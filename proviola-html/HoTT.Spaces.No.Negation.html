<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "1 subgoal, subgoal 1 (ID 1)	  	  ============================	  No -> No		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 18;
            data = "1 subgoal, subgoal 1 (ID 1)	  	  ============================	  No -> No		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 19;
            data = "5 subgoals, subgoal 1 (ID 42)	  	  L, R : Type	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), (fun x y : No => y < x) (fxL l) (fxR r)	  ============================	  No		subgoal 2 (ID 46) is:	 a = b	subgoal 3 (ID 66) is:	 (fun x y : No => y <= x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     ?Goal@{L:=L0; R:=R0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L R xL xR xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     ?Goal@{L:=L0; R:=R0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L' R' yL yR ycut fyL fyR fycut)	subgoal 4 (ID 85) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (xcut0 : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     ?Goal@{L:=L0; R:=R0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L R xL xR xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (xcut0 : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     ?Goal@{L:=L0; R:=R0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L' R' yL yR ycut fyL fyR fycut)	subgoal 5 (ID 104) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (xcut0 : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     ?Goal@{L:=L0; R:=R0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L R xL xR xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (xcut0 : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     ?Goal@{L:=L0; R:=R0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L' R' yL yR ycut fyL fyR fycut)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 20;
            data = "1 focused subgoal	(unfocused: 4), subgoal 1 (ID 42)	  	  L, R : Type	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), (fun x y : No => y < x) (fxL l) (fxR r)	  ============================	  No		(dependent evars: (printing disabled) )		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	4 subgoals, subgoal 1 (ID 46)		subgoal 1 (ID 46) is:	 a = b	subgoal 2 (ID 66) is:	 (fun x y : No => y <= x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r : R0), xL0 l < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L R xL xR xcut	      fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r : R0), xL0 l < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L' R' yL yR	      ycut fyL fyR fycut)	subgoal 3 (ID 85) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L R xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L' R' yL yR	      ycut fyL fyR fycut)	subgoal 4 (ID 104) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L R xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L' R' yL yR	      ycut fyL fyR fycut)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 21;
            data = "1 focused subgoal	(unfocused: 3), subgoal 1 (ID 46)	  	  a, b : No	  X : (fun x y : No => y <= x) a b	  X0 : (fun x y : No => y <= x) b a	  ============================	  a = b		(dependent evars: (printing disabled) )		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 subgoals, subgoal 1 (ID 66)		subgoal 1 (ID 66) is:	 (fun x y : No => y <= x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r : R0), xL0 l < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L R xL xR xcut	      fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r : R0), xL0 l < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L' R' yL yR	      ycut fyL fyR fycut)	subgoal 2 (ID 85) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L R xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L' R' yL yR	      ycut fyL fyR fycut)	subgoal 3 (ID 104) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L R xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L' R' yL yR	      ycut fyL fyR fycut)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 22;
            data = "1 focused subgoal	(unfocused: 2), subgoal 1 (ID 66)	  	  L, R : Type	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), (fun x y : No => y < x) (fxL l) (fxR r)	  L', R' : Type	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), (fun x y : No => y < x) (fyL l) (fyR r)	  p : forall l : L, xL l < {{ yL | yR // ycut }}	  dp : forall l : L,	       (fun x y : No => y < x) (fxL l)	         ((fun (L R : Type) (xL : L -> No) (xR : R -> No)	             (_ : forall (l0 : L) (r : R), xL l0 < xR r) 	             (fxL : L -> No) (fxR : R -> No)	             (fxcut : forall (l0 : L) (r : R),	                      (fun x y : No => y < x) (fxL l0) (fxR r)) =>	           {{ fxR | fxL // fun (r : R) (l0 : L) => fxcut l0 r }}) L' R' yL yR	            ycut fyL fyR fycut)	  q : forall r : R', {{ xL | xR // xcut }} < yR r	  dq : forall r : R',	       (fun x y : No => y < x)	         ((fun (L R : Type) (xL : L -> No) (xR : R -> No)	             (_ : forall (l : L) (r0 : R), xL l < xR r0) 	             (fxL : L -> No) (fxR : R -> No)	             (fxcut : forall (l : L) (r0 : R),	                      (fun x y : No => y < x) (fxL l) (fxR r0)) =>	           {{ fxR | fxL // fun (r0 : R) (l : L) => fxcut l r0 }}) L R xL xR	            xcut fxL fxR fxcut) (fyR r)	  ============================	  (fun x y : No => y <= x)	    ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	        (_ : forall (l : L0) (r : R0), xL0 l < xR0 r) 	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l : L0) (r : R0),	                  (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	      {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L R xL xR	       xcut fxL fxR fxcut)	    ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	        (_ : forall (l : L0) (r : R0), xL0 l < xR0 r) 	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l : L0) (r : R0),	                  (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	      {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L' R' yL yR	       ycut fyL fyR fycut)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 2), subgoal 1 (ID 131)	  	  L, R : Type	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), fxR r < fxL l	  L', R' : Type	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), fyR r < fyL l	  p : forall l : L, xL l < {{ yL | yR // ycut }}	  dp : forall l : L,	       {{ fyR | fyL // fun (r : R') (l0 : L') => fycut l0 r }} < fxL l	  q : forall r : R', {{ xL | xR // xcut }} < yR r	  dq : forall r : R',	       fyR r < {{ fxR | fxL // fun (r0 : R) (l : L) => fxcut l r0 }}	  ============================	  {{ fyR | fyL // fun (r : R') (l : L') => fycut l r }} <=	  {{ fxR | fxL // fun (r : R) (l : L) => fxcut l r }}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 23;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals, subgoal 1 (ID 85)		subgoal 1 (ID 85) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L R xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L' R' yL yR	      ycut fyL fyR fycut)	subgoal 2 (ID 104) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L R xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L' R' yL yR	      ycut fyL fyR fycut)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 24;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 85)	  	  L, R : Type	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), (fun x y : No => y < x) (fxL l) (fxR r)	  L', R' : Type	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), (fun x y : No => y < x) (fyL l) (fyR r)	  l : L'	  p : {{ xL | xR // xcut }} <= yL l	  dp : (fun x y : No => y <= x)	         ((fun (L R : Type) (xL : L -> No) (xR : R -> No)	             (_ : forall (l : L) (r : R), xL l < xR r) 	             (fxL : L -> No) (fxR : R -> No)	             (fxcut : forall (l : L) (r : R),	                      (fun x y : No => y < x) (fxL l) (fxR r)) =>	           {{ fxR | fxL // fun (r : R) (l : L) => fxcut l r }}) L R xL xR	            xcut fxL fxR fxcut) (fyL l)	  ============================	  (fun x y : No => y < x)	    ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	        (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l0 : L0) (r : R0),	                  (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	      {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L R xL xR	       xcut fxL fxR fxcut)	    ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	        (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l0 : L0) (r : R0),	                  (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	      {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L' R' yL yR	       ycut fyL fyR fycut)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 157)	  	  L, R : Type	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), fxR r < fxL l	  L', R' : Type	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), fyR r < fyL l	  l : L'	  p : {{ xL | xR // xcut }} <= yL l	  dp : fyL l <= {{ fxR | fxL // fun (r : R) (l : L) => fxcut l r }}	  ============================	  {{ fyR | fyL // fun (r : R') (l0 : L') => fycut l0 r }} <	  {{ fxR | fxL // fun (r : R) (l0 : L) => fxcut l0 r }}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 25;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 104)		subgoal 1 (ID 104) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L R xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	       (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L' R' yL yR	      ycut fyL fyR fycut)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 26;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 104)	  	  L, R : Type	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), (fun x y : No => y < x) (fxL l) (fxR r)	  L', R' : Type	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), (fun x y : No => y < x) (fyL l) (fyR r)	  r : R	  p : xR r <= {{ yL | yR // ycut }}	  dp : (fun x y : No => y <= x) (fxR r)	         ((fun (L R : Type) (xL : L -> No) (xR : R -> No)	             (_ : forall (l : L) (r : R), xL l < xR r) 	             (fxL : L -> No) (fxR : R -> No)	             (fxcut : forall (l : L) (r : R),	                      (fun x y : No => y < x) (fxL l) (fxR r)) =>	           {{ fxR | fxL // fun (r : R) (l : L) => fxcut l r }}) L' R' yL yR	            ycut fyL fyR fycut)	  ============================	  (fun x y : No => y < x)	    ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	        (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l : L0) (r0 : R0),	                  (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	      {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L R xL xR	       xcut fxL fxR fxcut)	    ((fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	        (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l : L0) (r0 : R0),	                  (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	      {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L' R' yL yR	       ycut fyL fyR fycut)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 180)	  	  L, R : Type	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), fxR r < fxL l	  L', R' : Type	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), fyR r < fyL l	  r : R	  p : xR r <= {{ yL | yR // ycut }}	  dp : {{ fyR | fyL // fun (r : R') (l : L') => fycut l r }} <= fxR r	  ============================	  {{ fyR | fyL // fun (r0 : R') (l : L') => fycut l r0 }} <	  {{ fxR | fxL // fun (r0 : R) (l : L) => fxcut l r0 }}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 27;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 28;
            data = "<infomsg>negate is defined</infomsg>	";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "";
            responses[i]=data;
          

            i = 32;
            data = "";
            responses[i]=data;
          

            i = 33;
            data = "";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "1 subgoal, subgoal 1 (ID 3)	  	  ============================	  negate one = minusone		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 36;
            data = "1 subgoal, subgoal 1 (ID 3)	  	  ============================	  negate one = minusone		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 37;
            data = "4 subgoals, subgoal 1 (ID 16)	  	  l : Empty	  ============================	  (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	     match xno with	     | isno L R xL xR i i0 g =>	         Core.Surreals.No_ind_internal_step (fun _ : No => No)	           (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	           (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0) =>	            {{ fxR | fxL // fun (r : R0) (l0 : L0) => fxcut l0 r }})	           (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	              (dp : b <= a) (dq : a <= b) =>	            transport_const (path_No p q) a @ path_No dq dp)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (xcut : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (ycut : forall (l0 : L') (r : R'), yL l0 < yR r)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0)	              (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	              (dp : forall l0 : L0,	                    {{ fyR | fyL // fun (r : R') (l1 : L') => fycut l1 r }} <	                    fxL l0)	              (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	              (dq : forall r : R',	                    fyR r <	                    {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	            =>	            le_lr fyR fyL (fun (r : R') (l0 : L') => fycut l0 r) fxR fxL	              (fun (r : R0) (l0 : L0) => fxcut l0 r) 	              (fun l0 : R' => dq l0) (fun r : L0 => dp r))	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (xcut : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (_ : forall (l0 : L') (r : R'), yL l0 < yR r) 	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0) 	              (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	              (dp : fyL l0 <=	                    {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	            =>	            lt_r fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	              (fun (r : R0) (l1 : L0) => fxcut l1 r) l0 dp)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (ycut : forall (l0 : L') (r : R'), yL l0 < yR r)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0) 	              (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	              (dp : {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <=	                    fxR r) =>	            lt_l fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	              (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) r dp) No_ind_internal	           (opt xL xR) (isno L R xL xR i i0 g)	     end) (game_of (Empty_rec l)) (isno_game_of (Empty_rec l)) <	  {{ Empty_rec | unit_name zero // Empty_ind	                                     (fun e : Empty =>	                                      Unit -> Empty_rec e < zero) }}		subgoal 2 (ID 17) is:	 {{ fun r0 : Empty =>	    (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : No => No)	             (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l) =>	              {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	             (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No p q) a @ path_No dq dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	                (dp : forall l : L0,	                      {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <	                      fxL l)	                (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                (dq : forall r1 : R',	                      fyR r1 <	                      {{ fxR | fxL // fun (r2 : R0) (l : L0) => fxcut l r2 }})	              =>	              le_lr fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	                (fun (r1 : R0) (l : L0) => fxcut l r1) 	                (fun l : R' => dq l) (fun r1 : L0 => dp r1))	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (_ : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	                (dp : fyL l <=	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              lt_r fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) l dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r2 : R') (l : L') => fycut l r2 }} <=	                      fxR r1) =>	              lt_l fyR fyL (fun (r2 : R') (l : L') => fycut l r2) fxR fxL	                (fun (r2 : R0) (l : L0) => fxcut l r2) r1 dp) No_ind_internal	             (opt xL xR) (isno L R xL xR i i0 g)	       end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) | 	 unit_name	   ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : No => No)	             (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	              {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	             (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No p q) a @ path_No dq dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                (dp : forall l0 : L0,	                      {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                      fxL l0)	                (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                (dq : forall r0 : R',	                      fyR r0 <	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                (dp : fyL l0 <=	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                      fxR r0) =>	              lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	             No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	       end) (game_of zero) (isno_game_of zero)) // 	 fun r0 : Empty =>	 unit_name	   match	     No_Empty_admitted	     return	       ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	           No :=	           match xno with	           | isno L R xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : No => No)	                 (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                  {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                 (fun (x1 y a b : No) (p : x1 <= y) 	                    (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                  transport_const (path_No p q) a @ path_No dq dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                    (dp : forall l0 : L0,	                          {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} < 	                          fxL l0)	                    (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                    (dq : forall r1 : R',	                          fyR r1 <	                          {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                          fxcut l0 r2 }}) =>	                  le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                    fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                    (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                    (dp : fyL l0 <=	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                          fycut l0 r2 }} <= 	                          fxR r1) =>	                  lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                    fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                 No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	           end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) <	        (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	           No :=	           match xno with	           | isno L R xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : No => No)	                 (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                  {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                 (fun (x1 y a b : No) (p : x1 <= y) 	                    (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                  transport_const (path_No p q) a @ path_No dq dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                    (dp : forall l0 : L0,	                          {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} < 	                          fxL l0)	                    (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                    (dq : forall r1 : R',	                          fyR r1 <	                          {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                          fxcut l0 r2 }}) =>	                  le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                    fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                    (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                    (dp : fyL l0 <=	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                          fycut l0 r2 }} <= 	                          fxR r1) =>	                  lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                    fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                 No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	           end) (game_of zero) (isno_game_of zero))	   with	   end }} < zero	subgoal 3 (ID 18) is:	 Empty_rec l <	 {{ fun r : Empty =>	    (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : No => No)	             (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	              {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	             (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No p q) a @ path_No dq dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                (dp : forall l0 : L0,	                      {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                      fxL l0)	                (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                (dq : forall r0 : R',	                      fyR r0 <	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                (dp : fyL l0 <=	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                      fxR r0) =>	              lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	             No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	       end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) | 	 unit_name	   ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : No => No)	             (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1) =>	              {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	             (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No p q) a @ path_No dq dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1)	                (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                (dp : forall l1 : L0,	                      {{ fyR | fyL // fun (r : R') (l2 : L') => fycut l2 r }} <	                      fxL l1)	                (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	                (dq : forall r : R',	                      fyR r <	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              le_lr fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	                (fun (r : R0) (l1 : L0) => fxcut l1 r) 	                (fun l1 : R' => dq l1) (fun r : L0 => dp r))	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (_ : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                (dp : fyL l1 <=	                      {{ fxR | fxL // fun (r : R0) (l2 : L0) => fxcut l2 r }})	              =>	              lt_r fyR fyL (fun (r : R') (l2 : L') => fycut l2 r) fxR fxL	                (fun (r : R0) (l2 : L0) => fxcut l2 r) l1 dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <=	                      fxR r) =>	              lt_l fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) r dp)	             No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	       end) (game_of zero) (isno_game_of zero)) // 	 fun r : Empty =>	 unit_name	   match	     No_Empty_admitted	     return	       ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	           No :=	           match xno with	           | isno L R xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : No => No)	                 (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y a b : No) (p : x1 <= y) 	                    (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                  transport_const (path_No p q) a @ path_No dq dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	           end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) <	        (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	           No :=	           match xno with	           | isno L R xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : No => No)	                 (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y a b : No) (p : x1 <= y) 	                    (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                  transport_const (path_No p q) a @ path_No dq dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	           end) (game_of zero) (isno_game_of zero))	   with	   end }}	subgoal 4 (ID 19) is:	 {{ Empty_rec | unit_name zero // Empty_ind	                                    (fun e : Empty =>	                                     Unit -> Empty_rec e < zero) }} <	 (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	    match xno with	    | isno L R xL xR i i0 g =>	        Core.Surreals.No_ind_internal_step (fun _ : No => No)	          (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	          (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	           {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	          (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	             (dp : b <= a) (dq : a <= b) =>	           transport_const (path_No p q) a @ path_No dq dp)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	             (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	             (dp : forall l : L0,	                   {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                   fxL l)	             (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	             (dq : forall r0 : R',	                   fyR r0 <	                   {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	           =>	           le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	             (fun (r0 : R0) (l : L0) => fxcut l r0) 	             (fun l : R' => dq l) (fun r0 : L0 => dp r0))	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	             (dp : fyL l <=	                   {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	           =>	           lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	             (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	             (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                   fxR r0) =>	           lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	             (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	          (opt xL xR) (isno L R xL xR i i0 g)	    end) (game_of zero) (isno_game_of zero)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "";
            responses[i]=data;
          

            i = 41;
            data = "";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "";
            responses[i]=data;
          

            i = 45;
            data = "";
            responses[i]=data;
          

            i = 46;
            data = "1 focused subgoal	(unfocused: 3), subgoal 1 (ID 16)	  	  l : Empty	  ============================	  (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	     match xno with	     | isno L R xL xR i i0 g =>	         Core.Surreals.No_ind_internal_step (fun _ : No => No)	           (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	           (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0) =>	            {{ fxR | fxL // fun (r : R0) (l0 : L0) => fxcut l0 r }})	           (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	              (dp : b <= a) (dq : a <= b) =>	            transport_const (path_No p q) a @ path_No dq dp)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (xcut : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (ycut : forall (l0 : L') (r : R'), yL l0 < yR r)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0)	              (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	              (dp : forall l0 : L0,	                    {{ fyR | fyL // fun (r : R') (l1 : L') => fycut l1 r }} <	                    fxL l0)	              (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	              (dq : forall r : R',	                    fyR r <	                    {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	            =>	            le_lr fyR fyL (fun (r : R') (l0 : L') => fycut l0 r) fxR fxL	              (fun (r : R0) (l0 : L0) => fxcut l0 r) 	              (fun l0 : R' => dq l0) (fun r : L0 => dp r))	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (xcut : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (_ : forall (l0 : L') (r : R'), yL l0 < yR r) 	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0) 	              (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	              (dp : fyL l0 <=	                    {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	            =>	            lt_r fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	              (fun (r : R0) (l1 : L0) => fxcut l1 r) l0 dp)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (ycut : forall (l0 : L') (r : R'), yL l0 < yR r)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0) 	              (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	              (dp : {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <=	                    fxR r) =>	            lt_l fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	              (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) r dp) No_ind_internal	           (opt xL xR) (isno L R xL xR i i0 g)	     end) (game_of (Empty_rec l)) (isno_game_of (Empty_rec l)) <	  {{ Empty_rec | unit_name zero // Empty_ind	                                     (fun e : Empty =>	                                      Unit -> Empty_rec e < zero) }}		(dependent evars: (printing disabled) )		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	";
            responses[i]=data;
          

            i = 47;
            data = "3 subgoals, subgoal 1 (ID 17)		subgoal 1 (ID 17) is:	 {{ fun r0 : Empty =>	    (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : No => No)	             (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l) =>	              {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	             (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No p q) a @ path_No dq dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	                (dp : forall l : L0,	                      {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <	                      fxL l)	                (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                (dq : forall r1 : R',	                      fyR r1 <	                      {{ fxR | fxL // fun (r2 : R0) (l : L0) => fxcut l r2 }})	              =>	              le_lr fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	                (fun (r1 : R0) (l : L0) => fxcut l r1) 	                (fun l : R' => dq l) (fun r1 : L0 => dp r1))	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (_ : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	                (dp : fyL l <=	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              lt_r fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) l dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r2 : R') (l : L') => fycut l r2 }} <=	                      fxR r1) =>	              lt_l fyR fyL (fun (r2 : R') (l : L') => fycut l r2) fxR fxL	                (fun (r2 : R0) (l : L0) => fxcut l r2) r1 dp) No_ind_internal	             (opt xL xR) (isno L R xL xR i i0 g)	       end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) | 	 unit_name	   ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : No => No)	             (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	              {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	             (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No p q) a @ path_No dq dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                (dp : forall l0 : L0,	                      {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                      fxL l0)	                (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                (dq : forall r0 : R',	                      fyR r0 <	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                (dp : fyL l0 <=	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                      fxR r0) =>	              lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	             No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	       end) (game_of zero) (isno_game_of zero)) // 	 fun r0 : Empty =>	 unit_name	   match	     No_Empty_admitted	     return	       ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	           No :=	           match xno with	           | isno L R xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : No => No)	                 (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                  {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                 (fun (x1 y a b : No) (p : x1 <= y) 	                    (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                  transport_const (path_No p q) a @ path_No dq dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                    (dp : forall l0 : L0,	                          {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} < 	                          fxL l0)	                    (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                    (dq : forall r1 : R',	                          fyR r1 <	                          {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                          fxcut l0 r2 }}) =>	                  le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                    fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                    (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                    (dp : fyL l0 <=	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                          fycut l0 r2 }} <= 	                          fxR r1) =>	                  lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                    fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                 No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	           end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) <	        (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	           No :=	           match xno with	           | isno L R xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : No => No)	                 (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                  {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                 (fun (x1 y a b : No) (p : x1 <= y) 	                    (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                  transport_const (path_No p q) a @ path_No dq dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                    (dp : forall l0 : L0,	                          {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} < 	                          fxL l0)	                    (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                    (dq : forall r1 : R',	                          fyR r1 <	                          {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                          fxcut l0 r2 }}) =>	                  le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                    fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                    (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                    (dp : fyL l0 <=	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                          fycut l0 r2 }} <= 	                          fxR r1) =>	                  lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                    fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                 No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	           end) (game_of zero) (isno_game_of zero))	   with	   end }} < zero	subgoal 2 (ID 18) is:	 Empty_rec l <	 {{ fun r : Empty =>	    (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : No => No)	             (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	              {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	             (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No p q) a @ path_No dq dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                (dp : forall l0 : L0,	                      {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                      fxL l0)	                (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                (dq : forall r0 : R',	                      fyR r0 <	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                (dp : fyL l0 <=	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                      fxR r0) =>	              lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	             No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	       end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) | 	 unit_name	   ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : No => No)	             (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1) =>	              {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	             (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No p q) a @ path_No dq dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1)	                (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                (dp : forall l1 : L0,	                      {{ fyR | fyL // fun (r : R') (l2 : L') => fycut l2 r }} <	                      fxL l1)	                (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	                (dq : forall r : R',	                      fyR r <	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              le_lr fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	                (fun (r : R0) (l1 : L0) => fxcut l1 r) 	                (fun l1 : R' => dq l1) (fun r : L0 => dp r))	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (_ : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                (dp : fyL l1 <=	                      {{ fxR | fxL // fun (r : R0) (l2 : L0) => fxcut l2 r }})	              =>	              lt_r fyR fyL (fun (r : R') (l2 : L') => fycut l2 r) fxR fxL	                (fun (r : R0) (l2 : L0) => fxcut l2 r) l1 dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <=	                      fxR r) =>	              lt_l fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) r dp)	             No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	       end) (game_of zero) (isno_game_of zero)) // 	 fun r : Empty =>	 unit_name	   match	     No_Empty_admitted	     return	       ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	           No :=	           match xno with	           | isno L R xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : No => No)	                 (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y a b : No) (p : x1 <= y) 	                    (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                  transport_const (path_No p q) a @ path_No dq dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	           end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) <	        (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	           No :=	           match xno with	           | isno L R xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : No => No)	                 (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y a b : No) (p : x1 <= y) 	                    (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                  transport_const (path_No p q) a @ path_No dq dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	           end) (game_of zero) (isno_game_of zero))	   with	   end }}	subgoal 3 (ID 19) is:	 {{ Empty_rec | unit_name zero // Empty_ind	                                    (fun e : Empty =>	                                     Unit -> Empty_rec e < zero) }} <	 (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	    match xno with	    | isno L R xL xR i i0 g =>	        Core.Surreals.No_ind_internal_step (fun _ : No => No)	          (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	          (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	           {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	          (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	             (dp : b <= a) (dq : a <= b) =>	           transport_const (path_No p q) a @ path_No dq dp)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	             (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	             (dp : forall l : L0,	                   {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                   fxL l)	             (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	             (dq : forall r0 : R',	                   fyR r0 <	                   {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	           =>	           le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	             (fun (r0 : R0) (l : L0) => fxcut l r0) 	             (fun l : R' => dq l) (fun r0 : L0 => dp r0))	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	             (dp : fyL l <=	                   {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	           =>	           lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	             (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	             (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                   fxR r0) =>	           lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	             (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	          (opt xL xR) (isno L R xL xR i i0 g)	    end) (game_of zero) (isno_game_of zero)	(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 2), subgoal 1 (ID 17)	  	  r : Unit	  ============================	  {{ fun r0 : Empty =>	     (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} :	        No :=	        match xno with	        | isno L R xL xR i i0 g =>	            Core.Surreals.No_ind_internal_step (fun _ : No => No)	              (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	              (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l) =>	               {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	              (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                 (dp : b <= a) (dq : a <= b) =>	               transport_const (path_No p q) a @ path_No dq dp)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                 (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	                 (dp : forall l : L0,	                       {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <	                       fxL l)	                 (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                 (dq : forall r1 : R',	                       fyR r1 <	                       {{ fxR | fxL // fun (r2 : R0) (l : L0) => fxcut l r2 }})	               =>	               le_lr fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	                 (fun (r1 : R0) (l : L0) => fxcut l r1) 	                 (fun l : R' => dq l) (fun r1 : L0 => dp r1))	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (_ : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                 (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	                 (dp : fyL l <=	                       {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	               =>	               lt_r fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                 (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) l dp)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                 (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                 (dp : {{ fyR | fyL // fun (r2 : R') (l : L') => fycut l r2 }} <=	                       fxR r1) =>	               lt_l fyR fyL (fun (r2 : R') (l : L') => fycut l r2) fxR fxL	                 (fun (r2 : R0) (l : L0) => fxcut l r2) r1 dp)	              No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	        end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) | 	  unit_name	    ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} :	        No :=	        match xno with	        | isno L R xL xR i i0 g =>	            Core.Surreals.No_ind_internal_step (fun _ : No => No)	              (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	              (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	               {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	              (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                 (dp : b <= a) (dq : a <= b) =>	               transport_const (path_No p q) a @ path_No dq dp)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                 (dp : forall l0 : L0,	                       {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                       fxL l0)	                 (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                 (dq : forall r0 : R',	                       fyR r0 <	                       {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	               =>	               le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                 (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                 (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                 (dp : fyL l0 <=	                       {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	               =>	               lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                 (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                 (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                       fxR r0) =>	               lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                 (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	              No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	        end) (game_of zero) (isno_game_of zero)) // 	  fun r0 : Empty =>	  unit_name	    match	      No_Empty_admitted	      return	        ((fix	          No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	            No :=	            match xno with	            | isno L R xL xR i i0 g =>	                Core.Surreals.No_ind_internal_step 	                  (fun _ : No => No)	                  (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                  (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                   {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                  (fun (x1 y a b : No) (p : x1 <= y) 	                     (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                   transport_const (path_No p q) a @ path_No dq dp)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                     (dp : forall l0 : L0,	                           {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                           fycut l1 r1 }} < 	                           fxL l0)	                     (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                     (dq : forall r1 : R',	                           fyR r1 <	                           {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                           fxcut l0 r2 }}) =>	                   le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                     fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                     (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                     (dp : fyL l0 <=	                           {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                           fxcut l1 r1 }}) =>	                   lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                     fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                     (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                           fycut l0 r2 }} <= 	                           fxR r1) =>	                   lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                     fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                  No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	            end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) <	         (fix	          No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	            No :=	            match xno with	            | isno L R xL xR i i0 g =>	                Core.Surreals.No_ind_internal_step 	                  (fun _ : No => No)	                  (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                  (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                   {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                  (fun (x1 y a b : No) (p : x1 <= y) 	                     (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                   transport_const (path_No p q) a @ path_No dq dp)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                     (dp : forall l0 : L0,	                           {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                           fycut l1 r1 }} < 	                           fxL l0)	                     (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                     (dq : forall r1 : R',	                           fyR r1 <	                           {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                           fxcut l0 r2 }}) =>	                   le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                     fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                     (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                     (dp : fyL l0 <=	                           {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                           fxcut l1 r1 }}) =>	                   lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                     fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                     (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                           fycut l0 r2 }} <= 	                           fxR r1) =>	                   lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                     fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                  No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	            end) (game_of zero) (isno_game_of zero))	    with	    end }} < zero		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 2), subgoal 1 (ID 22)	  	  r : Unit	  ============================	  (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	     match xno with	     | isno L R xL xR i i0 g =>	         Core.Surreals.No_ind_internal_step (fun _ : No => No)	           (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	           (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	            {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	           (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	              (dp : b <= a) (dq : a <= b) =>	            transport_const (path_No p q) a @ path_No dq dp)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	              (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	              (dp : forall l : L0,	                    {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                    fxL l)	              (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	              (dq : forall r0 : R',	                    fyR r0 <	                    {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	            =>	            le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	              (fun (r0 : R0) (l : L0) => fxcut l r0) 	              (fun l : R' => dq l) (fun r0 : L0 => dp r0))	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	              (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	              (dp : fyL l <=	                    {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	            =>	            lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	              (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	              (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	              (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                    fxR r0) =>	            lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	              (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	           (opt xL xR) (isno L R xL xR i i0 g)	     end) (game_of zero) (isno_game_of zero) <=	  {{ Empty_rec | Empty_rec // Empty_ind	                                (fun x : Empty =>	                                 forall y : Empty, Empty_rec x < Empty_rec y) }}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 48;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals, subgoal 1 (ID 18)		subgoal 1 (ID 18) is:	 Empty_rec l <	 {{ fun r : Empty =>	    (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : No => No)	             (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	              {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	             (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No p q) a @ path_No dq dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                (dp : forall l0 : L0,	                      {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                      fxL l0)	                (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                (dq : forall r0 : R',	                      fyR r0 <	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                (dp : fyL l0 <=	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                      fxR r0) =>	              lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	             No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	       end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) | 	 unit_name	   ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : No => No)	             (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1) =>	              {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	             (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No p q) a @ path_No dq dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1)	                (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                (dp : forall l1 : L0,	                      {{ fyR | fyL // fun (r : R') (l2 : L') => fycut l2 r }} <	                      fxL l1)	                (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	                (dq : forall r : R',	                      fyR r <	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              le_lr fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	                (fun (r : R0) (l1 : L0) => fxcut l1 r) 	                (fun l1 : R' => dq l1) (fun r : L0 => dp r))	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (_ : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                (dp : fyL l1 <=	                      {{ fxR | fxL // fun (r : R0) (l2 : L0) => fxcut l2 r }})	              =>	              lt_r fyR fyL (fun (r : R') (l2 : L') => fycut l2 r) fxR fxL	                (fun (r : R0) (l2 : L0) => fxcut l2 r) l1 dp)	             (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                (xR0 : R0 -> No)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <=	                      fxR r) =>	              lt_l fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) r dp)	             No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	       end) (game_of zero) (isno_game_of zero)) // 	 fun r : Empty =>	 unit_name	   match	     No_Empty_admitted	     return	       ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	           No :=	           match xno with	           | isno L R xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : No => No)	                 (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y a b : No) (p : x1 <= y) 	                    (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                  transport_const (path_No p q) a @ path_No dq dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	           end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) <	        (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	           No :=	           match xno with	           | isno L R xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : No => No)	                 (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y a b : No) (p : x1 <= y) 	                    (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                  transport_const (path_No p q) a @ path_No dq dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                    (xR0 : R0 -> No)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (yL : L' -> No) 	                    (yR : R' -> No)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	           end) (game_of zero) (isno_game_of zero))	   with	   end }}	subgoal 2 (ID 19) is:	 {{ Empty_rec | unit_name zero // Empty_ind	                                    (fun e : Empty =>	                                     Unit -> Empty_rec e < zero) }} <	 (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	    match xno with	    | isno L R xL xR i i0 g =>	        Core.Surreals.No_ind_internal_step (fun _ : No => No)	          (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	          (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	           {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	          (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	             (dp : b <= a) (dq : a <= b) =>	           transport_const (path_No p q) a @ path_No dq dp)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	             (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	             (dp : forall l : L0,	                   {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                   fxL l)	             (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	             (dq : forall r0 : R',	                   fyR r0 <	                   {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	           =>	           le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	             (fun (r0 : R0) (l : L0) => fxcut l r0) 	             (fun l : R' => dq l) (fun r0 : L0 => dp r0))	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	             (dp : fyL l <=	                   {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	           =>	           lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	             (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	             (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                   fxR r0) =>	           lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	             (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	          (opt xL xR) (isno L R xL xR i i0 g)	    end) (game_of zero) (isno_game_of zero)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 49;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 18)	  	  l : Empty	  ============================	  Empty_rec l <	  {{ fun r : Empty =>	     (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} :	        No :=	        match xno with	        | isno L R xL xR i i0 g =>	            Core.Surreals.No_ind_internal_step (fun _ : No => No)	              (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	              (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	               {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	              (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                 (dp : b <= a) (dq : a <= b) =>	               transport_const (path_No p q) a @ path_No dq dp)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                 (dp : forall l0 : L0,	                       {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                       fxL l0)	                 (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                 (dq : forall r0 : R',	                       fyR r0 <	                       {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	               =>	               le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                 (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                 (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                 (dp : fyL l0 <=	                       {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	               =>	               lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                 (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                 (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                       fxR r0) =>	               lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                 (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	              No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	        end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) | 	  unit_name	    ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} :	        No :=	        match xno with	        | isno L R xL xR i i0 g =>	            Core.Surreals.No_ind_internal_step (fun _ : No => No)	              (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	              (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1) =>	               {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	              (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                 (dp : b <= a) (dq : a <= b) =>	               transport_const (path_No p q) a @ path_No dq dp)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1)	                 (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                 (dp : forall l1 : L0,	                       {{ fyR | fyL // fun (r : R') (l2 : L') => fycut l2 r }} <	                       fxL l1)	                 (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	                 (dq : forall r : R',	                       fyR r <	                       {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	               =>	               le_lr fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	                 (fun (r : R0) (l1 : L0) => fxcut l1 r)	                 (fun l1 : R' => dq l1) (fun r : L0 => dp r))	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (_ : forall (l1 : L') (r : R'), yL l1 < yR r)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1)	                 (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                 (dp : fyL l1 <=	                       {{ fxR | fxL // fun (r : R0) (l2 : L0) => fxcut l2 r }})	               =>	               lt_r fyR fyL (fun (r : R') (l2 : L') => fycut l2 r) fxR fxL	                 (fun (r : R0) (l2 : L0) => fxcut l2 r) l1 dp)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                 (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	                 (dp : {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <=	                       fxR r) =>	               lt_l fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                 (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) r dp)	              No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	        end) (game_of zero) (isno_game_of zero)) // 	  fun r : Empty =>	  unit_name	    match	      No_Empty_admitted	      return	        ((fix	          No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	            No :=	            match xno with	            | isno L R xL xR i i0 g =>	                Core.Surreals.No_ind_internal_step 	                  (fun _ : No => No)	                  (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                  (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                   {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                  (fun (x1 y a b : No) (p : x1 <= y) 	                     (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                   transport_const (path_No p q) a @ path_No dq dp)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                     (dp : forall l1 : L0,	                           {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                           fycut l2 r0 }} < 	                           fxL l1)	                     (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                     (dq : forall r0 : R',	                           fyR r0 <	                           {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                           fxcut l1 r1 }}) =>	                   le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                     fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                     (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                     (dp : fyL l1 <=	                           {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                           fxcut l2 r0 }}) =>	                   lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                     fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                     (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                           fycut l1 r1 }} <= 	                           fxR r0) =>	                   lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                     fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                  No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	            end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) <	         (fix	          No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	            No :=	            match xno with	            | isno L R xL xR i i0 g =>	                Core.Surreals.No_ind_internal_step 	                  (fun _ : No => No)	                  (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                  (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                   {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                  (fun (x1 y a b : No) (p : x1 <= y) 	                     (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                   transport_const (path_No p q) a @ path_No dq dp)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                     (dp : forall l1 : L0,	                           {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                           fycut l2 r0 }} < 	                           fxL l1)	                     (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                     (dq : forall r0 : R',	                           fyR r0 <	                           {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                           fxcut l1 r1 }}) =>	                   le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                     fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                     (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                     (dp : fyL l1 <=	                           {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                           fxcut l2 r0 }}) =>	                   lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                     fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                  (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                     (xR0 : R0 -> No)	                     (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (yL : L' -> No) 	                     (yR : R' -> No)	                     (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                     (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                           fycut l1 r1 }} <= 	                           fxR r0) =>	                   lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                     fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                  No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	            end) (game_of zero) (isno_game_of zero))	    with	    end }}		(dependent evars: (printing disabled) )		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 19)		subgoal 1 (ID 19) is:	 {{ Empty_rec | unit_name zero // Empty_ind	                                    (fun e : Empty =>	                                     Unit -> Empty_rec e < zero) }} <	 (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	    match xno with	    | isno L R xL xR i i0 g =>	        Core.Surreals.No_ind_internal_step (fun _ : No => No)	          (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	          (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	           {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	          (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	             (dp : b <= a) (dq : a <= b) =>	           transport_const (path_No p q) a @ path_No dq dp)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	             (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	             (dp : forall l : L0,	                   {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                   fxL l)	             (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	             (dq : forall r0 : R',	                   fyR r0 <	                   {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	           =>	           le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	             (fun (r0 : R0) (l : L0) => fxcut l r0) 	             (fun l : R' => dq l) (fun r0 : L0 => dp r0))	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	             (dp : fyL l <=	                   {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	           =>	           lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	             (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	          (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	             (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                   fxR r0) =>	           lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	             (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	          (opt xL xR) (isno L R xL xR i i0 g)	    end) (game_of zero) (isno_game_of zero)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 50;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 19)	  	  r : Unit	  ============================	  {{ Empty_rec | unit_name zero // Empty_ind	                                     (fun e : Empty =>	                                      Unit -> Empty_rec e < zero) }} <	  (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	     match xno with	     | isno L R xL xR i i0 g =>	         Core.Surreals.No_ind_internal_step (fun _ : No => No)	           (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	           (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	            {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	           (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	              (dp : b <= a) (dq : a <= b) =>	            transport_const (path_No p q) a @ path_No dq dp)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	              (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	              (dp : forall l : L0,	                    {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                    fxL l)	              (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	              (dq : forall r0 : R',	                    fyR r0 <	                    {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	            =>	            le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	              (fun (r0 : R0) (l : L0) => fxcut l r0) 	              (fun l : R' => dq l) (fun r0 : L0 => dp r0))	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	              (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	              (dp : fyL l <=	                    {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	            =>	            lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	              (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	           (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	              (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	              (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	              (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	              (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                    fxR r0) =>	            lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	              (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	           (opt xL xR) (isno L R xL xR i i0 g)	     end) (game_of zero) (isno_game_of zero)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 29)	  	  r : Unit	  ============================	  zero <=	  {{ fun r0 : Empty =>	     (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} :	        No :=	        match xno with	        | isno L R xL xR i i0 g =>	            Core.Surreals.No_ind_internal_step (fun _ : No => No)	              (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	              (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l) =>	               {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	              (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	                 (dp : b <= a) (dq : a <= b) =>	               transport_const (path_No p q) a @ path_No dq dp)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                 (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	                 (dp : forall l : L0,	                       {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <	                       fxL l)	                 (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                 (dq : forall r1 : R',	                       fyR r1 <	                       {{ fxR | fxL // fun (r2 : R0) (l : L0) => fxcut l r2 }})	               =>	               le_lr fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	                 (fun (r1 : R0) (l : L0) => fxcut l r1) 	                 (fun l : R' => dq l) (fun r1 : L0 => dp r1))	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (_ : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                 (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	                 (dp : fyL l <=	                       {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	               =>	               lt_r fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                 (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) l dp)	              (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                 (xR0 : R0 -> No)	                 (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	                 (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                 (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                 (dp : {{ fyR | fyL // fun (r2 : R') (l : L') => fycut l r2 }} <=	                       fxR r1) =>	               lt_l fyR fyL (fun (r2 : R') (l : L') => fycut l r2) fxR fxL	                 (fun (r2 : R0) (l : L0) => fxcut l r2) r1 dp)	              No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	        end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) | 	  (fun l : Empty =>	   (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	      match xno with	      | isno L R xL xR i i0 g =>	          Core.Surreals.No_ind_internal_step (fun _ : No => No)	            (fun (x0 y : No) (_ : x0 <= y) (a b : No) => b <= a)	            (fun (x0 y : No) (_ : x0 < y) (a b : No) => b < a)	            (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	               (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	               (fxL : L0 -> No) (fxR : R0 -> No)	               (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	             {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	            (fun (x0 y a b : No) (p : x0 <= y) (q : y <= x0) 	               (dp : b <= a) (dq : a <= b) =>	             transport_const (path_No p q) a @ path_No dq dp)	            (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	               (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	               (fxL : L0 -> No) (fxR : R0 -> No)	               (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	               (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	               (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	               (fyL : L' -> No) (fyR : R' -> No)	               (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	               (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	               (dp : forall l0 : L0,	                     {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                     fxL l0)	               (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	               (dq : forall r0 : R',	                     fyR r0 <	                     {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	             =>	             le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	               (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	               (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	            (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	               (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	               (fxL : L0 -> No) (fxR : R0 -> No)	               (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	               (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	               (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	               (fyL : L' -> No) (fyR : R' -> No)	               (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	               (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	               (dp : fyL l0 <=	                     {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	             =>	             lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	               (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	            (fun (L0 R0 : Type) (xL0 : L0 -> No) (xR0 : R0 -> No)	               (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	               (fxL : L0 -> No) (fxR : R0 -> No)	               (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	               (L' R' : Type) (yL : L' -> No) (yR : R' -> No)	               (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	               (fyL : L' -> No) (fyR : R' -> No)	               (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	               (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	               (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                     fxR r0) =>	             lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	               (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	            No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	      end) (game_of (Empty_rec l)) (isno_game_of (Empty_rec l))) // 	  fun r0 l : Empty =>	  match	    No_Empty_admitted	    return	      ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	          No :=	          match xno with	          | isno L R xL xR i i0 g =>	              Core.Surreals.No_ind_internal_step (fun _ : No => No)	                (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                   (xR0 : R0 -> No)	                   (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                 {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                (fun (x1 y a b : No) (p : x1 <= y) 	                   (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                 transport_const (path_No p q) a @ path_No dq dp)	                (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                   (xR0 : R0 -> No)	                   (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (yL : L' -> No) 	                   (yR : R' -> No)	                   (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                   (dp : forall l0 : L0,	                         {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                         fycut l1 r1 }} < 	                         fxL l0)	                   (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                   (dq : forall r1 : R',	                         fyR r1 <	                         {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                         fxcut l0 r2 }}) =>	                 le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                   fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                   (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                   (xR0 : R0 -> No)	                   (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (yL : L' -> No) 	                   (yR : R' -> No)	                   (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                   (dp : fyL l0 <=	                         {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                         fxcut l1 r1 }}) =>	                 lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                   fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                   (xR0 : R0 -> No)	                   (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (yL : L' -> No) 	                   (yR : R' -> No)	                   (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                   (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                         fycut l0 r2 }} <= 	                         fxR r1) =>	                 lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                   fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	          end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) <	       (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	          No :=	          match xno with	          | isno L R xL xR i i0 g =>	              Core.Surreals.No_ind_internal_step (fun _ : No => No)	                (fun (x1 y : No) (_ : x1 <= y) (a b : No) => b <= a)	                (fun (x1 y : No) (_ : x1 < y) (a b : No) => b < a)	                (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                   (xR0 : R0 -> No)	                   (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                 {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                (fun (x1 y a b : No) (p : x1 <= y) 	                   (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                 transport_const (path_No p q) a @ path_No dq dp)	                (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                   (xR0 : R0 -> No)	                   (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (yL : L' -> No) 	                   (yR : R' -> No)	                   (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                   (dp : forall l0 : L0,	                         {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                         fycut l1 r1 }} < 	                         fxL l0)	                   (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                   (dq : forall r1 : R',	                         fyR r1 <	                         {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                         fxcut l0 r2 }}) =>	                 le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                   fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                   (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                   (xR0 : R0 -> No)	                   (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (yL : L' -> No) 	                   (yR : R' -> No)	                   (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                   (dp : fyL l0 <=	                         {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                         fxcut l1 r1 }}) =>	                 lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                   fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                (fun (L0 R0 : Type) (xL0 : L0 -> No) 	                   (xR0 : R0 -> No)	                   (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (yL : L' -> No) 	                   (yR : R' -> No)	                   (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                   (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                         fycut l0 r2 }} <= 	                         fxR r1) =>	                 lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                   fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                No_ind_internal (opt xL xR) (isno L R xL xR i i0 g)	          end) (game_of (Empty_rec l)) (isno_game_of (Empty_rec l)))	  with	  end }}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 51;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 52;
            data = "<infomsg>Unnamed_thm is defined</infomsg>	";
            responses[i]=data;
          

            i = 53;
            data = "";
            responses[i]=data;
          

            i = 54;
            data = "";
            responses[i]=data;
          

            i = 55;
            data = "";
            responses[i]=data;
          

            i = 56;
            data = "";
            responses[i]=data;
          

            i = 57;
            data = "";
            responses[i]=data;
          

            i = 58;
            data = "";
            responses[i]=data;
          

            i = 59;
            data = "";
            responses[i]=data;
          

            i = 60;
            data = "";
            responses[i]=data;
          

            i = 61;
            data = "";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Spaces.No.Negation</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Spaces.No.Core.html#"><span class="id" title="library">HoTT.Spaces.No.Core</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">surreal_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(10, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a name="lab444"></a><h1 class="section">Negation of surreal numbers</h1>
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(17, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="negate"><span class="id" title="definition">negate</span></a> : <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.No"><span class="id" title="record">No</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.No"><span class="id" title="record">No</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(18, '0_3_7');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      "><br>
<span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#No_rec"><span class="id" title="definition">No_rec</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.No"><span class="id" title="record">No</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>  <a class="idref" href="HoTT.Spaces.No.Negation.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#x"><span class="id" title="variable">x</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>  <a class="idref" href="HoTT.Spaces.No.Negation.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#x"><span class="id" title="variable">x</span></a>)<br>
<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(20, '0_3_7');
      "><br>
- <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <span class="id" title="var">fxR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <span class="id" title="var">fxL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> <span class="id" title="var">l</span>  <span class="id" title="var">fxcut</span> <a class="idref" href="HoTT.Spaces.No.Negation.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(21, '0_3_7');
      "><br>
- <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.path_No"><span class="id" title="axiom">path_No</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(22, '0_3_7');
      "><br>
- <span class="id" title="var">cbn</span> <span class="id" title="keyword">in</span> . </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(23, '0_3_7');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">intros</span>; [ <span class="id" title="tactic">apply</span> <span class="id" title="var">dq</span> | <span class="id" title="tactic">apply</span> <span class="id" title="var">dp</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(24, '0_3_7');
      "><br>
- <span class="id" title="var">cbn</span> <span class="id" title="keyword">in</span> . </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(25, '0_3_7');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_r"><span class="id" title="definition">lt_r</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">l</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(26, '0_3_7');
      "><br>
- <span class="id" title="var">cbn</span> <span class="id" title="keyword">in</span> . </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(27, '0_3_7');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_l"><span class="id" title="definition">lt_l</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">r</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(28, '0_3_7');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(29, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
The following proof verifies that <span class="inlinecode"><a class="idref" href="HoTT.Spaces.No.Core.html#No_rec"><span class="id" title="definition">No_rec</span></a></span> applied to a cut reduces definitionally to a cut with the expected options (although it does produce quite a large term). 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(35, '0_3_11');
      ">
<span class="id" title="keyword">Goal</span> <a class="idref" href="HoTT.Spaces.No.Negation.html#negate"><span class="id" title="definition">negate</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#one"><span class="id" title="definition">one</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#minusone"><span class="id" title="definition">minusone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(36, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(37, '0_3_11');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.path_No"><span class="id" title="axiom">path_No</span></a>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">intros</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(38, '0_3_11');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
Since <span class="inlinecode"><a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a></span> only proves inequality of cuts, this would not work if <span class="inlinecode"><a class="idref" href="HoTT.Spaces.No.Negation.html#negate"><span class="id" title="definition">negate</span></a></span> didn't compute to a cut when applied to a cut. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(46, '0_3_15');
      ">
- <span class="id" title="tactic">elim</span> <span class="id" title="var">l</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(47, '0_3_15');
      "><br>
- <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_r"><span class="id" title="definition">lt_r</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(48, '0_3_15');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#Empty_ind"><span class="id" title="definition">Empty_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(49, '0_3_15');
      "><br>
- <span class="id" title="tactic">elim</span> <span class="id" title="var">l</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(50, '0_3_15');
      "><br>
- <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_r"><span class="id" title="definition">lt_r</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(51, '0_3_15');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#Empty_ind"><span class="id" title="definition">Empty_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(52, '0_3_15');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(53, '0_3_15');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "<infomsg>Interactive Module Topological_Modalities_Theory started</infomsg>	";
            responses[i]=data;
          

            i = 21;
            data = "<infomsg>Module Acc_Lex_Theory is defined</infomsg>	<infomsg>	Ambiguous paths:	[modality_to_reflective_subuniverse; O_reflector] : Modality >-> Funclass	</infomsg>	";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "";
            responses[i]=data;
          

            i = 32;
            data = "";
            responses[i]=data;
          

            i = 33;
            data = "1 subgoal (ID 5)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  ============================	  Lex O	";
            responses[i]=data;
          

            i = 34;
            data = "1 subgoal (ID 6)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  ============================	  In O (Type_ O)	";
            responses[i]=data;
          

            i = 35;
            data = "1 subgoal (ID 14)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  ============================	  ooExtendableAlong ((null_to_local_generators (acc_gen O)) i)	    (fun _ : lgen_codomain (null_to_local_generators (acc_gen O)) i =>	     Type_ O)	";
            responses[i]=data;
          

            i = 36;
            data = "1 subgoal (ID 6012)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  ============================	  IsEquiv	    (fun	       g : lgen_codomain (null_to_local_generators (acc_gen O)) i -> Type_ O	     => g oD (null_to_local_generators (acc_gen O)) i)	";
            responses[i]=data;
          

            i = 37;
            data = "3 subgoals (ID 6023)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  ============================	  ((acc_gen O) i -> Type_ O) -> Unit -> Type_ O		subgoal 2 (ID 6024) is:	 Sect ?Goal (fun g : Unit -> Type_ O => g oD (fun _ : (acc_gen O) i => tt))	subgoal 3 (ID 6025) is:	 Sect (fun g : Unit -> Type_ O => g oD (fun _ : (acc_gen O) i => tt)) ?Goal	";
            responses[i]=data;
          

            i = 38;
            data = "1 subgoal (ID 6023)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  ============================	  ((acc_gen O) i -> Type_ O) -> Unit -> Type_ O	1 subgoal (ID 6028)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  ============================	  Type_ O	";
            responses[i]=data;
          

            i = 39;
            data = "1 subgoal (ID 6035)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  ============================	  In O (forall a : (acc_gen O) i, B a)	";
            responses[i]=data;
          

            i = 40;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals (ID 6024)		subgoal 1 (ID 6024) is:	 Sect	   (fun B : (acc_gen O) i -> Type_ O =>	    unit_name	      (forall a : (acc_gen O) i, B a;	      inO_forall O ((acc_gen O) i) (fun x : (acc_gen O) i => B x)	        (fun x : (acc_gen O) i => inO_TypeO (B x))))	   (fun g : Unit -> Type_ O => g oD (fun _ : (acc_gen O) i => tt))	subgoal 2 (ID 6025) is:	 Sect (fun g : Unit -> Type_ O => g oD (fun _ : (acc_gen O) i => tt))	   (fun B : (acc_gen O) i -> Type_ O =>	    unit_name	      (forall a : (acc_gen O) i, B a;	      inO_forall O ((acc_gen O) i) (fun x : (acc_gen O) i => B x)	        (fun x : (acc_gen O) i => inO_TypeO (B x))))	";
            responses[i]=data;
          

            i = 41;
            data = "1 subgoal (ID 6024)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  ============================	  Sect	    (fun B : (acc_gen O) i -> Type_ O =>	     unit_name	       (forall a : (acc_gen O) i, B a;	       inO_forall O ((acc_gen O) i) (fun x : (acc_gen O) i => B x)	         (fun x : (acc_gen O) i => inO_TypeO (B x))))	    (fun g : Unit -> Type_ O => g oD (fun _ : (acc_gen O) i => tt))	1 subgoal (ID 6217)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  ============================	  unit_name	    (forall a : (acc_gen O) i, B a;	    inO_forall O ((acc_gen O) i) (fun x : (acc_gen O) i => B x)	      (fun x : (acc_gen O) i => inO_TypeO (B x)))	  oD (fun _ : (acc_gen O) i => tt) = B	";
            responses[i]=data;
          

            i = 42;
            data = "1 subgoal (ID 6236)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  ============================	  (unit_name	     (forall a0 : (acc_gen O) i, B a0;	     inO_forall O ((acc_gen O) i) (fun x : (acc_gen O) i => B x)	       (fun x : (acc_gen O) i => inO_TypeO (B x)))	   oD (fun _ : (acc_gen O) i => tt)) a = B a	";
            responses[i]=data;
          

            i = 43;
            data = "1 subgoal (ID 6257)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  ============================	  ((unit_name	      (forall a0 : (acc_gen O) i, B a0;	      inO_forall O ((acc_gen O) i) (fun x : (acc_gen O) i => B x)	        (fun x : (acc_gen O) i => inO_TypeO (B x)))	    oD (fun _ : (acc_gen O) i => tt)) a).1 <~> (B a).1	";
            responses[i]=data;
          

            i = 44;
            data = "1 subgoal (ID 6259)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  ============================	  (forall a0 : (acc_gen O) i, B a0) <~> (B a).1	";
            responses[i]=data;
          

            i = 45;
            data = "4 subgoals (ID 6263)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  ============================	  (forall a0 : (acc_gen O) i, B a0) -> (B a).1		subgoal 2 (ID 6265) is:	 (B a).1 -> forall a0 : (acc_gen O) i, B a0	subgoal 3 (ID 6267) is:	 Sect ?g ?f	subgoal 4 (ID 6269) is:	 Sect ?f ?g	";
            responses[i]=data;
          

            i = 46;
            data = "1 subgoal (ID 6263)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  ============================	  (forall a0 : (acc_gen O) i, B a0) -> (B a).1	1 subgoal (ID 6270)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  f : forall a : (acc_gen O) i, B a	  ============================	  (B a).1	";
            responses[i]=data;
          

            i = 47;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	4 subgoals (ID 6265)		subgoal 1 (ID 6265) is:	 (B a).1 -> forall a0 : (acc_gen O) i, B a0	subgoal 2 (ID 6267) is:	 Sect ?g (fun f : forall a0 : (acc_gen O) i, B a0 => f a)	subgoal 3 (ID 6269) is:	 Sect (fun f : forall a0 : (acc_gen O) i, B a0 => f a) ?g	subgoal 4 (ID 6025) is:	 Sect (fun g : Unit -> Type_ O => g oD (fun _ : (acc_gen O) i => tt))	   (fun B : (acc_gen O) i -> Type_ O =>	    unit_name	      (forall a : (acc_gen O) i, B a;	      inO_forall O ((acc_gen O) i) (fun x : (acc_gen O) i => B x)	        (fun x : (acc_gen O) i => inO_TypeO (B x))))	";
            responses[i]=data;
          

            i = 48;
            data = "1 subgoal (ID 6265)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  ============================	  (B a).1 -> forall a0 : (acc_gen O) i, B a0	1 subgoal (ID 6272)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  b : (B a).1	  a' : (acc_gen O) i	  ============================	  B a'	";
            responses[i]=data;
          

            i = 49;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 subgoals (ID 6267)		subgoal 1 (ID 6267) is:	 Sect	   (fun (b : (B a).1) (a' : (acc_gen O) i) =>	    transport (fun x : (acc_gen O) i => B x) (path_ishprop a a') b)	   (fun f : forall a0 : (acc_gen O) i, B a0 => f a)	subgoal 2 (ID 6269) is:	 Sect (fun f : forall a0 : (acc_gen O) i, B a0 => f a)	   (fun (b : (B a).1) (a' : (acc_gen O) i) =>	    transport (fun x : (acc_gen O) i => B x) (path_ishprop a a') b)	subgoal 3 (ID 6025) is:	 Sect (fun g : Unit -> Type_ O => g oD (fun _ : (acc_gen O) i => tt))	   (fun B : (acc_gen O) i -> Type_ O =>	    unit_name	      (forall a : (acc_gen O) i, B a;	      inO_forall O ((acc_gen O) i) (fun x : (acc_gen O) i => B x)	        (fun x : (acc_gen O) i => inO_TypeO (B x))))	";
            responses[i]=data;
          

            i = 50;
            data = "1 subgoal (ID 6267)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  ============================	  Sect	    (fun (b : (B a).1) (a' : (acc_gen O) i) =>	     transport (fun x : (acc_gen O) i => B x) (path_ishprop a a') b)	    (fun f : forall a0 : (acc_gen O) i, B a0 => f a)	1 subgoal (ID 6279)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  b : (B a).1	  ============================	  transport (fun x : (acc_gen O) i => B x) (path_ishprop a a) b = b	";
            responses[i]=data;
          

            i = 51;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 6269)		subgoal 1 (ID 6269) is:	 Sect (fun f : forall a0 : (acc_gen O) i, B a0 => f a)	   (fun (b : (B a).1) (a' : (acc_gen O) i) =>	    transport (fun x : (acc_gen O) i => B x) (path_ishprop a a') b)	subgoal 2 (ID 6025) is:	 Sect (fun g : Unit -> Type_ O => g oD (fun _ : (acc_gen O) i => tt))	   (fun B : (acc_gen O) i -> Type_ O =>	    unit_name	      (forall a : (acc_gen O) i, B a;	      inO_forall O ((acc_gen O) i) (fun x : (acc_gen O) i => B x)	        (fun x : (acc_gen O) i => inO_TypeO (B x))))	";
            responses[i]=data;
          

            i = 52;
            data = "1 subgoal (ID 6269)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  ============================	  Sect (fun f : forall a0 : (acc_gen O) i, B a0 => f a)	    (fun (b : (B a).1) (a' : (acc_gen O) i) =>	     transport (fun x : (acc_gen O) i => B x) (path_ishprop a a') b)	1 subgoal (ID 6330)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  f : forall a : (acc_gen O) i, B a	  ============================	  (fun a' : (acc_gen O) i =>	   transport (fun x : (acc_gen O) i => B x) (path_ishprop a a') (f a)) = f	";
            responses[i]=data;
          

            i = 53;
            data = "1 subgoal (ID 6353)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : (acc_gen O) i -> Type_ O	  a : (acc_gen O) i	  f : forall a : (acc_gen O) i, B a	  a' : (acc_gen O) i	  ============================	  transport (fun x : (acc_gen O) i => B x) (path_ishprop a a') (f a) = f a'	";
            responses[i]=data;
          

            i = 54;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 6025)		subgoal 1 (ID 6025) is:	 Sect (fun g : Unit -> Type_ O => g oD (fun _ : (acc_gen O) i => tt))	   (fun B : (acc_gen O) i -> Type_ O =>	    unit_name	      (forall a : (acc_gen O) i, B a;	      inO_forall O ((acc_gen O) i) (fun x : (acc_gen O) i => B x)	        (fun x : (acc_gen O) i => inO_TypeO (B x))))	";
            responses[i]=data;
          

            i = 55;
            data = "1 subgoal (ID 6025)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  ============================	  Sect (fun g : Unit -> Type_ O => g oD (fun _ : (acc_gen O) i => tt))	    (fun B : (acc_gen O) i -> Type_ O =>	     unit_name	       (forall a : (acc_gen O) i, B a;	       inO_forall O ((acc_gen O) i) (fun x : (acc_gen O) i => B x)	         (fun x : (acc_gen O) i => inO_TypeO (B x))))	1 subgoal (ID 6361)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : Unit -> Type_ O	  ============================	  unit_name	    (forall a : (acc_gen O) i, (B oD (fun _ : (acc_gen O) i => tt)) a;	    inO_forall O ((acc_gen O) i)	      (fun x : (acc_gen O) i => (B oD (fun _ : (acc_gen O) i => tt)) x)	      (fun x : (acc_gen O) i =>	       inO_TypeO ((B oD (fun _ : (acc_gen O) i => tt)) x))) = B	";
            responses[i]=data;
          

            i = 56;
            data = "1 subgoal (ID 6382)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : Unit -> Type_ O	  ============================	  (forall a : (acc_gen O) i, (B oD (fun _ : (acc_gen O) i => tt)) a;	  inO_forall O ((acc_gen O) i)	    (fun x : (acc_gen O) i => (B oD (fun _ : (acc_gen O) i => tt)) x)	    (fun x : (acc_gen O) i =>	     inO_TypeO ((B oD (fun _ : (acc_gen O) i => tt)) x))) = 	  B tt	";
            responses[i]=data;
          

            i = 57;
            data = "1 subgoal (ID 6401)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : Unit -> Type_ O	  ============================	  (forall a : (acc_gen O) i, (B oD (fun _ : (acc_gen O) i => tt)) a;	  inO_forall O ((acc_gen O) i)	    (fun x : (acc_gen O) i => (B oD (fun _ : (acc_gen O) i => tt)) x)	    (fun x : (acc_gen O) i =>	     inO_TypeO ((B oD (fun _ : (acc_gen O) i => tt)) x))).1 <~> 	  (B tt).1	";
            responses[i]=data;
          

            i = 58;
            data = "1 subgoal (ID 6403)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : Unit -> Type_ O	  ============================	  ((acc_gen O) i -> B tt) <~> (B tt).1	";
            responses[i]=data;
          

            i = 59;
            data = "1 subgoal (ID 6428)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : Unit -> Type_ O	  e := isequiv_ooextendable	         (fun _ : lgen_codomain (null_to_local_generators (acc_gen O)) i =>	          B tt) ((null_to_local_generators (acc_gen O)) i)	         (fst (inO_iff_isnull O (B tt)) (inO_TypeO (B tt)) i)	   : IsEquiv	       (fun	          g : forall	              b : lgen_codomain (null_to_local_generators (acc_gen O)) i,	              (fun _ : lgen_codomain (null_to_local_generators (acc_gen O)) i	               => TypeO_pr1 O (B tt)) b =>	        g oD (null_to_local_generators (acc_gen O)) i)	  ============================	  ((acc_gen O) i -> B tt) <~> (B tt).1	";
            responses[i]=data;
          

            i = 60;
            data = "1 subgoal (ID 6430)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : Unit -> Type_ O	  e := isequiv_ooextendable (unit_name (B tt)) (fun _ : (acc_gen O) i => tt)	         (fst (inO_iff_isnull O (B tt)) (inO_TypeO (B tt)) i)	   : IsEquiv (fun (g : Unit -> B tt) (_ : (acc_gen O) i) => g tt)	  ============================	  ((acc_gen O) i -> B tt) <~> (B tt).1	";
            responses[i]=data;
          

            i = 61;
            data = "1 subgoal (ID 6446)	  	  H : Univalence	  O : Modality	  Topological0 : forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	  i : lgen_indices (null_to_local_generators (acc_gen O))	  B : Unit -> Type_ O	  e := isequiv_ooextendable (unit_name (B tt)) (fun _ : (acc_gen O) i => tt)	         (fst (inO_iff_isnull O (B tt)) (inO_TypeO (B tt)) i)	   : IsEquiv (fun (g : Unit -> B tt) (_ : (acc_gen O) i) => g tt)	  ============================	  (Unit -> B tt) <~> (B tt).1	";
            responses[i]=data;
          

            i = 62;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 63;
            data = "<infomsg>lex_topological is defined</infomsg>	";
            responses[i]=data;
          

            i = 64;
            data = "<infomsg>Module Topological_Modalities_Theory is defined</infomsg>	";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "";
            responses[i]=data;
          

            i = 67;
            data = "";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "<infomsg>Module Topological_Nullification_Theory is defined</infomsg>	<infomsg>	Ambiguous paths:	[modality_to_reflective_subuniverse; O_reflector] : Modality >-> Funclass	[Nullification_Modality_to_Modality; modality_to_reflective_subuniverse;	 O_reflector] : Nullification_Modality >-> Funclass</infomsg>	<infomsg>	Ambiguous paths:	[modality_to_reflective_subuniverse; O_reflector] : Modality >-> Funclass	[Nullification_Modality_to_Modality; modality_to_reflective_subuniverse;	 O_reflector] : Nullification_Modality >-> Funclass</infomsg>	";
            responses[i]=data;
          

            i = 70;
            data = "";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "1 subgoal (ID 5)	  	  O : Nullification_Modality	  H : forall i : ngen_indices (unNul O), IsHProp ((unNul O) i)	  ============================	  forall i : ngen_indices (acc_gen O), IsHProp ((acc_gen O) i)	";
            responses[i]=data;
          

            i = 76;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 77;
            data = "<infomsg>topological_nullification is defined</infomsg>	";
            responses[i]=data;
          

            i = 78;
            data = "";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "";
            responses[i]=data;
          

            i = 84;
            data = "";
            responses[i]=data;
          

            i = 85;
            data = "1 subgoal (ID 10)	  	  H : Univalence	  O : Nullification_Modality	  H0 : forall i : ngen_indices (unNul O), IsHProp ((unNul O) i)	  ============================	  Lex O	";
            responses[i]=data;
          

            i = 86;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 87;
            data = "<infomsg>lex_nullification is defined</infomsg>	";
            responses[i]=data;
          

            i = 88;
            data = "";
            responses[i]=data;
          

            i = 89;
            data = "";
            responses[i]=data;
          

            i = 90;
            data = "";
            responses[i]=data;
          

            i = 91;
            data = "";
            responses[i]=data;
          

            i = 92;
            data = "";
            responses[i]=data;
          

            i = 93;
            data = "";
            responses[i]=data;
          

            i = 94;
            data = "";
            responses[i]=data;
          

            i = 95;
            data = "";
            responses[i]=data;
          

            i = 96;
            data = "";
            responses[i]=data;
          

            i = 97;
            data = "";
            responses[i]=data;
          

            i = 98;
            data = "";
            responses[i]=data;
          

            i = 99;
            data = "";
            responses[i]=data;
          

            i = 100;
            data = "";
            responses[i]=data;
          

            i = 101;
            data = "";
            responses[i]=data;
          

            i = 102;
            data = "";
            responses[i]=data;
          

            i = 103;
            data = "";
            responses[i]=data;
          

            i = 104;
            data = "";
            responses[i]=data;
          

            i = 105;
            data = "";
            responses[i]=data;
          

            i = 106;
            data = "";
            responses[i]=data;
          

            i = 107;
            data = "";
            responses[i]=data;
          

            i = 108;
            data = "";
            responses[i]=data;
          

            i = 109;
            data = "";
            responses[i]=data;
          

            i = 110;
            data = "";
            responses[i]=data;
          

            i = 111;
            data = "<infomsg>Interactive Module Topological_Lex started</infomsg>	";
            responses[i]=data;
          

            i = 112;
            data = "<infomsg>Ambiguous paths: [O_reflector] : ReflectiveSubuniverse >-> Funclass	</infomsg>	<infomsg>Ambiguous paths: [TypeO_pr1] : Type_ >-> Sortclass</infomsg>	<infomsg>	Ambiguous paths:	[modality_to_reflective_subuniverse] : Modality >-> ReflectiveSubuniverse	</infomsg>	";
            responses[i]=data;
          

            i = 113;
            data = "<infomsg>	Ambiguous paths:	[modality_to_reflective_subuniverse; O_reflector] : Modality >-> Funclass	[Nullification_Modality_to_Modality; modality_to_reflective_subuniverse;	 O_reflector] : Nullification_Modality >-> Funclass</infomsg>	";
            responses[i]=data;
          

            i = 114;
            data = "<infomsg>Module LexNulM is defined</infomsg>	<infomsg>	Ambiguous paths:	[modality_to_reflective_subuniverse; O_reflector] : Modality >-> Funclass	[Nullification_Modality_to_Modality; modality_to_reflective_subuniverse;	 O_reflector] : Nullification_Modality >-> Funclass</infomsg>	";
            responses[i]=data;
          

            i = 115;
            data = "1 subgoal (ID 19)	  	  H : Funext	  B : NullGenerators	  Olex : Lex {| unNul := B |}	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 116;
            data = "1 subgoal (ID 19)	  	  H : Funext	  B : NullGenerators	  Olex : Lex {| unNul := B |}	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 117;
            data = "2 subgoals (ID 28)	  	  H : Funext	  B : NullGenerators	  Olex : Lex {| unNul := B |}	  gtr : forall a : ngen_indices B, Contr (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}		subgoal 2 (ID 30) is:	 {D : NullGenerators &	 (forall c : ngen_indices D, IsHProp (D c)) *	 OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 118;
            data = "1 subgoal (ID 28)	  	  H : Funext	  B : NullGenerators	  Olex : Lex {| unNul := B |}	  gtr : forall a : ngen_indices B, Contr (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	1 subgoal (ID 33)	  	  H : Funext	  B : NullGenerators	  Olex : Lex {| unNul := B |}	  gtr : forall a : ngen_indices B, Contr (B a)	  ============================	  (forall	   c : ngen_indices	         {| ngen_indices := Empty; ngen_type := fun _ : Empty => Unit |},	   IsHProp	     ({| ngen_indices := Empty; ngen_type := fun _ : Empty => Unit |} c)) *	  OeqO	    {|	    unNul := {| ngen_indices := Empty; ngen_type := fun _ : Empty => Unit |} |}	    {| unNul := B |}	";
            responses[i]=data;
          

            i = 119;
            data = "1 subgoal (ID 69)	  	  H : Funext	  B : NullGenerators	  Olex : Lex {| unNul := B |}	  gtr : forall a : ngen_indices B, Contr (B a)	  X : Type2le	  ============================	  In	    {|	    unNul := {| ngen_indices := Empty; ngen_type := fun _ : Empty => Unit |} |}	    X <-> In {| unNul := B |} X	";
            responses[i]=data;
          

            i = 120;
            data = "1 subgoal (ID 74)	  	  H : Funext	  B : NullGenerators	  Olex : Lex {| unNul := B |}	  gtr : forall a : ngen_indices B, Contr (B a)	  X : Type2le	  ============================	  In {| unNul := B |} X	";
            responses[i]=data;
          

            i = 121;
            data = "1 subgoal (ID 86)	  	  H : Funext	  B : NullGenerators	  Olex : Lex {| unNul := B |}	  gtr : forall a : ngen_indices B, Contr (B a)	  X : Type2le	  i : lgen_indices	        (unLoc	           (LocRSU_Data.ReflectiveSubuniverses_restriction	              {| unNul := acc_gen {| unNul := B |} |}))	  ============================	  ooExtendableAlong	    ((unLoc	        (LocRSU_Data.ReflectiveSubuniverses_restriction	           {| unNul := acc_gen {| unNul := B |} |})) i)	    (fun	       _ : lgen_codomain	             (unLoc	                (LocRSU_Data.ReflectiveSubuniverses_restriction	                   {| unNul := acc_gen {| unNul := B |} |})) i => X)	";
            responses[i]=data;
          

            i = 122;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal (ID 30)		subgoal 1 (ID 30) is:	 {D : NullGenerators &	 (forall c : ngen_indices D, IsHProp (D c)) *	 OeqO {| unNul := D |} {| unNul := B |}}	1 subgoal (ID 30)	  	  H : Funext	  B : NullGenerators	  Olex : Lex {| unNul := B |}	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n.+1 (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	1 subgoal (ID 95)	  	  H : Funext	  B : NullGenerators	  Olex : Lex {| unNul := B |}	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n.+1 (B a)	  O := {| unNul := B |} : Nullification_Modality	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 123;
            data = "1 subgoal (ID 124)	  	  H : Funext	  B : NullGenerators	  Olex : Lex {| unNul := B |}	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n.+1 (B a)	  O := {| unNul := B |} : Nullification_Modality	  OeqB := (reflexivity O : OeqO O {| unNul := B |}) : OeqO O {| unNul := B |}	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 124;
            data = "1 subgoal (ID 125)	  	  H : Funext	  B : NullGenerators	  O := {| unNul := B |} : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n.+1 (B a)	  OeqB := (reflexivity O : OeqO O {| unNul := B |}) : OeqO O {| unNul := B |}	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 125;
            data = "1 subgoal (ID 126)	  	  H : Funext	  B : NullGenerators	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n.+1 (B a)	  OeqB : OeqO O {| unNul := B |}	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 126;
            data = "1 subgoal (ID 128)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  ============================	  forall B : NullGenerators,	  OeqO O {| unNul := B |} ->	  (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 127;
            data = "2 subgoals (ID 138)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsHProp (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}		subgoal 2 (ID 141) is:	 {D : NullGenerators &	 (forall c : ngen_indices D, IsHProp (D c)) *	 OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 128;
            data = "1 subgoal (ID 138)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsHProp (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal (ID 141)		subgoal 1 (ID 141) is:	 {D : NullGenerators &	 (forall c : ngen_indices D, IsHProp (D c)) *	 OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 129;
            data = "1 subgoal (ID 141)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	1 subgoal (ID 171)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 130;
            data = "1 subgoal (ID 174)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) *	  OeqO {| unNul := D |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 131;
            data = "1 subgoal (ID 178)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  ============================	  {D0 : NullGenerators &	  (forall c : ngen_indices D0, IsHProp (D0 c)) *	  OeqO {| unNul := D0 |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 132;
            data = "2 subgoals (ID 179)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  ============================	  forall c : C, IsTrunc n.+1 (D c)		subgoal 2 (ID 181) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) *	 OeqO {| unNul := D0 |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 133;
            data = "1 subgoal (ID 179)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  ============================	  forall c : C, IsTrunc n.+1 (D c)	";
            responses[i]=data;
          

            i = 134;
            data = "1 subgoal (ID 196)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  a : A	  ============================	  IsTrunc n.+1 (Trunc -1 (B a))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal (ID 181)		subgoal 1 (ID 181) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) *	 OeqO {| unNul := D0 |} {| unNul := B |}}	1 subgoal (ID 181)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  ============================	  {D0 : NullGenerators &	  (forall c : ngen_indices D0, IsHProp (D0 c)) *	  OeqO {| unNul := D0 |} {| unNul := B |}}	2 subgoals (ID 500)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  ============================	  OeqO O {| unNul := D |}		subgoal 2 (ID 502) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) *	 OeqO {| unNul := D0 |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 135;
            data = "1 subgoal (ID 500)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  ============================	  OeqO O {| unNul := D |}	2 subgoals (ID 506)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  ============================	  In O X -> In {| unNul := D |} X		subgoal 2 (ID 507) is:	 In {| unNul := D |} X -> In O X	";
            responses[i]=data;
          

            i = 136;
            data = "1 subgoal (ID 506)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  ============================	  In O X -> In {| unNul := D |} X	1 subgoal (ID 510)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  c : lgen_indices	        (unLoc	           (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	  ============================	  ooExtendableAlong	    ((unLoc (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	       c)	    (fun	       _ : lgen_codomain	             (unLoc	                (LocRSU_Data.ReflectiveSubuniverses_restriction	                   {| unNul := D |})) c => X)	";
            responses[i]=data;
          

            i = 137;
            data = "2 subgoals (ID 511)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  c : lgen_indices	        (unLoc	           (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	  ============================	  forall a : A, IsConnected O (B a)		subgoal 2 (ID 513) is:	 ooExtendableAlong	   ((unLoc (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	      c)	   (fun	      _ : lgen_codomain	            (unLoc	               (LocRSU_Data.ReflectiveSubuniverses_restriction	                  {| unNul := D |})) c => X)	";
            responses[i]=data;
          

            i = 138;
            data = "1 subgoal (ID 511)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  c : lgen_indices	        (unLoc	           (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	  ============================	  forall a : A, IsConnected O (B a)	1 subgoal (ID 514)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  c : lgen_indices	        (unLoc	           (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	  a : A	  ============================	  IsConnected O (B a)	";
            responses[i]=data;
          

            i = 139;
            data = "2 subgoals (ID 515)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  c : lgen_indices	        (unLoc	           (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	  a : A	  ============================	  OeqO {| unNul := B |} O		subgoal 2 (ID 516) is:	 IsConnected {| unNul := B |} (B a)	";
            responses[i]=data;
          

            i = 140;
            data = "1 subgoal (ID 515)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  c : lgen_indices	        (unLoc	           (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	  a : A	  ============================	  OeqO {| unNul := B |} O	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	4 subgoals (ID 516)		subgoal 1 (ID 516) is:	 IsConnected {| unNul := B |} (B a)	subgoal 2 (ID 513) is:	 ooExtendableAlong	   ((unLoc (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	      c)	   (fun	      _ : lgen_codomain	            (unLoc	               (LocRSU_Data.ReflectiveSubuniverses_restriction	                  {| unNul := D |})) c => X)	subgoal 3 (ID 507) is:	 In {| unNul := D |} X -> In O X	subgoal 4 (ID 502) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) *	 OeqO {| unNul := D0 |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 141;
            data = "1 subgoal (ID 516)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  c : lgen_indices	        (unLoc	           (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	  a : A	  ============================	  IsConnected {| unNul := B |} (B a)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 subgoals (ID 513)		subgoal 1 (ID 513) is:	 ooExtendableAlong	   ((unLoc (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	      c)	   (fun	      _ : lgen_codomain	            (unLoc	               (LocRSU_Data.ReflectiveSubuniverses_restriction	                  {| unNul := D |})) c => X)	subgoal 2 (ID 507) is:	 In {| unNul := D |} X -> In O X	subgoal 3 (ID 502) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) *	 OeqO {| unNul := D0 |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 142;
            data = "1 subgoal (ID 513)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  c : lgen_indices	        (unLoc	           (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	  Bc : forall a : A, IsConnected O (B a)	  ============================	  ooExtendableAlong	    ((unLoc (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	       c)	    (fun	       _ : lgen_codomain	             (unLoc	                (LocRSU_Data.ReflectiveSubuniverses_restriction	                   {| unNul := D |})) c => X)	2 subgoals (ID 565)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  ============================	  IsConnected O	    (lgen_domain	       (unLoc	          (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	       (inl a))		subgoal 2 (ID 579) is:	 IsConnected O	   (lgen_domain	      (unLoc	         (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	      (inr (a; (b1, b2))))	";
            responses[i]=data;
          

            i = 143;
            data = "1 subgoal (ID 565)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  ============================	  IsConnected O	    (lgen_domain	       (unLoc	          (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	       (inl a))	1 subgoal (ID 580)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  ============================	  NullHomotopy.NullHomotopy	    (to O	       (lgen_domain	          (unLoc	             (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	          (inl a)))	";
            responses[i]=data;
          

            i = 144;
            data = "1 subgoal (ID 597)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  x : O (merely (B a))	  h : forall x0 : B a, to O (Trunc -1 (B a)) (tr x0) = x	  ============================	  NullHomotopy.NullHomotopy	    (to O	       (lgen_domain	          (unLoc	             (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	          (inl a)))	";
            responses[i]=data;
          

            i = 145;
            data = "1 subgoal (ID 601)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  x : O (merely (B a))	  h : forall x0 : B a, to O (Trunc -1 (B a)) (tr x0) = x	  y : Trunc -1 (B a)	  ============================	  to O	    (lgen_domain	       (unLoc	          (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	       (inl a)) y = x	";
            responses[i]=data;
          

            i = 146;
            data = "1 subgoal (ID 1082)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  x : O (merely (B a))	  h : forall x0 : B a, to O (Trunc -1 (B a)) (tr x0) = x	  y : B a	  ============================	  to O	    (lgen_domain	       (unLoc	          (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	       (inl a)) (tr y) = x	";
            responses[i]=data;
          

            i = 147;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 subgoals (ID 579)		subgoal 1 (ID 579) is:	 IsConnected O	   (lgen_domain	      (unLoc	         (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	      (inr (a; (b1, b2))))	subgoal 2 (ID 507) is:	 In {| unNul := D |} X -> In O X	subgoal 3 (ID 502) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) *	 OeqO {| unNul := D0 |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 148;
            data = "1 subgoal (ID 579)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  X_inO : In O X	  a : A	  b1, b2 : B a	  Bc : forall a : A, IsConnected O (B a)	  ============================	  IsConnected O	    (lgen_domain	       (unLoc	          (LocRSU_Data.ReflectiveSubuniverses_restriction {| unNul := D |}))	       (inr (a; (b1, b2))))	";
            responses[i]=data;
          

            i = 149;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals (ID 507)		subgoal 1 (ID 507) is:	 In {| unNul := D |} X -> In O X	subgoal 2 (ID 502) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) *	 OeqO {| unNul := D0 |} {| unNul := B |}}	1 subgoal (ID 507)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  ============================	  In {| unNul := D |} X -> In O X	1 subgoal (ID 2739)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  ============================	  In {| unNul := B |} X	";
            responses[i]=data;
          

            i = 150;
            data = "1 subgoal (ID 2743)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  ============================	  ooExtendableAlong (fun _ : B a => tt) (unit_name X)	";
            responses[i]=data;
          

            i = 151;
            data = "1 subgoal (ID 2785)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  ============================	  IsEquiv (fun g : Unit -> X => g oD (fun _ : B a => tt))	";
            responses[i]=data;
          

            i = 152;
            data = "1 subgoal (ID 2790)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  ============================	  Contr {a0 : Unit -> X & a0 oD (fun _ : B a => tt) = f}	";
            responses[i]=data;
          

            i = 153;
            data = "2 subgoals (ID 3446)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  ============================	  {x : X & forall u : B a, x = f u} <~>	  {a0 : Unit -> X & a0 oD (fun _ : B a => tt) = f}		subgoal 2 (ID 3447) is:	 Contr {x : X & forall u : B a, x = f u}	";
            responses[i]=data;
          

            i = 154;
            data = "1 subgoal (ID 3446)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  ============================	  {x : X & forall u : B a, x = f u} <~>	  {a0 : Unit -> X & a0 oD (fun _ : B a => tt) = f}	1 subgoal (ID 3455)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  ============================	  forall a0 : X,	  (forall u : B a, a0 = f u) <~>	  (equiv_unit_rec X) a0 oD (fun _ : B a => tt) = f	";
            responses[i]=data;
          

            i = 155;
            data = "1 subgoal (ID 3458)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  x : X	  ============================	  (forall u : B a, x = f u) <~> (fun _ : B a => x) = f	";
            responses[i]=data;
          

            i = 156;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 subgoals (ID 3447)		subgoal 1 (ID 3447) is:	 Contr {x : X & forall u : B a, x = f u}	subgoal 2 (ID 502) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) *	 OeqO {| unNul := D0 |} {| unNul := B |}}	1 subgoal (ID 3447)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  ============================	  Contr {x : X & forall u : B a, x = f u}	";
            responses[i]=data;
          

            i = 157;
            data = "2 subgoals (ID 7894)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  ============================	  IsConnected {| unNul := D |} (D (inl a))		subgoal 2 (ID 7895) is:	 D (inl a) -> Contr {x : X & forall u : B a, x = f u}	1 subgoal (ID 7894)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  ============================	  IsConnected {| unNul := D |} (D (inl a))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 subgoals (ID 7895)		subgoal 1 (ID 7895) is:	 D (inl a) -> Contr {x : X & forall u : B a, x = f u}	subgoal 2 (ID 502) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) *	 OeqO {| unNul := D0 |} {| unNul := B |}}	1 subgoal (ID 7895)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  ============================	  D (inl a) -> Contr {x : X & forall u : B a, x = f u}	1 subgoal (ID 7897)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b : Trunc -1 (B a)	  ============================	  Contr {x : X & forall u : B a, x = f u}	";
            responses[i]=data;
          

            i = 158;
            data = "1 subgoal (ID 7999)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b : B a	  ============================	  Contr {x : X & forall u : B a, x = f u}	";
            responses[i]=data;
          

            i = 159;
            data = "2 subgoals (ID 8919)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b : B a	  ============================	  IsConnMap {| unNul := D |} (unit_name b)		subgoal 2 (ID 8921) is:	 Contr {x : X & forall u : B a, x = f u}	";
            responses[i]=data;
          

            i = 160;
            data = "1 subgoal (ID 8919)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b : B a	  ============================	  IsConnMap {| unNul := D |} (unit_name b)	1 subgoal (ID 8924)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b, x : B a	  ============================	  IsConnected {| unNul := D |} {_ : Unit & b = x}	";
            responses[i]=data;
          

            i = 161;
            data = "1 subgoal (ID 8977)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b, x : B a	  ============================	  IsConnected {| unNul := D |} (b = x)	";
            responses[i]=data;
          

            i = 162;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 subgoals (ID 8921)		subgoal 1 (ID 8921) is:	 Contr {x : X & forall u : B a, x = f u}	subgoal 2 (ID 502) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) *	 OeqO {| unNul := D0 |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 163;
            data = "1 subgoal (ID 8921)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap {| unNul := D |} (unit_name b)	  ============================	  Contr {x : X & forall u : B a, x = f u}	1 subgoal (ID 9077)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap {| unNul := D |} (unit_name b)	  p := conn_map_elim {| unNul := D |} (unit_name b)	         (fun u : B a => f b = f u) (unit_name 1)	   : forall b0 : B a, (fun u : B a => f b = f u) b0	  ============================	  Contr {x : X & forall u : B a, x = f u}	";
            responses[i]=data;
          

            i = 164;
            data = "1 subgoal (ID 9088)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap {| unNul := D |} (unit_name b)	  p := conn_map_elim {| unNul := D |} (unit_name b)	         (fun u : B a => f b = f u) (unit_name 1)	   : forall b0 : B a, (fun u : B a => f b = f u) b0	  x : X	  q : forall u : B a, x = f u	  ============================	  (f b; p) = (x; q)	";
            responses[i]=data;
          

            i = 165;
            data = "1 subgoal (ID 9105)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap {| unNul := D |} (unit_name b)	  p := conn_map_elim {| unNul := D |} (unit_name b)	         (fun u : B a => f b = f u) (unit_name 1)	   : forall b0 : B a, (fun u : B a => f b = f u) b0	  x : X	  q : forall u : B a, x = f u	  ============================	  transport (fun x0 : X => forall u : B a, x0 = f u) (q b)^ p == q	";
            responses[i]=data;
          

            i = 166;
            data = "1 subgoal (ID 9234)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap {| unNul := D |} (unit_name b)	  p := conn_map_elim {| unNul := D |} (unit_name b)	         (fun u : B a => f b = f u) (unit_name 1)	   : forall b0 : B a, (fun u : B a => f b = f u) b0	  x : X	  q : forall u : B a, x = f u	  ============================	  transport (fun x0 : X => forall u : B a, x0 = f u) (q b)^ p b = q b	";
            responses[i]=data;
          

            i = 167;
            data = "1 subgoal (ID 9260)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap {| unNul := D |} (unit_name b)	  p := conn_map_elim {| unNul := D |} (unit_name b)	         (fun u : B a => f b = f u) (unit_name 1)	   : forall b0 : B a, (fun u : B a => f b = f u) b0	  x : X	  q : forall u : B a, x = f u	  ============================	  q b @ p b = q b	";
            responses[i]=data;
          

            i = 168;
            data = "1 subgoal (ID 9277)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type2le	  Dnull : In {| unNul := D |} X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap {| unNul := D |} (unit_name b)	  p := conn_map_elim {| unNul := D |} (unit_name b)	         (fun u : B a => f b = f u) (unit_name 1)	   : forall b0 : B a, (fun u : B a => f b = f u) b0	  x : X	  q : forall u : B a, x = f u	  ============================	  q b @ 1 = q b	";
            responses[i]=data;
          

            i = 169;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal (ID 502)		subgoal 1 (ID 502) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) *	 OeqO {| unNul := D0 |} {| unNul := B |}}	1 subgoal (ID 502)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  OeqD : OeqO O {| unNul := D |}	  ============================	  {D0 : NullGenerators &	  (forall c : ngen_indices D0, IsHProp (D0 c)) *	  OeqO {| unNul := D0 |} {| unNul := B |}}	1 subgoal (ID 9305)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  OeqD : OeqO O {| unNul := D |}	  E : NullGenerators	  HE : forall c : ngen_indices E, IsHProp (E c)	  EeqD : OeqO {| unNul := E |} {| unNul := D |}	  ============================	  {D0 : NullGenerators &	  (forall c : ngen_indices D0, IsHProp (D0 c)) *	  OeqO {| unNul := D0 |} {| unNul := B |}}	";
            responses[i]=data;
          

            i = 170;
            data = "1 subgoal (ID 9310)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  OeqD : OeqO O {| unNul := D |}	  E : NullGenerators	  HE : forall c : ngen_indices E, IsHProp (E c)	  EeqD : OeqO {| unNul := E |} {| unNul := D |}	  ============================	  OeqO {| unNul := E |} {| unNul := B |}	";
            responses[i]=data;
          

            i = 171;
            data = "1 subgoal (ID 9408)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  OeqD : OeqO O {| unNul := D |}	  E : NullGenerators	  HE : forall c : ngen_indices E, IsHProp (E c)	  EeqD : OeqO {| unNul := E |} {| unNul := D |}	  ============================	  OeqO {| unNul := D |} {| unNul := B |}	";
            responses[i]=data;
          

            i = 172;
            data = "1 subgoal (ID 9506)	  	  H : Funext	  O : Nullification_Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        OeqO O {| unNul := B |} ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) *	        OeqO {| unNul := D |} {| unNul := B |}}	  B : NullGenerators	  OeqB : OeqO O {| unNul := B |}	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	       ngen_indices := C;	       ngen_type := fun c : C =>	                    match c with	                    | inl a => merely (B a)	                    | inr s => fst s.2 = snd s.2	                    end	                    :	                    Type |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  OeqD : OeqO O {| unNul := D |}	  E : NullGenerators	  HE : forall c : ngen_indices E, IsHProp (E c)	  EeqD : OeqO {| unNul := E |} {| unNul := D |}	  ============================	  OeqO {| unNul := D |} O	";
            responses[i]=data;
          

            i = 173;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 174;
            data = "<infomsg>topological_lex_trunc_acc is defined</infomsg>	";
            responses[i]=data;
          

            i = 175;
            data = "<infomsg>Module Topological_Lex is defined</infomsg>	";
            responses[i]=data;
          

            i = 176;
            data = "";
            responses[i]=data;
          

            i = 177;
            data = "";
            responses[i]=data;
          

            i = 178;
            data = "";
            responses[i]=data;
          

            i = 179;
            data = "";
            responses[i]=data;
          

            i = 180;
            data = "";
            responses[i]=data;
          

            i = 181;
            data = "";
            responses[i]=data;
          

            i = 182;
            data = "";
            responses[i]=data;
          

            i = 183;
            data = "";
            responses[i]=data;
          

            i = 184;
            data = "";
            responses[i]=data;
          

            i = 185;
            data = "";
            responses[i]=data;
          

            i = 186;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Modalities.Topological</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.EquivalenceVarieties.html#"><span class="id" title="library">EquivalenceVarieties</span></a> <a class="idref" href="HoTT.Extensions.html#"><span class="id" title="library">Extensions</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HIT.Truncations.html#"><span class="id" title="library">HIT.Truncations</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Modalities.Modality.html#"><span class="id" title="library">Modality</span></a> <a class="idref" href="HoTT.Modalities.Accessible.html#"><span class="id" title="library">Accessible</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#"><span class="id" title="library">Lex</span></a> <a class="idref" href="HoTT.Modalities.Nullification.html#"><span class="id" title="library">Nullification</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(10, '0_3_3');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(11, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a name="lab297"></a><h1 class="section">Topological localizations</h1>
<div class="doc" scenenumber="4"> </div>

 A topological localization -- or, as we will say, a topological nullification -- is a nullification at a family of hprops, or more generally an accessible modality whose generators of accessibility are all hprops.  This is not quite the same as Lurie's definition: in Higher Topos Theory, a topological localization is an accessible *left exact* localization at a pullback-stable class generated by a set of monomorphisms.  "Pullback-stable class generated by" is roughly incorporated into our internal notion of accessibility, so the main new difference here is that when the generation is internal in this way, the localization at a family of hprops is *automatically* left exact. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(20, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Module</span> <a name="Topological_Modalities_Theory"><span class="id" title="module">Topological_Modalities_Theory</span></a><br>
(<span class="id" title="var">Os</span> : <a class="idref" href="HoTT.Modalities.Modality.html#Modalities"><span class="id" title="module">Modalities</span></a>) (<span class="id" title="var">Acc</span> : <a class="idref" href="HoTT.Modalities.Accessible.html#Accessible_Modalities"><span class="id" title="module">Accessible_Modalities</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#Os"><span class="id" title="module">Os</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(21, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Topological_Modalities_Theory.Acc_Lex_Theory"><span class="id" title="module">Acc_Lex_Theory</span></a> := <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory"><span class="id" title="module">Accessible_Lex_Modalities_Theory</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#Os"><span class="id" title="module">Os</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#Acc"><span class="id" title="module">Acc</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(22, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="Topological_Modalities_Theory.Topological"><span class="id" title="abbreviation">Topological</span></a> <span class="id" title="var">O</span> := (<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation"></span></a> <span class="id" title="var">i</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.Modalities.Topological.html#Acc.acc_gen"><span class="id" title="axiom">acc_gen</span></a> <span class="id" title="var">O</span> <a class="idref" href="HoTT.Modalities.Topological.html#i"><span class="id" title="variable">i</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(23, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
<a name="lab298"></a><h2 class="section">Topological modalities are lex</h2>
<div class="doc" scenenumber="4"> </div>

 We prove left-exactness by proving that the universe of modal types is modal.  Of course, this requires univalence. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(32, '0_3_11');
      ">
<br>
<span class="id" title="keyword">Global Instance</span> <a name="Topological_Modalities_Theory.lex_topological"><span class="id" title="instance">lex_topological</span></a> `{<a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="class">Univalence</span></a>}<br>
(<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Topological.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Topological.html#Topological_Modalities_Theory.Topological"><span class="id" title="abbreviation">Topological</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#O"><span class="id" title="variable">O</span></a>}<br>
: <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#O"><span class="id" title="variable">O</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(33, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(34, '0_3_11');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Modalities_Theory.lex_inO_typeO"><span class="id" title="definition">lex_inO_typeO</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(35, '0_3_11');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="HoTT.Modalities.Topological.html#Acc.inO_iff_isnull"><span class="id" title="axiom">inO_iff_isnull</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(36, '0_3_11');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_inverse"><span class="id" title="lemma">equiv_inverse</span></a> (<a class="idref" href="HoTT.Extensions.html#equiv_ooextendable_isequiv"><span class="id" title="definition">equiv_ooextendable_isequiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(37, '0_3_11');
      "><br>
<span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(38, '0_3_11');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(39, '0_3_11');
      "><br>
<span class="id" title="tactic">refine</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">((</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation"></span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Topological.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(40, '0_3_11');
      "><br>
<span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(41, '0_3_11');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(42, '0_3_11');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Arrow.html#path_arrow"><span class="id" title="definition">path_arrow</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(43, '0_3_11');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Modalities_Theory.path_TypeO"><span class="id" title="definition">path_TypeO</span></a>, <a class="idref" href="HoTT.Types.Universe.html#path_universe_uncurried"><span class="id" title="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(44, '0_3_11');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#composeD"><span class="id" title="definition">composeD</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(45, '0_3_11');
      "><br>
<span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_adjointify"><span class="id" title="definition">equiv_adjointify</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(46, '0_3_11');
      "><br>
+ <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(47, '0_3_11');
      "><span class="id" title="tactic">exact</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(48, '0_3_11');
      "><br>
+ <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">a'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(49, '0_3_11');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a> <span class="id" title="var">a</span> <span class="id" title="var">a'</span>) <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(50, '0_3_11');
      "><br>
+ <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(51, '0_3_11');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#transport2"><span class="id" title="definition">transport2</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Basics.Contractible.html#path_contr"><span class="id" title="definition">path_contr</span></a> <span class="id" title="var">_</span> 1) <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(52, '0_3_11');
      "><br>
+ <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(53, '0_3_11');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">a'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(54, '0_3_11');
      "><br>
<span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">f</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(55, '0_3_11');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(56, '0_3_11');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Arrow.html#path_arrow"><span class="id" title="definition">path_arrow</span></a>; <span class="id" title="tactic">intros</span> [].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(57, '0_3_11');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Modalities_Theory.path_TypeO"><span class="id" title="definition">path_TypeO</span></a>, <a class="idref" href="HoTT.Types.Universe.html#path_universe_uncurried"><span class="id" title="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(58, '0_3_11');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#composeD"><span class="id" title="definition">composeD</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(59, '0_3_11');
      "><br>
<span class="id" title="tactic">pose</span> (<span class="id" title="var">e</span> := <a class="idref" href="HoTT.Extensions.html#isequiv_ooextendable"><span class="id" title="definition">isequiv_ooextendable</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br>
(<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Modalities.Topological.html#Acc.inO_iff_isnull"><span class="id" title="axiom">inO_iff_isnull</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)) (<a class="idref" href="HoTT.Modalities.Topological.html#Topological_Modalities_Theory.inO_TypeO"><span class="id" title="instance">inO_TypeO</span></a> (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)) <span class="id" title="var">i</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(60, '0_3_11');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#composeD"><span class="id" title="definition">composeD</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">e</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(61, '0_3_11');
      "><br>
<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Basics.Equivalences.html#88ede747212f43ca2516cbd6e5847b58"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#BuildEquiv"><span class="id" title="constructor">BuildEquiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Equivalences.html#88ede747212f43ca2516cbd6e5847b58"><span class="id" title="notation">)^-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(62, '0_3_11');
      "><br>
<span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Types.Forall.html#equiv_contr_forall"><span class="id" title="definition">equiv_contr_forall</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(63, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(64, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Modalities_Theory"><span class="id" title="module">Topological_Modalities_Theory</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(65, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
In particular, a nullification at a family of hprops is topological and therefore lex. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(69, '0_3_15');
      ">
<br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Import</span> <a name="Topological_Nullification_Theory"><span class="id" title="module">Topological_Nullification_Theory</span></a> :=<br>
<a class="idref" href="HoTT.Modalities.Topological.html#Topological_Modalities_Theory"><span class="id" title="module">Topological_Modalities_Theory</span></a><br>
<a class="idref" href="HoTT.Modalities.Nullification.html#Nullification_Modalities"><span class="id" title="module">Nullification_Modalities</span></a><br>
<a class="idref" href="HoTT.Modalities.Nullification.html#Accessible_Nullification"><span class="id" title="module">Accessible_Nullification</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(70, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
It isn't necessary to declare these as global instances, since typeclass search can find them automatically.  But we want to state them explicitly here for exposition, so we make them local instances. 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(74, '0_3_19');
      ">
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Instance</span> <a name="topological_nullification"><span class="id" title="instance">topological_nullification</span></a><br>
(<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Nullification.html#Nullification_Modality"><span class="id" title="record">Nullification_Modality</span></a>) `{<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation"></span></a> <span class="id" title="var">i</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#unNul"><span class="id" title="projection">unNul</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#i"><span class="id" title="variable">i</span></a>)}<br>
: <a class="idref" href="HoTT.Modalities.Topological.html#Topological"><span class="id" title="abbreviation">Topological</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#O"><span class="id" title="variable">O</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(75, '0_3_19');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(76, '0_3_19');
      "><br>
<span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(77, '0_3_19');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(78, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
Note the hypothesis of <span class="inlinecode"><a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="section">Univalence</span></a></span> required for this one.  It's unclear whether this is necessary or not in general; in one special case (open modalities) funext suffices.  But it's plausible that it would be necessary in general, because lex-ness of nullification is a statement about the path-spaces of a HIT, and characterizing those in any way usually requires some amount of univalence. 
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(84, '0_3_23');
      ">
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Instance</span> <a name="lex_nullification"><span class="id" title="instance">lex_nullification</span></a> `{<a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="class">Univalence</span></a>}<br>
(<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Nullification.html#Nullification_Modality"><span class="id" title="record">Nullification_Modality</span></a>) `{<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation"></span></a> <span class="id" title="var">i</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#unNul"><span class="id" title="projection">unNul</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#i"><span class="id" title="variable">i</span></a>)}<br>
: <a class="idref" href="HoTT.Modalities.Topological.html#Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#O"><span class="id" title="variable">O</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(85, '0_3_23');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(86, '0_3_23');
      "><br>
<span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(87, '0_3_23');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(88, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
<a name="lab299"></a><h2 class="section">Lex modalities generated by n-types are topological</h2>
<div class="doc" scenenumber="4"> </div>

 For <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode"></span> <span class="inlinecode">0</span>, nullification at a family of <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a></span>-types need not be lex.  For instance, the (-1)-truncation is nullification at <span class="inlinecode"><a class="idref" href="HoTT.Types.Bool.html#Bool"><span class="id" title="inductive">Bool</span></a></span>.  However, if the nullification at a family of <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a></span>-types *is* lex, then it is topological. 
<div class="doc" scenenumber="18"> </div>

 This is kind of annoying to prove, not just because the proof is fiddly, but because we have to pass back and forth between different generating families for the "same" modality.  It's a bit easier to prove it about nullifications than about arbitrary accessible lex modalities. 
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(111, '0_3_27');
      ">
<br>
<span class="id" title="keyword">Module</span> <a name="Topological_Lex"><span class="id" title="module">Topological_Lex</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(112, '0_3_27');
      "><br>
<span class="id" title="keyword">Import</span> <span class="id" title="var">NulM</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(113, '0_3_27');
      "><br>
<span class="id" title="keyword">Import</span> <span class="id" title="var">AccNulM</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(114, '0_3_27');
      "><br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Import</span> <a name="Topological_Lex.LexNulM"><span class="id" title="module">LexNulM</span></a> := <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a> <a class="idref" href="HoTT.Modalities.Nullification.html#Nullification_Modalities"><span class="id" title="module">Nullification_Modalities</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(115, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="Topological_Lex.topological_lex_trunc_acc"><span class="id" title="definition">topological_lex_trunc_acc</span></a> `{<a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" title="class">Funext</span></a>}<br>
(<span class="id" title="var">B</span> : <a class="idref" href="HoTT.Modalities.Accessible.html#NullGenerators"><span class="id" title="record">NullGenerators</span></a>) {<span class="id" title="var">Olex</span> : <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.Lex"><span class="id" title="class">Lex</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#B"><span class="id" title="variable">B</span></a>)}<br>
(<span class="id" title="var">n</span> : <a class="idref" href="HoTT.Basics.Overture.html#trunc_index"><span class="id" title="inductive">trunc_index</span></a>) (<span class="id" title="var">gtr</span> : <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation"></span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#n"><span class="id" title="variable">n</span></a> (<a class="idref" href="HoTT.Modalities.Accessible.html#ngen_type"><span class="id" title="projection">ngen_type</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#a"><span class="id" title="variable">a</span></a>))<br>
: <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a> <span class="id" title="var">D</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Modalities.Accessible.html#NullGenerators"><span class="id" title="record">NullGenerators</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a><br>
<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation"></span></a> <span class="id" title="var">c</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.Modalities.Accessible.html#ngen_type"><span class="id" title="projection">ngen_type</span></a> <span class="id" title="var">D</span> <a class="idref" href="HoTT.Modalities.Topological.html#c"><span class="id" title="variable">c</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation"></span></a><br>
<a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.OeqO"><span class="id" title="class">OeqO</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">D</span>) (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#B"><span class="id" title="variable">B</span></a>) <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(116, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(117, '0_3_27');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(118, '0_3_27');
      "><br>
{ <span class="id" title="tactic"></span> (<a class="idref" href="HoTT.Modalities.Accessible.html#Build_NullGenerators"><span class="id" title="constructor">Build_NullGenerators</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Empty"><span class="id" title="inductive">Empty</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span>  <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(119, '0_3_27');
      "><br>
<span class="id" title="tactic">split</span>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">intros</span> <span class="id" title="var">X</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(120, '0_3_27');
      "><br>
<span class="id" title="tactic">split</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>; [ | <span class="id" title="tactic">intros</span> [] ].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(121, '0_3_27');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Nullification.html#Accessible_Nullification.inO_iff_isnull"><span class="id" title="definition">inO_iff_isnull</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(122, '0_3_27');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Extensions.html#ooextendable_equiv"><span class="id" title="definition">ooextendable_equiv</span></a>, <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_contr_contr"><span class="id" title="instance">isequiv_contr_contr</span></a>. }<br>
<span class="id" title="tactic">pose</span> (<span class="id" title="var">O</span> := <a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">B</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(123, '0_3_27');
      "><br>
<span class="id" title="tactic">pose</span> (<span class="id" title="var">OeqB</span> := <a class="idref" href="HoTT.Basics.Overture.html#reflexivity"><span class="id" title="definition">reflexivity</span></a> <span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.OeqO"><span class="id" title="class">OeqO</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">B</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(124, '0_3_27');
      "><br>
<span class="id" title="tactic">fold</span> <span class="id" title="var">O</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Olex</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(125, '0_3_27');
      "><br>
<span class="id" title="var">clearbody</span> <span class="id" title="var">O</span> <span class="id" title="var">OeqB</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(126, '0_3_27');
      "><br>
<span class="id" title="var">revert</span> <span class="id" title="var">B</span> <span class="id" title="var">OeqB</span> <span class="id" title="var">gtr</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(127, '0_3_27');
      "><br>
<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">OeqB</span> <span class="id" title="var">gtr</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(128, '0_3_27');
      "><br>
{ <span class="id" title="tactic"></span> <span class="id" title="var">B</span>; <span class="id" title="tactic">split</span>; [ <span class="id" title="tactic">assumption</span> | <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">reflexivity</span> ]. }</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(129, '0_3_27');
      "><br>
<span class="id" title="tactic">pose</span> (<span class="id" title="var">A</span> := <a class="idref" href="HoTT.Modalities.Accessible.html#ngen_indices"><span class="id" title="projection">ngen_indices</span></a> <span class="id" title="var">B</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(130, '0_3_27');
      "><br>
<span class="id" title="tactic">pose</span> (<span class="id" title="var">C</span> := <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a> <span class="id" title="var">a</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a><span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">B</span>(<span class="id" title="var">a</span>) <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation"></span></a> <span class="id" title="var">B</span>(<span class="id" title="var">a</span>) <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(131, '0_3_27');
      "><br>
<span class="id" title="tactic">pose</span> (<span class="id" title="var">D</span> := <a class="idref" href="HoTT.Modalities.Accessible.html#Build_NullGenerators"><span class="id" title="constructor">Build_NullGenerators</span></a><br>
<span class="id" title="var">C</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">c</span>:<span class="id" title="var">C</span>  <span class="id" title="keyword">match</span> <a class="idref" href="HoTT.Modalities.Topological.html#c"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br>
| <a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span>  <a class="idref" href="HoTT.HIT.Truncations.html#merely"><span class="id" title="definition">merely</span></a> (<span class="id" title="var">B</span> <span class="id" title="var">a</span>)<br>
| <a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">b1</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">b2</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>  (<span class="id" title="var">b1</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">b2</span>)<br>
<span class="id" title="keyword">end</span> : <span class="id" title="keyword">Type</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(132, '0_3_27');
      "><br>
<span class="id" title="tactic">assert</span> (<span class="id" title="var">Dtrunc</span> : <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation"></span></a> <span class="id" title="var">c</span>:<span class="id" title="var">C</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#c22cac241987f957a2833c2ff4900717"><span class="id" title="notation">.+1</span></a> (<span class="id" title="var">D</span> <a class="idref" href="HoTT.Modalities.Topological.html#c"><span class="id" title="variable">c</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(133, '0_3_27');
      "><br>
{ <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> | [<span class="id" title="var">a</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>]]; [ <span class="id" title="var">cbn</span> | <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(134, '0_3_27');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br>
<span class="id" title="tactic">assert</span> (<span class="id" title="var">OeqD</span> : <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.OeqO"><span class="id" title="class">OeqO</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">D</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(135, '0_3_27');
      "><br>
{ <span class="id" title="tactic">intros</span> <span class="id" title="var">X</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(136, '0_3_27');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">X_inO</span> <span class="id" title="var">c</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(137, '0_3_27');
      "><br>
<span class="id" title="tactic">assert</span> (<span class="id" title="var">Bc</span> : <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation"></span></a> <span class="id" title="var">a</span>:<span class="id" title="var">A</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.IsConnected"><span class="id" title="class">IsConnected</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Topological.html#a"><span class="id" title="variable">a</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(138, '0_3_27');
      "><br>
{ <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(139, '0_3_27');
      "><br>
<span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.isconnected_OeqO"><span class="id" title="instance">isconnected_OeqO</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">B</span>) <span class="id" title="var">O</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(140, '0_3_27');
      "><br>
- <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(141, '0_3_27');
      "><br>
- <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Modalities.Nullification.html#AccNulM.isconnected_acc_gen"><span class="id" title="instance">isconnected_acc_gen</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">B</span>) <span class="id" title="var">a</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(142, '0_3_27');
      "><br>
<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.ooextendable_const_isconnected_inO"><span class="id" title="definition">ooextendable_const_isconnected_inO</span></a> <span class="id" title="var">O</span>);<br>
[ <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">a</span> | [<span class="id" title="var">a</span> [<span class="id" title="var">b1</span> <span class="id" title="var">b2</span>]]] | <span class="id" title="tactic">exact</span> <span class="id" title="var">X_inO</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(143, '0_3_27');
      "><br>
+ <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.isconnected_from_elim_to_O"><span class="id" title="definition">isconnected_from_elim_to_O</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(144, '0_3_27');
      "><br>
<span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.isconnected_elim"><span class="id" title="definition">isconnected_elim</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">O</span> (<a class="idref" href="HoTT.HIT.Truncations.html#merely"><span class="id" title="definition">merely</span></a> (<span class="id" title="var">B</span> <span class="id" title="var">a</span>)))<br>
(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span>  <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#b"><span class="id" title="variable">b</span></a>)))<br>
<span class="id" title="keyword">as</span> [<span class="id" title="var">x</span> <span class="id" title="var">h</span>].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(145, '0_3_27');
      "><br>
<span class="id" title="tactic"></span> <span class="id" title="var">x</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(146, '0_3_27');
      "><br>
<span class="id" title="var">strip_truncations</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(147, '0_3_27');
      "><br>
<span class="id" title="tactic">exact</span> (<span class="id" title="var">h</span> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(148, '0_3_27');
      "><br>
+ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(149, '0_3_27');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">Dnull</span>; <span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.inO_OeqO"><span class="id" title="definition">inO_OeqO</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">OeqB</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(150, '0_3_27');
      "><br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(151, '0_3_27');
      "><br>
<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Extensions.html#equiv_ooextendable_isequiv"><span class="id" title="definition">equiv_ooextendable_isequiv</span></a><br>
(<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">X</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span>:<span class="id" title="var">B</span> <span class="id" title="var">a</span>  <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(152, '0_3_27');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.EquivalenceVarieties.html#isequiv_fcontr"><span class="id" title="definition">isequiv_fcontr</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">f</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(153, '0_3_27');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv'"><span class="id" title="definition">contr_equiv'</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a> <span class="id" title="var">x</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a><span class="id" title="var">X</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation"></span></a> <span class="id" title="var">u</span>:<span class="id" title="var">B</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">f</span> <a class="idref" href="HoTT.Modalities.Topological.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(154, '0_3_27');
      "><br>
{ <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma'"><span class="id" title="definition">equiv_functor_sigma'</span></a> (<a class="idref" href="HoTT.Types.Unit.html#equiv_unit_rec"><span class="id" title="definition">equiv_unit_rec</span></a> <span class="id" title="var">X</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(155, '0_3_27');
      "><br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#composeD"><span class="id" title="definition">composeD</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(156, '0_3_27');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Arrow.html#equiv_path_arrow"><span class="id" title="definition">equiv_path_arrow</span></a>. }<br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.isconnected_elim"><span class="id" title="definition">isconnected_elim</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">D</span>) (<span class="id" title="var">A</span> := <span class="id" title="var">D</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span>)) <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(157, '0_3_27');
      "><br>
{ <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Nullification.html#AccNulM.isconnected_acc_gen"><span class="id" title="instance">isconnected_acc_gen</span></a>. }<br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(158, '0_3_27');
      "><span class="id" title="var">strip_truncations</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(159, '0_3_27');
      "><br>
<span class="id" title="tactic">assert</span> (<span class="id" title="var">bc</span> : <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.IsConnMap"><span class="id" title="class">IsConnMap</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">D</span>) (<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(160, '0_3_27');
      "><br>
{ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(161, '0_3_27');
      "><br>
<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">D</span>) (<span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">x</span>)<br>
<a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Types.Sigma.html#equiv_contr_sigma"><span class="id" title="definition">equiv_contr_sigma</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(162, '0_3_27');
      "><br>
<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.Nullification.html#AccNulM.isconnected_acc_gen"><span class="id" title="instance">isconnected_acc_gen</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">D</span>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">b</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><span class="id" title="var">x</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>)). }</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(163, '0_3_27');
      "><br>
<span class="id" title="tactic">pose</span> (<span class="id" title="var">p</span> := <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.conn_map_elim"><span class="id" title="definition">conn_map_elim</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">D</span>) (<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">b</span>)<br>
(<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span>  <span class="id" title="var">f</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">f</span> <a class="idref" href="HoTT.Modalities.Topological.html#u"><span class="id" title="variable">u</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span>  1)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(164, '0_3_27');
      "><br>
<span class="id" title="tactic"></span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">f</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">x</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(165, '0_3_27');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#path_sigma'"><span class="id" title="definition">path_sigma'</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><span class="id" title="var">q</span> <span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>); <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(166, '0_3_27');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.conn_map_elim"><span class="id" title="definition">conn_map_elim</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">D</span>) (<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">b</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> [].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(167, '0_3_27');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Forall.html#transport_forall_constant"><span class="id" title="definition">transport_forall_constant</span></a>, <a class="idref" href="HoTT.Types.Paths.html#transport_paths_l"><span class="id" title="definition">transport_paths_l</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(168, '0_3_27');
      "><br>
<span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex.conn_map_comp"><span class="id" title="definition">conn_map_comp</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="constructor">Nul</span></a> <span class="id" title="var">D</span>) (<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">b</span>)<br>
(<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span>:<span class="id" title="var">B</span> <span class="id" title="var">a</span>  <span class="id" title="var">f</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">f</span> <a class="idref" href="HoTT.Modalities.Topological.html#u"><span class="id" title="variable">u</span></a>)<br>
(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span>  1) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> : <span class="id" title="var">p</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 1).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(169, '0_3_27');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>. }<br>
<span class="id" title="tactic">destruct</span> (<span class="id" title="var">IHn</span> <span class="id" title="var">D</span> <span class="id" title="var">OeqD</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">E</span> [<span class="id" title="var">HE</span> <span class="id" title="var">EeqD</span>]].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(170, '0_3_27');
      "><br>
<span class="id" title="tactic"></span> <span class="id" title="var">E</span>; <span class="id" title="tactic">split</span>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">HE</span> | ].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(171, '0_3_27');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> <span class="id" title="var">EeqD</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(172, '0_3_27');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> <span class="id" title="var">_</span> <span class="id" title="var">OeqB</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(173, '0_3_27');
      "><br>
<span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(174, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(175, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Topological.html#Topological_Lex"><span class="id" title="module">Topological_Lex</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(176, '0_3_27');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "<infomsg>Interactive Module Lex_Modalities_Theory started</infomsg>	";
            responses[i]=data;
          

            i = 28;
            data = "<infomsg>Module Os_Theory is defined</infomsg>	";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "";
            responses[i]=data;
          

            i = 32;
            data = "";
            responses[i]=data;
          

            i = 33;
            data = "";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "";
            responses[i]=data;
          

            i = 36;
            data = "";
            responses[i]=data;
          

            i = 37;
            data = "";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "1 subgoal, subgoal 1 (ID 12)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  H0 : IsConnected O A	  H1 : IsConnected O B	  ============================	  IsConnMap O f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 41;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 42;
            data = "<infomsg>conn_map_lex is defined</infomsg>	";
            responses[i]=data;
          

            i = 43;
            data = "1 subgoal, subgoal 1 (ID 19)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> IsConnMap O f	  ============================	  Lex O		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 44;
            data = "1 subgoal, subgoal 1 (ID 19)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> IsConnMap O f	  ============================	  Lex O		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 45;
            data = "1 subgoal, subgoal 1 (ID 24)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> IsConnMap O f	  A : Type	  x, y : A	  AC : IsConnected O A	  ============================	  IsConnected O (x = y)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 46;
            data = "1 subgoal, subgoal 1 (ID 48)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> IsConnMap O f	  A : Type	  x, y : A	  AC : IsConnected O A	  ============================	  hfiber (unit_name x) y <~> x = y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 47;
            data = "1 subgoal, subgoal 1 (ID 49)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> IsConnMap O f	  A : Type	  x, y : A	  AC : IsConnected O A	  ============================	  {_ : Unit & x = y} <~> x = y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 48;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 49;
            data = "<infomsg>lex_from_conn_map_lex is defined</infomsg>	";
            responses[i]=data;
          

            i = 50;
            data = "";
            responses[i]=data;
          

            i = 51;
            data = "";
            responses[i]=data;
          

            i = 52;
            data = "";
            responses[i]=data;
          

            i = 53;
            data = "";
            responses[i]=data;
          

            i = 54;
            data = "1 subgoal, subgoal 1 (ID 42)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : B -> C	  ============================	  IsConnMap O g -> IsConnMap O (g o f) -> IsConnMap O f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 55;
            data = "1 subgoal, subgoal 1 (ID 42)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : B -> C	  ============================	  IsConnMap O g -> IsConnMap O (g o f) -> IsConnMap O f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 56;
            data = "1 subgoal, subgoal 1 (ID 46)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : B -> C	  X : IsConnMap O g	  X0 : IsConnMap O (g o f)	  b : B	  ============================	  IsConnected O (hfiber f b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 57;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 58;
            data = "<infomsg>cancelL_conn_map is defined</infomsg>	";
            responses[i]=data;
          

            i = 59;
            data = "";
            responses[i]=data;
          

            i = 60;
            data = "";
            responses[i]=data;
          

            i = 61;
            data = "";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "";
            responses[i]=data;
          

            i = 67;
            data = "1 subgoal, subgoal 1 (ID 55)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  O_inverts0 : O_inverts O f	  ============================	  IsConnMap O f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 68;
            data = "1 subgoal, subgoal 1 (ID 55)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  O_inverts0 : O_inverts O f	  ============================	  IsConnMap O f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 69;
            data = "1 subgoal, subgoal 1 (ID 298)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  O_inverts0 : O_inverts O f	  ============================	  IsConnMap O (fun x : A => to O B (f x))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 70;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "<infomsg>isconnected_O_inverts is defined</infomsg>	";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          

            i = 77;
            data = "";
            responses[i]=data;
          

            i = 78;
            data = "";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "1 subgoal, subgoal 1 (ID 69)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : A -> C	  g : B -> C	  H0 : IsConnected O A	  H1 : IsConnected O B	  H2 : IsConnected O C	  ============================	  IsConnected O (Pullback f g)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 84;
            data = "1 subgoal, subgoal 1 (ID 73)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : A -> C	  g : B -> C	  H0 : IsConnected O A	  H1 : IsConnected O B	  H2 : IsConnected O C	  a : A	  ============================	  IsConnected O {c : B & f a = g c}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 85;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 86;
            data = "<infomsg>isconnected_pullback is defined</infomsg>	";
            responses[i]=data;
          

            i = 87;
            data = "";
            responses[i]=data;
          

            i = 88;
            data = "";
            responses[i]=data;
          

            i = 89;
            data = "";
            responses[i]=data;
          

            i = 90;
            data = "";
            responses[i]=data;
          

            i = 91;
            data = "1 subgoal, subgoal 1 (ID 99)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  ============================	  IsPullback	    (O_functor_square O pullback_pr1 pullback_pr2 f g (pullback_commsq f g))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 92;
            data = "1 subgoal, subgoal 1 (ID 99)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  ============================	  IsPullback	    (O_functor_square O pullback_pr1 pullback_pr2 f g (pullback_commsq f g))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 93;
            data = "1 subgoal, subgoal 1 (ID 701)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  ============================	  O_inverts O	    (pullback_corec	       (O_functor_square O pullback_pr1 pullback_pr2 f g	          (pullback_commsq f g)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 94;
            data = "1 subgoal, subgoal 1 (ID 969)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  ============================	  IsConnMap O	    (pullback_corec	       (O_functor_square O pullback_pr1 pullback_pr2 f g	          (pullback_commsq f g)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 95;
            data = "1 subgoal, subgoal 1 (ID 2079)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  ============================	  IsConnMap O	    (fun x : Pullback f g =>	     pullback_corec	       (O_functor_square O pullback_pr1 pullback_pr2 f g	          (pullback_commsq f g)) (to O (Pullback f g) x))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 96;
            data = "2 subgoals, subgoal 1 (ID 2825)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  ============================	  functor_pullback f g (O_functor O f) (O_functor O g) 	    (to O A) (to O B) (to O C) (to_O_natural O f) 	    (to_O_natural O g) ==	  (fun x : Pullback f g =>	   pullback_corec	     (O_functor_square O pullback_pr1 pullback_pr2 f g (pullback_commsq f g))	     (to O (Pullback f g) x))		subgoal 2 (ID 2826) is:	 IsConnMap O	   (functor_pullback f g (O_functor O f) (O_functor O g) 	      (to O A) (to O B) (to O C) (to_O_natural O f) 	      (to_O_natural O g))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 97;
            data = "";
            responses[i]=data;
          

            i = 98;
            data = "";
            responses[i]=data;
          

            i = 99;
            data = "";
            responses[i]=data;
          

            i = 100;
            data = "";
            responses[i]=data;
          

            i = 101;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2825)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  ============================	  functor_pullback f g (O_functor O f) (O_functor O g) 	    (to O A) (to O B) (to O C) (to_O_natural O f) 	    (to_O_natural O g) ==	  (fun x : Pullback f g =>	   pullback_corec	     (O_functor_square O pullback_pr1 pullback_pr2 f g (pullback_commsq f g))	     (to O (Pullback f g) x))		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2842)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  (to O B b;	  (to O C c; (to_O_natural O f b @ ap (to O A) e) @ (to_O_natural O g c)^)) =	  (O_functor O pullback_pr1 (to O (Pullback f g) (b; (c; e)));	  (O_functor O pullback_pr2 (to O (Pullback f g) (b; (c; e)));	  O_functor_square O pullback_pr1 pullback_pr2 f g 	    (pullback_commsq f g) (to O (Pullback f g) (b; (c; e)))))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 102;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2864)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  transport	    (fun b0 : O B => {c0 : O C & O_functor O f b0 = O_functor O g c0})	    (to_O_natural O pullback_pr1 (b; (c; e)))^	    (to O C c; (to_O_natural O f b @ ap (to O A) e) @ (to_O_natural O g c)^) =	  (O_functor O pullback_pr2 (to O (Pullback f g) (b; (c; e)));	  O_functor_square O pullback_pr1 pullback_pr2 f g 	    (pullback_commsq f g) (to O (Pullback f g) (b; (c; e))))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 103;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2883)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  (to O C c;	  transport (fun x : O B => O_functor O f x = O_functor O g (to O C c))	    (to_O_natural O pullback_pr1 (b; (c; e)))^	    ((to_O_natural O f b @ ap (to O A) e) @ (to_O_natural O g c)^)) =	  (O_functor O pullback_pr2 (to O (Pullback f g) (b; (c; e)));	  O_functor_square O pullback_pr1 pullback_pr2 f g 	    (pullback_commsq f g) (to O (Pullback f g) (b; (c; e))))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 104;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2905)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  transport	    (fun c0 : O C =>	     O_functor O f	       (O_functor O pullback_pr1 (to O (Pullback f g) (b; (c; e)))) =	     O_functor O g c0) (to_O_natural O pullback_pr2 (b; (c; e)))^	    (transport (fun x : O B => O_functor O f x = O_functor O g (to O C c))	       (to_O_natural O pullback_pr1 (b; (c; e)))^	       ((to_O_natural O f b @ ap (to O A) e) @ (to_O_natural O g c)^)) =	  O_functor_square O pullback_pr1 pullback_pr2 f g 	    (pullback_commsq f g) (to O (Pullback f g) (b; (c; e)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 105;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2912)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  transport	    (fun c0 : O C =>	     O_functor O f	       (O_functor O pullback_pr1 (to O (Pullback f g) (b; (c; e)))) =	     O_functor O g c0) (to_O_natural O pullback_pr2 (b; (c; e)))^	    ((ap (O_functor O f) (to_O_natural O pullback_pr1 (b; (c; e)))^)^ @	     ((to_O_natural O f b @ ap (to O A) e) @ (to_O_natural O g c)^)) =	  O_functor_square O pullback_pr1 pullback_pr2 f g 	    (pullback_commsq f g) (to O (Pullback f g) (b; (c; e)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 106;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2925)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  ((ap (O_functor O f) (to_O_natural O pullback_pr1 (b; (c; e)))^)^ @	   ((to_O_natural O f b @ ap (to O A) e) @ (to_O_natural O g c)^)) @	  ap (O_functor O g) (to_O_natural O pullback_pr2 (b; (c; e)))^ =	  O_functor_square O pullback_pr1 pullback_pr2 f g 	    (pullback_commsq f g) (to O (Pullback f g) (b; (c; e)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 107;
            data = "";
            responses[i]=data;
          

            i = 108;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2932)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  (ap (O_functor O f) (to_O_natural O pullback_pr1 (b; (c; e)))^)^	  @' (to_O_natural O f b	      @' ap (to O A) e	      @' (to_O_natural O g c)^)	  @' ap (O_functor O g) (to_O_natural O pullback_pr2 (b; (c; e)))^ =	  (O_functor_compose O pullback_pr1 f (to O (Pullback f g) (b; (c; e))))^	  @' (O_functor_homotopy O (fun x : Pullback f g => f (pullback_pr1 x))	        (fun x : Pullback f g => g (pullback_pr2 x)) 	        (pullback_commsq f g) (to O (Pullback f g) (b; (c; e)))	      @' O_functor_compose O pullback_pr2 g (to O (Pullback f g) (b; (c; e))))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 109;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2975)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  ap (O_functor O f) (to_O_natural O pullback_pr1 (b; (c; e)))	  @' to_O_natural O f b	  @' ap (to O A) e	  @' (to_O_natural O g c)^	  @' ap (O_functor O g) (to_O_natural O pullback_pr2 (b; (c; e)))^ =	  (O_functor_compose O pullback_pr1 f (to O (Pullback f g) (b; (c; e))))^	  @' to_O_natural O (fun x : Pullback f g => f (pullback_pr1 x)) (b; (c; e))	  @' ap (to O A) (pullback_commsq f g (b; (c; e)))	  @' (to_O_natural O (fun x : Pullback f g => g (pullback_pr2 x)) (b; (c; e)))^	  @' O_functor_compose O pullback_pr2 g (to O (Pullback f g) (b; (c; e)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 110;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 3085)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  ap (O_functor O f) (to_O_natural O pullback_pr1 (b; (c; e)))	  @' to_O_natural O f b	  @' ap (to O A) e	  @' (to_O_natural O g c)^	  @' ap (O_functor O g) (to_O_natural O pullback_pr2 (b; (c; e)))^ =	  (O_functor_compose O pullback_pr1 f (to O (Pullback f g) (b; (c; e))))^	  @' to_O_natural O (fun x : Pullback f g => f (pullback_pr1 x)) (b; (c; e))	  @' ap (to O A) e	  @' (to_O_natural O (fun x : Pullback f g => g (pullback_pr2 x)) (b; (c; e)))^	  @' O_functor_compose O pullback_pr2 g (to O (Pullback f g) (b; (c; e)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 111;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 3122)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  (O_functor_compose O pullback_pr1 f (to O (Pullback f g) (b; (c; e))))^	  @' (to_O_natural O (fun x : Pullback f g => f (pullback_pr1 x)) (b; (c; e))	      @' (ap (to O A) e	          @' ((to_O_natural O g c)^	              @' ap (O_functor O g)	                   (to_O_natural O pullback_pr2 (b; (c; e)))^))) =	  (O_functor_compose O pullback_pr1 f (to O (Pullback f g) (b; (c; e))))^	  @' (to_O_natural O (fun x : Pullback f g => f (pullback_pr1 x)) (b; (c; e))	      @' (ap (to O A) e	          @' ((to_O_natural O (fun x : Pullback f g => g (pullback_pr2 x))	                 (b; (c; e)))^	              @' O_functor_compose O pullback_pr2 g	                   (to O (Pullback f g) (b; (c; e))))))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 112;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 3147)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  (to_O_natural O g c)^	  @' ap (O_functor O g) (to_O_natural O pullback_pr2 (b; (c; e)))^ =	  (to_O_natural O (fun x : Pullback f g => g (pullback_pr2 x)) (b; (c; e)))^	  @' O_functor_compose O pullback_pr2 g (to O (Pullback f g) (b; (c; e)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 113;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 3157)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  (ap (O_functor O g) (to_O_natural O pullback_pr2 (b; (c; e)))	   @' to_O_natural O g c)^ =	  (to_O_natural O (fun x : Pullback f g => g (pullback_pr2 x)) (b; (c; e)))^	  @' O_functor_compose O pullback_pr2 g (to O (Pullback f g) (b; (c; e)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 114;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 3187)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  b : B	  c : C	  e : f b = g c	  ============================	  (ap (O_functor O g) (to_O_natural O pullback_pr2 (b; (c; e)))	   @' to_O_natural O g c)^ =	  ((O_functor_compose O pullback_pr2 g (to O (Pullback f g) (b; (c; e))))^	   @' to_O_natural O (fun x : Pullback f g => g (pullback_pr2 x)) (b; (c; e)))^		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 115;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 2826)		subgoal 1 (ID 2826) is:	 IsConnMap O	   (functor_pullback f g (O_functor O f) (O_functor O g) 	      (to O A) (to O B) (to O C) (to_O_natural O f) 	      (to_O_natural O g))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 116;
            data = "";
            responses[i]=data;
          

            i = 117;
            data = "";
            responses[i]=data;
          

            i = 118;
            data = "";
            responses[i]=data;
          

            i = 119;
            data = "";
            responses[i]=data;
          

            i = 120;
            data = "";
            responses[i]=data;
          

            i = 121;
            data = "";
            responses[i]=data;
          

            i = 122;
            data = "";
            responses[i]=data;
          

            i = 123;
            data = "";
            responses[i]=data;
          

            i = 124;
            data = "";
            responses[i]=data;
          

            i = 125;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 2826)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  ============================	  IsConnMap O	    (functor_pullback f g (O_functor O f) (O_functor O g) 	       (to O A) (to O B) (to O C) (to_O_natural O f) 	       (to_O_natural O g))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 126;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 3207)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  f : B -> A	  g : C -> A	  ob : O B	  oc : O C	  oe : O_functor O f ob = O_functor O g oc	  ============================	  IsConnected O	    (hfiber	       (functor_pullback f g (O_functor O f) (O_functor O g) 	          (to O A) (to O B) (to O C) (to_O_natural O f) 	          (to_O_natural O g)) (ob; (oc; oe)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 127;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 128;
            data = "";
            responses[i]=data;
          

            i = 129;
            data = "";
            responses[i]=data;
          

            i = 130;
            data = "";
            responses[i]=data;
          

            i = 131;
            data = "";
            responses[i]=data;
          

            i = 132;
            data = "<infomsg>O_functor_pullback is defined</infomsg>	";
            responses[i]=data;
          

            i = 133;
            data = "1 subgoal, subgoal 1 (ID 112)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  ============================	  IsEquiv (O_functor_hfiber O f b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 134;
            data = "1 subgoal, subgoal 1 (ID 497)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  ============================	  O_inverts O (O_functor_hfiber O f b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 135;
            data = "1 subgoal, subgoal 1 (ID 498)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  ============================	  IsConnMap O (O_functor_hfiber O f b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 136;
            data = "1 subgoal, subgoal 1 (ID 1882)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  ============================	  IsConnMap O	    (fun x : hfiber f b => O_functor_hfiber O f b (to O (hfiber f b) x))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 137;
            data = "1 subgoal, subgoal 1 (ID 1883)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  ============================	  IsConnMap O	    (fun x : hfiber f b =>	     O_rec	       (fun X : hfiber f b =>	        (to O A (let (proj1_sig, _) := X in proj1_sig);	        to_O_natural O f (let (proj1_sig, _) := X in proj1_sig) @	        ap (to O B)	          (let	             (proj1_sig, proj2_sig) as s	              return ((fun x0 : A => f x0 = b) s.1) := X in	           proj2_sig))) (to O (hfiber f b) x))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 138;
            data = "2 subgoals, subgoal 1 (ID 2741)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  ============================	  functor_hfiber (fun x : A => (to_O_natural O f x)^) b ==	  (fun x : hfiber f b =>	   O_rec	     (fun X : hfiber f b =>	      (to O A (let (proj1_sig, _) := X in proj1_sig);	      to_O_natural O f (let (proj1_sig, _) := X in proj1_sig) @	      ap (to O B)	        (let	           (proj1_sig, proj2_sig) as s	            return ((fun x0 : A => f x0 = b) s.1) := X in	         proj2_sig))) (to O (hfiber f b) x))		subgoal 2 (ID 2742) is:	 IsConnMap O (functor_hfiber (fun x : A => (to_O_natural O f x)^) b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 139;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2741)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  ============================	  functor_hfiber (fun x : A => (to_O_natural O f x)^) b ==	  (fun x : hfiber f b =>	   O_rec	     (fun X : hfiber f b =>	      (to O A (let (proj1_sig, _) := X in proj1_sig);	      to_O_natural O f (let (proj1_sig, _) := X in proj1_sig) @	      ap (to O B)	        (let	           (proj1_sig, proj2_sig) as s	            return ((fun x0 : A => f x0 = b) s.1) := X in	         proj2_sig))) (to O (hfiber f b) x))		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2748)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  a : A	  p : f a = b	  ============================	  functor_hfiber (fun x : A => (to_O_natural O f x)^) b (a; p) =	  O_rec	    (fun X : hfiber f b =>	     (to O A (let (proj1_sig, _) := X in proj1_sig);	     to_O_natural O f (let (proj1_sig, _) := X in proj1_sig) @	     ap (to O B)	       (let	          (proj1_sig, proj2_sig) as s return ((fun x : A => f x = b) s.1) :=	          X in	        proj2_sig))) (to O (hfiber f b) (a; p))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 140;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2753)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  a : A	  p : f a = b	  ============================	  functor_hfiber (fun x : A => (to_O_natural O f x)^) b (a; p) =	  (to O A a; to_O_natural O f a @ ap (to O B) p)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 141;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2758)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  a : A	  p : f a = b	  ============================	  (to O A (a; p).1; ((to_O_natural O f (a; p).1)^)^ @ ap (to O B) (a; p).2) =	  (to O A a; to_O_natural O f a @ ap (to O B) p)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 142;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2761)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  a : A	  p : f a = b	  ============================	  ((to_O_natural O f (a; p).1)^)^ @ ap (to O B) (a; p).2 =	  to_O_natural O f a @ ap (to O B) p		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 143;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 2742)		subgoal 1 (ID 2742) is:	 IsConnMap O (functor_hfiber (fun x : A => (to_O_natural O f x)^) b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 144;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 2742)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  ============================	  IsConnMap O (functor_hfiber (fun x : A => (to_O_natural O f x)^) b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 2777)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  b : B	  oa : O A	  p : O_functor O f oa = to O B b	  ============================	  IsConnected O	    (hfiber (functor_hfiber (fun x : A => (to_O_natural O f x)^) b) (oa; p))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 145;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 146;
            data = "<infomsg>isequiv_O_functor_hfiber is defined</infomsg>	";
            responses[i]=data;
          

            i = 147;
            data = "<infomsg>equiv_O_functor_hfiber is defined</infomsg>	";
            responses[i]=data;
          

            i = 148;
            data = "";
            responses[i]=data;
          

            i = 149;
            data = "";
            responses[i]=data;
          

            i = 150;
            data = "";
            responses[i]=data;
          

            i = 151;
            data = "";
            responses[i]=data;
          

            i = 152;
            data = "<infomsg>O_path_cmp is defined</infomsg>	";
            responses[i]=data;
          

            i = 153;
            data = "";
            responses[i]=data;
          

            i = 154;
            data = "1 subgoal, subgoal 1 (ID 160)	  	  O : Modality	  H : Lex O	  A : Type	  x, y : A	  ============================	  IsEquiv (O_path_cmp O x y)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 155;
            data = "1 subgoal, subgoal 1 (ID 543)	  	  O : Modality	  H : Lex O	  A : Type	  x, y : A	  ============================	  IsConnMap O (O_path_cmp O x y)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 156;
            data = "1 subgoal, subgoal 1 (ID 2005)	  	  O : Modality	  H : Lex O	  A : Type	  x, y : A	  ============================	  IsConnMap O (fun x0 : x = y => O_path_cmp O x y (to O (x = y) x0))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 157;
            data = "2 subgoals, subgoal 1 (ID 2251)	  	  O : Modality	  H : Lex O	  A : Type	  x, y : A	  ============================	  ap (to O A) == (fun x0 : x = y => O_path_cmp O x y (to O (x = y) x0))		subgoal 2 (ID 2252) is:	 IsConnMap O (ap (to O A))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 158;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2251)	  	  O : Modality	  H : Lex O	  A : Type	  x, y : A	  ============================	  ap (to O A) == (fun x0 : x = y => O_path_cmp O x y (to O (x = y) x0))		(dependent evars: (printing disabled) )		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 2252)		subgoal 1 (ID 2252) is:	 IsConnMap O (ap (to O A))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 159;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 2252)	  	  O : Modality	  H : Lex O	  A : Type	  x, y : A	  ============================	  IsConnMap O (ap (to O A))		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 2272)	  	  O : Modality	  H : Lex O	  A : Type	  x, y : A	  p : to O A x = to O A y	  ============================	  IsConnected O (hfiber (ap (to O A)) p)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 160;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 161;
            data = "<infomsg>isequiv_O_path_cmp is defined</infomsg>	";
            responses[i]=data;
          

            i = 162;
            data = "";
            responses[i]=data;
          

            i = 163;
            data = "";
            responses[i]=data;
          

            i = 164;
            data = "";
            responses[i]=data;
          

            i = 165;
            data = "";
            responses[i]=data;
          

            i = 166;
            data = "";
            responses[i]=data;
          

            i = 167;
            data = "1 subgoal, subgoal 1 (ID 175)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  f : A -> B	  H0 : IsConnected O A	  H1 : IsConnected O B	  H2 : MapIn O f	  ============================	  IsEquiv f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 168;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 169;
            data = "<infomsg>isequiv_ismodal_isconnected_types is defined</infomsg>	";
            responses[i]=data;
          

            i = 170;
            data = "1 subgoal, subgoal 1 (ID 184)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> MapIn O f -> IsEquiv f	  ============================	  Lex O		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 171;
            data = "1 subgoal, subgoal 1 (ID 184)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> MapIn O f -> IsEquiv f	  ============================	  Lex O		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 172;
            data = "1 subgoal, subgoal 1 (ID 186)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> MapIn O f -> IsEquiv f	  ============================	  forall (A B : Type) (f : A -> B),	  IsConnected O A -> IsConnected O B -> IsConnMap O f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 173;
            data = "1 subgoal, subgoal 1 (ID 191)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> MapIn O f -> IsEquiv f	  A : Type	  B : Type	  f : A -> B	  AC : IsConnected O A	  BC : IsConnected O B	  ============================	  IsConnMap O f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 174;
            data = "1 subgoal, subgoal 1 (ID 203)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> MapIn O f -> IsEquiv f	  A, B : Type	  f : A -> B	  AC : IsConnected O A	  BC : IsConnected O B	  ============================	  IsConnMap O (fun x : A => factor2 (image O f) (factor1 (image O f) x))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 175;
            data = "1 subgoal, subgoal 1 (ID 205)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> MapIn O f -> IsEquiv f	  A, B : Type	  f : A -> B	  AC : IsConnected O A	  BC : IsConnected O B	  ============================	  IsConnMap O (factor2 (image O f))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 176;
            data = "1 subgoal, subgoal 1 (ID 207)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> MapIn O f -> IsEquiv f	  A, B : Type	  f : A -> B	  AC : IsConnected O A	  BC : IsConnected O B	  ============================	  IsEquiv (factor2 (image O f))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 177;
            data = "1 subgoal, subgoal 1 (ID 208)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> MapIn O f -> IsEquiv f	  A, B : Type	  f : A -> B	  AC : IsConnected O A	  BC : IsConnected O B	  ============================	  IsConnected O (image O f)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 178;
            data = "1 subgoal, subgoal 1 (ID 213)	  	  O : Modality	  H : forall (A B : Type) (f : A -> B),	      IsConnected O A -> IsConnected O B -> MapIn O f -> IsEquiv f	  A, B : Type	  f : A -> B	  AC : IsConnected O A	  BC : IsConnected O B	  ============================	  IsConnMap O (const tt)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 179;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 180;
            data = "<infomsg>lex_from_isequiv_ismodal_isconnected_types is defined</infomsg>	";
            responses[i]=data;
          

            i = 181;
            data = "";
            responses[i]=data;
          

            i = 182;
            data = "";
            responses[i]=data;
          

            i = 183;
            data = "";
            responses[i]=data;
          

            i = 184;
            data = "";
            responses[i]=data;
          

            i = 185;
            data = "1 subgoal, subgoal 1 (ID 240)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  D : Type	  f : A -> B	  g : C -> D	  h : A -> C	  k : B -> D	  H0 : IsConnMap O f	  H1 : IsConnMap O g	  H2 : MapIn O h	  H3 : MapIn O k	  p : k o f == g o h	  ============================	  IsPullback p		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 186;
            data = "1 subgoal, subgoal 1 (ID 240)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  D : Type	  f : A -> B	  g : C -> D	  h : A -> C	  k : B -> D	  H0 : IsConnMap O f	  H1 : IsConnMap O g	  H2 : MapIn O h	  H3 : MapIn O k	  p : k o f == g o h	  ============================	  IsPullback p		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 187;
            data = "2 subgoals, subgoal 1 (ID 720)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  D : Type	  f : A -> B	  g : C -> D	  h : A -> C	  k : B -> D	  H0 : IsConnMap O f	  H1 : IsConnMap O g	  H2 : MapIn O h	  H3 : MapIn O k	  p : k o f == g o h	  ============================	  IsConnMap O (pullback_corec p)		subgoal 2 (ID 721) is:	 MapIn O (pullback_corec p)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 188;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 720)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  D : Type	  f : A -> B	  g : C -> D	  h : A -> C	  k : B -> D	  H0 : IsConnMap O f	  H1 : IsConnMap O g	  H2 : MapIn O h	  H3 : MapIn O k	  p : k o f == g o h	  ============================	  IsConnMap O (pullback_corec p)		(dependent evars: (printing disabled) )		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 721)		subgoal 1 (ID 721) is:	 MapIn O (pullback_corec p)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 189;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 721)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  D : Type	  f : A -> B	  g : C -> D	  h : A -> C	  k : B -> D	  H0 : IsConnMap O f	  H1 : IsConnMap O g	  H2 : MapIn O h	  H3 : MapIn O k	  p : k o f == g o h	  ============================	  MapIn O (pullback_corec p)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 190;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 2321)	  	  O : Modality	  H : Lex O	  A : Type	  B : Type	  C : Type	  D : Type	  f : A -> B	  g : C -> D	  h : A -> C	  k : B -> D	  H0 : IsConnMap O f	  H1 : IsConnMap O g	  H2 : MapIn O h	  H3 : MapIn O k	  p : k o f == g o h	  ============================	  MapIn O (fun x : A => (equiv_pullback_symm k g) (pullback_corec p x))		(dependent evars: (printing disabled) )		No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 191;
            data = "<infomsg>ispullback_connmap_mapino_commsq is defined</infomsg>	";
            responses[i]=data;
          

            i = 192;
            data = "1 subgoal, subgoal 1 (ID 283)	  	  O : Modality	  H : forall (A B C D : Type) (f : A -> B) (g : C -> D) 	      (h : A -> C) (k : B -> D),	      IsConnMap O f ->	      IsConnMap O g ->	      MapIn O h -> MapIn O k -> forall p : k o f == g o h, IsPullback p	  ============================	  Lex O		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 193;
            data = "1 subgoal, subgoal 1 (ID 283)	  	  O : Modality	  H : forall (A B C D : Type) (f : A -> B) (g : C -> D) 	      (h : A -> C) (k : B -> D),	      IsConnMap O f ->	      IsConnMap O g ->	      MapIn O h -> MapIn O k -> forall p : k o f == g o h, IsPullback p	  ============================	  Lex O		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 194;
            data = "1 subgoal, subgoal 1 (ID 285)	  	  O : Modality	  H : forall (A B C D : Type) (f : A -> B) (g : C -> D) 	      (h : A -> C) (k : B -> D),	      IsConnMap O f ->	      IsConnMap O g ->	      MapIn O h -> MapIn O k -> forall p : k o f == g o h, IsPullback p	  ============================	  forall (A B : Type) (f : A -> B),	  IsConnected O A -> IsConnected O B -> MapIn O f -> IsEquiv f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 195;
            data = "1 subgoal, subgoal 1 (ID 291)	  	  O : Modality	  H : forall (A B C D : Type) (f : A -> B) (g : C -> D) 	      (h : A -> C) (k : B -> D),	      IsConnMap O f ->	      IsConnMap O g ->	      MapIn O h -> MapIn O k -> forall p : k o f == g o h, IsPullback p	  A : Type	  B : Type	  f : A -> B	  AC : IsConnected O A	  BC : IsConnected O B	  fM : MapIn O f	  ============================	  IsEquiv f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 196;
            data = "1 subgoal, subgoal 1 (ID 333)	  	  O : Modality	  A : Type	  B : Type	  f : A -> B	  H : IsPullback (fun x : A => 1)	  AC : IsConnected O A	  BC : IsConnected O B	  fM : MapIn O f	  ============================	  IsEquiv f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 197;
            data = "1 subgoal, subgoal 1 (ID 334)	  	  O : Modality	  A : Type	  B : Type	  f : A -> B	  H : IsEquiv (fun a : A => (const tt a; (f a; 1)))	  AC : IsConnected O A	  BC : IsConnected O B	  fM : MapIn O f	  ============================	  IsEquiv f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 198;
            data = "1 subgoal, subgoal 1 (ID 369)	  	  O : Modality	  A : Type	  B : Type	  f : A -> B	  H : IsEquiv (fun a : A => (const tt a; (f a; 1)))	  AC : IsConnected O A	  BC : IsConnected O B	  fM : MapIn O f	  ============================	  IsEquiv (fun x : Pullback idmap (const tt) => (x.2).1)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 199;
            data = "1 subgoal, subgoal 1 (ID 370)	  	  O : Modality	  A : Type	  B : Type	  f : A -> B	  H : IsEquiv (fun a : A => (const tt a; (f a; 1)))	  AC : IsConnected O A	  BC : IsConnected O B	  fM : MapIn O f	  ============================	  IsEquiv (fun x : {b : Unit & {c : B & b = const tt c}} => (x.2).1)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 200;
            data = "1 subgoal, subgoal 1 (ID 553)	  	  O : Modality	  A : Type	  B : Type	  f : A -> B	  H : IsEquiv (fun a : A => (const tt a; (f a; 1)))	  AC : IsConnected O A	  BC : IsConnected O B	  fM : MapIn O f	  ============================	  IsEquiv pr2		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 201;
            data = "1 subgoal, subgoal 1 (ID 595)	  	  O : Modality	  A : Type	  B : Type	  f : A -> B	  H : IsEquiv (fun a : A => (const tt a; (f a; 1)))	  AC : IsConnected O A	  BC : IsConnected O B	  fM : MapIn O f	  ============================	  IsEquiv snd		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 202;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 203;
            data = "<infomsg>lex_from_ispullback_connmap_mapino_commsq is defined</infomsg>	";
            responses[i]=data;
          

            i = 204;
            data = "";
            responses[i]=data;
          

            i = 205;
            data = "";
            responses[i]=data;
          

            i = 206;
            data = "";
            responses[i]=data;
          

            i = 207;
            data = "";
            responses[i]=data;
          

            i = 208;
            data = "";
            responses[i]=data;
          

            i = 209;
            data = "";
            responses[i]=data;
          

            i = 210;
            data = "";
            responses[i]=data;
          

            i = 211;
            data = "";
            responses[i]=data;
          

            i = 212;
            data = "";
            responses[i]=data;
          

            i = 213;
            data = "";
            responses[i]=data;
          

            i = 214;
            data = "";
            responses[i]=data;
          

            i = 215;
            data = "1 subgoal, subgoal 1 (ID 292)	  	  H : Funext	  O : Modality	  H0 : Lex O	  n : trunc_index	  A : Type	  H1 : IsTrunc n A	  ============================	  IsTrunc n (O A)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 216;
            data = "2 subgoals, subgoal 1 (ID 308)	  	  H : Funext	  O : Modality	  H0 : Lex O	  A : Type	  H1 : Contr A	  ============================	  Contr (O A)		subgoal 2 (ID 310) is:	 IsTrunc n.+1 (O A)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 217;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 308)	  	  H : Funext	  O : Modality	  H0 : Lex O	  A : Type	  H1 : Contr A	  ============================	  Contr (O A)		(dependent evars: (printing disabled) )		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 310)		subgoal 1 (ID 310) is:	 IsTrunc n.+1 (O A)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 218;
            data = "";
            responses[i]=data;
          

            i = 219;
            data = "";
            responses[i]=data;
          

            i = 220;
            data = "";
            responses[i]=data;
          

            i = 221;
            data = "";
            responses[i]=data;
          

            i = 222;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 310)	  	  H : Funext	  O : Modality	  H0 : Lex O	  n : trunc_index	  IHn : forall A : Type, IsTrunc n A -> IsTrunc n (O A)	  A : Type	  H1 : IsTrunc n.+1 A	  ============================	  IsTrunc n.+1 (O A)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 578)	  	  H : Funext	  O : Modality	  H0 : Lex O	  n : trunc_index	  IHn : forall A : Type, IsTrunc n A -> IsTrunc n (O A)	  A : Type	  H1 : IsTrunc n.+1 A	  x : A	  ============================	  forall y : O A, IsTrunc n (to O A x = y)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 223;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 663)	  	  H : Funext	  O : Modality	  H0 : Lex O	  n : trunc_index	  IHn : forall A : Type, IsTrunc n A -> IsTrunc n (O A)	  A : Type	  H1 : IsTrunc n.+1 A	  x, y : A	  ============================	  IsTrunc n (to O A x = to O A y)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 224;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 225;
            data = "<infomsg>istrunc_O_lex is defined</infomsg>	";
            responses[i]=data;
          

            i = 226;
            data = "<infomsg>Module Lex_Modalities_Theory is defined</infomsg>	";
            responses[i]=data;
          

            i = 227;
            data = "";
            responses[i]=data;
          

            i = 228;
            data = "";
            responses[i]=data;
          

            i = 229;
            data = "";
            responses[i]=data;
          

            i = 230;
            data = "";
            responses[i]=data;
          

            i = 231;
            data = "";
            responses[i]=data;
          

            i = 232;
            data = "";
            responses[i]=data;
          

            i = 233;
            data = "";
            responses[i]=data;
          

            i = 234;
            data = "";
            responses[i]=data;
          

            i = 235;
            data = "";
            responses[i]=data;
          

            i = 236;
            data = "<infomsg>Interactive Module Type Preserves_Fibers started</infomsg>	";
            responses[i]=data;
          

            i = 237;
            data = "";
            responses[i]=data;
          

            i = 238;
            data = "<infomsg>Module Os_Theory is defined</infomsg>	";
            responses[i]=data;
          

            i = 239;
            data = "<infomsg>isequiv_O_functor_hfiber is declared</infomsg>	";
            responses[i]=data;
          

            i = 240;
            data = "<infomsg>Module Type Preserves_Fibers is defined</infomsg>	";
            responses[i]=data;
          

            i = 241;
            data = "<infomsg>Interactive Module Lex_Reflective_Subuniverses started</infomsg>	";
            responses[i]=data;
          

            i = 242;
            data = "";
            responses[i]=data;
          

            i = 243;
            data = "1 subgoal, subgoal 1 (ID 8)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  ============================	  In O {x : A & B x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 244;
            data = "1 subgoal, subgoal 1 (ID 8)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  ============================	  In O {x : A & B x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 245;
            data = "1 subgoal, subgoal 1 (ID 17)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  ============================	  In O {x : A & B x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 246;
            data = "2 subgoals, subgoal 1 (ID 24)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  ============================	  forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1		subgoal 2 (ID 92) is:	 In O {x : A & B x}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 247;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 24)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  ============================	  forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1		(dependent evars: (printing disabled) )		<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal, subgoal 1 (ID 92)		subgoal 1 (ID 92) is:	 In O {x : A & B x}	(dependent evars: (printing disabled) )		1 subgoal, subgoal 1 (ID 92)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  ============================	  In O {x : A & B x}		(dependent evars: (printing disabled) )		1 subgoal, subgoal 1 (ID 101)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  ============================	  IsEquiv (to O {x : A & B x})		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 248;
            data = "1 subgoal, subgoal 1 (ID 105)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  Contr {a : {x0 : A & B x0} & to O {x0 : A & B x0} a = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 249;
            data = "1 subgoal, subgoal 1 (ID 433)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  Contr (hfiber (hfiber_compose_map (to O {x0 : A & B x0}) g x) (x; 1))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 250;
            data = "1 subgoal, subgoal 1 (ID 436)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  IsEquiv (hfiber_compose_map (to O {x0 : A & B x0}) g x)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 251;
            data = "1 subgoal, subgoal 1 (ID 437)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  IsEquiv	    (fun	       x0 : hfiber (fun x0 : {x0 : A & B x0} => g (to O {x1 : A & B x1} x0))	              (g x) => (to O {x1 : A & B x1} x0.1; x0.2))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 252;
            data = "2 subgoals, subgoal 1 (ID 442)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  hfiber pr1 (g x) <~> hfiber g (g x)		subgoal 2 (ID 455) is:	 IsEquiv	   (fun	      x0 : hfiber (fun x0 : {x0 : A & B x0} => g (to O {x1 : A & B x1} x0))	             (g x) => (to O {x1 : A & B x1} x0.1; x0.2))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 253;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 442)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  hfiber pr1 (g x) <~> hfiber g (g x)		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 653)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  O (hfiber pr1 (g x)) <~> hfiber g (g x)		subgoal 2 (ID 654) is:	 In O (hfiber pr1 (g x))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 254;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 653)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  O (hfiber pr1 (g x)) <~> hfiber g (g x)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 664)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  hfiber (O_functor O pr1) (to O A (g x)) <~> hfiber g (g x)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 255;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 665)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  {x0 : O {x : _ & B x} & O_functor O pr1 x0 = to O A (g x)} <~>	  {x0 : O {x0 : A & B x0} & g x0 = g x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 256;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 672)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  forall a : O {x : _ & B x},	  O_functor O pr1 a = to O A (g x) <~> g (1%equiv a) = g x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 257;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 674)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  y : O {x : _ & B x}	  ============================	  O_functor O pr1 y = to O A (g x) <~> g y = g x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 258;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 696)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  y : O {x : _ & B x}	  ============================	  (to O A)^-1 (O_functor O pr1 y) = g x <~> g y = g x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 259;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 700)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  y : O {x : _ & B x}	  ============================	  g y = (to O A)^-1 (O_functor O pr1 y)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 260;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 705)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  y : O {x : _ & B x}	  ============================	  to O A (g y) = O_functor O pr1 y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 261;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 706)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  y : O {x : _ & B x}	  ============================	  to O A (O_rec pr1 y) = O_rec (fun x0 : {x : _ & B x} => to O A x0.1) y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 262;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 720)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  q : B a	  ============================	  to O A (O_rec pr1 (to O {x : _ & B x} (a; q))) =	  O_rec	    (fun x0 : {x : _ & B x} => to O A (let (proj1_sig, _) := x0 in proj1_sig))	    (to O {x : _ & B x} (a; q))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 263;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 735)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  q : B a	  ============================	  to O A (O_rec pr1 (to O {x : _ & B x} (a; q))) = to O A a		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 264;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals, subgoal 1 (ID 654)		subgoal 1 (ID 654) is:	 In O (hfiber pr1 (g x))	subgoal 2 (ID 455) is:	 IsEquiv	   (fun	      x0 : hfiber (fun x0 : {x0 : A & B x0} => g (to O {x1 : A & B x1} x0))	             (g x) => (to O {x1 : A & B x1} x0.1; x0.2))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 265;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 654)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  ============================	  In O (hfiber pr1 (g x))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 266;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal, subgoal 1 (ID 455)		subgoal 1 (ID 455) is:	 IsEquiv	   (fun	      x0 : hfiber (fun x0 : {x0 : A & B x0} => g (to O {x1 : A & B x1} x0))	             (g x) => (to O {x1 : A & B x1} x0.1; x0.2))	(dependent evars: (printing disabled) )		1 subgoal, subgoal 1 (ID 455)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  h := equiv_functor_sigma' 1	         (fun y : O {x : _ & B x} =>	          equiv_concat_l	            (moveL_equiv_V (O_functor O pr1 y) (g y)	               (O_indpaths (fun x : O {x : _ & B x} => to O A (O_rec pr1 x))	                  (O_rec (fun x : {x : _ & B x} => to O A x.1))	                  (fun x0 : {x : _ & B x} =>	                   (fun (a : A) (q : B a) =>	                    ap (to O A) (O_rec_beta pr1 (a; q)) @	                    (O_rec_beta	                       (fun x : {x : _ & B x} =>	                        to O A (let (proj1_sig, _) := x in proj1_sig)) 	                       (a; q))^) (let (proj1_sig, _) := x0 in proj1_sig)	                     (let (proj1_sig, proj2_sig) as s return (B s.1) := x0 in	                      proj2_sig)) y)) (g x)	          oE equiv_moveR_equiv_V (O_functor O pr1 y) (g x))	       oE {|	          equiv_fun := O_functor_hfiber O pr1 (g x);	          equiv_isequiv := isequiv_O_functor_hfiber O pr1 (g x) |}	       oE equiv_to_O O (hfiber pr1 (g x))	    : hfiber pr1 (g x) <~> hfiber g (g x)	  ============================	  IsEquiv	    (fun	       x0 : hfiber (fun x0 : {x0 : A & B x0} => g (to O {x1 : A & B x1} x0))	              (g x) => (to O {x1 : A & B x1} x0.1; x0.2))		(dependent evars: (printing disabled) )		1 subgoal, subgoal 1 (ID 780)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  h := equiv_functor_sigma' 1	         (fun y : O {x : _ & B x} =>	          equiv_concat_l	            (moveL_equiv_V (O_functor O pr1 y) (g y)	               (O_indpaths (fun x : O {x : _ & B x} => to O A (O_rec pr1 x))	                  (O_rec (fun x : {x : _ & B x} => to O A x.1))	                  (fun x0 : {x : _ & B x} =>	                   (fun (a : A) (q : B a) =>	                    ap (to O A) (O_rec_beta pr1 (a; q)) @	                    (O_rec_beta	                       (fun x : {x : _ & B x} =>	                        to O A (let (proj1_sig, _) := x in proj1_sig)) 	                       (a; q))^) (let (proj1_sig, _) := x0 in proj1_sig)	                     (let (proj1_sig, proj2_sig) as s return (B s.1) := x0 in	                      proj2_sig)) y)) (g x)	          oE equiv_moveR_equiv_V (O_functor O pr1 y) (g x))	       oE {|	          equiv_fun := O_functor_hfiber O pr1 (g x);	          equiv_isequiv := isequiv_O_functor_hfiber O pr1 (g x) |}	       oE equiv_to_O O (hfiber pr1 (g x))	    : hfiber pr1 (g x) <~> hfiber g (g x)	  ============================	  h	  oE equiv_hfiber_homotopic	       (fun x0 : {x0 : A & B x0} => g (to O {x1 : A & B x1} x0))	       (fun x0 : {x0 : A & B x0} => x0.1) p (g x) ==	  (fun	     x0 : hfiber (fun x0 : {x0 : A & B x0} => g (to O {x1 : A & B x1} x0))	            (g x) => (to O {x1 : A & B x1} x0.1; x0.2))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 267;
            data = "1 subgoal, subgoal 1 (ID 791)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  h := equiv_functor_sigma' 1	         (fun y : O {x : _ & B x} =>	          equiv_concat_l	            (moveL_equiv_V (O_functor O pr1 y) (g y)	               (O_indpaths (fun x : O {x : _ & B x} => to O A (O_rec pr1 x))	                  (O_rec (fun x : {x : _ & B x} => to O A x.1))	                  (fun x0 : {x : _ & B x} =>	                   (fun (a : A) (q : B a) =>	                    ap (to O A) (O_rec_beta pr1 (a; q)) @	                    (O_rec_beta	                       (fun x : {x : _ & B x} =>	                        to O A (let (proj1_sig, _) := x in proj1_sig)) 	                       (a; q))^) (let (proj1_sig, _) := x0 in proj1_sig)	                     (let (proj1_sig, proj2_sig) as s return (B s.1) := x0 in	                      proj2_sig)) y)) (g x)	          oE equiv_moveR_equiv_V (O_functor O pr1 y) (g x))	       oE {|	          equiv_fun := O_functor_hfiber O pr1 (g x);	          equiv_isequiv := isequiv_O_functor_hfiber O pr1 (g x) |}	       oE equiv_to_O O (hfiber pr1 (g x))	    : hfiber pr1 (g x) <~> hfiber g (g x)	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  functor_sigma idmap	    (fun (a0 : O {x : _ & B x}) (x0 : O_functor O pr1 a0 = to O A (g x)) =>	     moveL_equiv_V (O_functor O pr1 a0) (g a0)	       (O_indpaths (fun x1 : O {x : _ & B x} => to O A (O_rec pr1 x1))	          (O_rec	             (fun x1 : {x : _ & B x} =>	              to O A (let (proj1_sig, _) := x1 in proj1_sig)))	          (fun x1 : {x : _ & B x} =>	           ap (to O A)	             (O_rec_beta pr1	                (let (proj1_sig, _) := x1 in proj1_sig;	                let (proj1_sig, proj2_sig) as s return (B s.1) := x1 in	                proj2_sig)) @	           (O_rec_beta	              (fun x2 : {x : _ & B x} =>	               to O A (let (proj1_sig, _) := x2 in proj1_sig))	              (let (proj1_sig, _) := x1 in proj1_sig;	              let (proj1_sig, proj2_sig) as s return (B s.1) := x1 in	              proj2_sig))^) a0) @ moveR_equiv_V (O_functor O pr1 a0) (g x) x0)	    (O_functor_hfiber O pr1 (g x)	       (to O (hfiber pr1 (g x)) ((a; b); (p (a; b))^ @ q))) =	  (to O {x0 : A & B x0} (a; b); q)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 268;
            data = "1 subgoal, subgoal 1 (ID 792)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  functor_sigma idmap	    (fun (a0 : O {x : _ & B x}) (x0 : O_functor O pr1 a0 = to O A (g x)) =>	     moveL_equiv_V (O_functor O pr1 a0) (g a0)	       (O_indpaths (fun x1 : O {x : _ & B x} => to O A (O_rec pr1 x1))	          (O_rec	             (fun x1 : {x : _ & B x} =>	              to O A (let (proj1_sig, _) := x1 in proj1_sig)))	          (fun x1 : {x : _ & B x} =>	           ap (to O A)	             (O_rec_beta pr1	                (let (proj1_sig, _) := x1 in proj1_sig;	                let (proj1_sig, proj2_sig) as s return (B s.1) := x1 in	                proj2_sig)) @	           (O_rec_beta	              (fun x2 : {x : _ & B x} =>	               to O A (let (proj1_sig, _) := x2 in proj1_sig))	              (let (proj1_sig, _) := x1 in proj1_sig;	              let (proj1_sig, proj2_sig) as s return (B s.1) := x1 in	              proj2_sig))^) a0) @ moveR_equiv_V (O_functor O pr1 a0) (g x) x0)	    (O_functor_hfiber O pr1 (g x)	       (to O (hfiber pr1 (g x)) ((a; b); (p (a; b))^ @ q))) =	  (to O {x0 : A & B x0} (a; b); q)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 269;
            data = "1 subgoal, subgoal 1 (ID 793)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  functor_sigma idmap	    (fun (a0 : O {x : _ & B x}) (x0 : O_functor O pr1 a0 = to O A (g x)) =>	     moveL_equiv_V (O_functor O pr1 a0) (g a0)	       (O_indpaths (fun x1 : O {x : _ & B x} => to O A (O_rec pr1 x1))	          (O_rec	             (fun x1 : {x : _ & B x} =>	              to O A (let (proj1_sig, _) := x1 in proj1_sig)))	          (fun x1 : {x : _ & B x} =>	           ap (to O A)	             (O_rec_beta pr1	                (let (proj1_sig, _) := x1 in proj1_sig;	                let (proj1_sig, proj2_sig) as s return (B s.1) := x1 in	                proj2_sig)) @	           (O_rec_beta	              (fun x2 : {x : _ & B x} =>	               to O A (let (proj1_sig, _) := x2 in proj1_sig))	              (let (proj1_sig, _) := x1 in proj1_sig;	              let (proj1_sig, proj2_sig) as s return (B s.1) := x1 in	              proj2_sig))^) a0) @ moveR_equiv_V (O_functor O pr1 a0) (g x) x0)	    (O_rec	       (fun X : hfiber pr1 (g x) =>	        (to O {x : _ & B x} (let (proj1_sig, _) := X in proj1_sig);	        to_O_natural O pr1 (let (proj1_sig, _) := X in proj1_sig) @	        ap (to O A)	          (let	             (proj1_sig, proj2_sig) as s	              return ((fun x0 : {x : _ & B x} => x0.1 = g x) s.1) := X in	           proj2_sig))) (to O (hfiber pr1 (g x)) ((a; b); (p (a; b))^ @ q))) =	  (to O {x0 : A & B x0} (a; b); q)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 270;
            data = "1 subgoal, subgoal 1 (ID 798)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  functor_sigma idmap	    (fun (a0 : O {x : _ & B x}) (x0 : O_functor O pr1 a0 = to O A (g x)) =>	     moveL_equiv_V (O_functor O pr1 a0) (g a0)	       (O_indpaths (fun x1 : O {x : _ & B x} => to O A (O_rec pr1 x1))	          (O_rec	             (fun x1 : {x : _ & B x} =>	              to O A (let (proj1_sig, _) := x1 in proj1_sig)))	          (fun x1 : {x : _ & B x} =>	           ap (to O A)	             (O_rec_beta pr1	                (let (proj1_sig, _) := x1 in proj1_sig;	                let (proj1_sig, proj2_sig) as s return (B s.1) := x1 in	                proj2_sig)) @	           (O_rec_beta	              (fun x2 : {x : _ & B x} =>	               to O A (let (proj1_sig, _) := x2 in proj1_sig))	              (let (proj1_sig, _) := x1 in proj1_sig;	              let (proj1_sig, proj2_sig) as s return (B s.1) := x1 in	              proj2_sig))^) a0) @ moveR_equiv_V (O_functor O pr1 a0) (g x) x0)	    (to O {x : _ & B x} (a; b);	    to_O_natural O pr1 (a; b) @ ap (to O A) ((p (a; b))^ @ q)) =	  (to O {x0 : A & B x0} (a; b); q)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 271;
            data = "1 subgoal, subgoal 1 (ID 804)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  (to O {x : _ & B x} (a; b);	  moveL_equiv_V (O_functor O pr1 (to O {x : _ & B x} (a; b)))	    (g (to O {x : _ & B x} (a; b)))	    (O_indpaths (fun x0 : O {x : _ & B x} => to O A (O_rec pr1 x0))	       (O_rec	          (fun x0 : {x : _ & B x} =>	           to O A (let (proj1_sig, _) := x0 in proj1_sig)))	       (fun x0 : {x : _ & B x} =>	        ap (to O A)	          (O_rec_beta pr1	             (let (proj1_sig, _) := x0 in proj1_sig;	             let (proj1_sig, proj2_sig) as s return (B s.1) := x0 in	             proj2_sig)) @	        (O_rec_beta	           (fun x1 : {x : _ & B x} =>	            to O A (let (proj1_sig, _) := x1 in proj1_sig))	           (let (proj1_sig, _) := x0 in proj1_sig;	           let (proj1_sig, proj2_sig) as s return (B s.1) := x0 in proj2_sig))^)	       (to O {x : _ & B x} (a; b))) @	  moveR_equiv_V (O_functor O pr1 (to O {x : _ & B x} (a; b))) 	    (g x) (to_O_natural O pr1 (a; b) @ ap (to O A) ((p (a; b))^ @ q))) =	  (to O {x0 : A & B x0} (a; b); q)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 272;
            data = "1 subgoal, subgoal 1 (ID 814)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  transport (fun x0 : O {x0 : A & B x0} => g x0 = g x) 1	    (moveL_equiv_V (O_functor O pr1 (to O {x : _ & B x} (a; b)))	       (g (to O {x : _ & B x} (a; b)))	       (O_indpaths (fun x0 : O {x : _ & B x} => to O A (O_rec pr1 x0))	          (O_rec	             (fun x0 : {x : _ & B x} =>	              to O A (let (proj1_sig, _) := x0 in proj1_sig)))	          (fun x0 : {x : _ & B x} =>	           ap (to O A)	             (O_rec_beta pr1	                (let (proj1_sig, _) := x0 in proj1_sig;	                let (proj1_sig, proj2_sig) as s return (B s.1) := x0 in	                proj2_sig)) @	           (O_rec_beta	              (fun x1 : {x : _ & B x} =>	               to O A (let (proj1_sig, _) := x1 in proj1_sig))	              (let (proj1_sig, _) := x0 in proj1_sig;	              let (proj1_sig, proj2_sig) as s return (B s.1) := x0 in	              proj2_sig))^) (to O {x : _ & B x} (a; b))) @	     moveR_equiv_V (O_functor O pr1 (to O {x : _ & B x} (a; b))) 	       (g x) (to_O_natural O pr1 (a; b) @ ap (to O A) ((p (a; b))^ @ q))) = q		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 273;
            data = "1 subgoal, subgoal 1 (ID 824)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  moveL_equiv_V (O_functor O pr1 (to O {x : _ & B x} (a; b)))	    (g (to O {x : _ & B x} (a; b)))	    (ap (to O A) (O_rec_beta pr1 (a; b)) @	     (O_rec_beta	        (fun x0 : {x : _ & B x} =>	         to O A (let (proj1_sig, _) := x0 in proj1_sig)) 	        (a; b))^) @	  moveR_equiv_V (O_functor O pr1 (to O {x : _ & B x} (a; b))) 	    (g x) (to_O_natural O pr1 (a; b) @ ap (to O A) ((p (a; b))^ @ q)) = q		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 274;
            data = "1 subgoal, subgoal 1 (ID 825)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  ((eissect (to O A) (g (to O {x : _ & B x} (a; b))))^ @	   ap (to O A)^-1	     (ap (to O A) (O_rec_beta pr1 (a; b)) @	      (O_rec_beta	         (fun x0 : {x : _ & B x} =>	          to O A (let (proj1_sig, _) := x0 in proj1_sig)) 	         (a; b))^)) @	  (ap (to O A)^-1 (to_O_natural O pr1 (a; b) @ ap (to O A) ((p (a; b))^ @ q)) @	   eissect (to O A) (g x)) = q		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 275;
            data = "";
            responses[i]=data;
          

            i = 276;
            data = "1 subgoal, subgoal 1 (ID 830)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  (eissect (to O A) (g (to O {x : _ & B x} (a; b))))^	  @' ap (to O A)^-1	       (ap (to O A) (O_rec_beta pr1 (a; b))	        @' (O_rec_beta	              (fun x0 : {x : _ & B x} =>	               to O A (let (proj1_sig, _) := x0 in proj1_sig)) 	              (a; b))^)	  @' (ap (to O A)^-1	        (to_O_natural O pr1 (a; b)	         @' ap (to O A) ((p (a; b))^	                         @' q))	      @' eissect (to O A) (g x)) = q		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 277;
            data = "1 subgoal, subgoal 1 (ID 889)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  (eissect (to O A) (g (to O {x : _ & B x} (a; b))))^	  @' ap (to O A)^-1 (ap (to O A) (O_rec_beta pr1 (a; b)))	  @' (ap (to O A)^-1	        (O_rec_beta	           (fun x0 : {x : _ & B x} =>	            to O A (let (proj1_sig, _) := x0 in proj1_sig)) 	           (a; b)))^	  @' ap (to O A)^-1 (to_O_natural O pr1 (a; b))	  @' (ap (to O A)^-1 (ap (to O A) (p (a; b))))^	  @' ap (to O A)^-1 (ap (to O A) q)	  @' eissect (to O A) (g x) = q		(dependent evars: (printing disabled) )		1 subgoal, subgoal 1 (ID 894)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  (eissect (to O A) (g (to O {x : _ & B x} (a; b))))^	  @' ap (to O A)^-1 (ap (to O A) (O_rec_beta pr1 (a; b)))	  @' (ap (to O A)^-1	        (O_rec_beta	           (fun x0 : {x : _ & B x} =>	            to O A (let (proj1_sig, _) := x0 in proj1_sig)) 	           (a; b)))^	  @' ap (to O A)^-1	       (O_rec_beta (fun x0 : {x : _ & B x} => to O A x0.1) (a; b))	  @' (ap (to O A)^-1 (ap (to O A) (p (a; b))))^	  @' ap (to O A)^-1 (ap (to O A) q)	  @' eissect (to O A) (g x) = q		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 278;
            data = "1 subgoal, subgoal 1 (ID 899)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  p := fun x : {x : A & B x} => O_rec_beta pr1 x	    : forall x : {x : A & B x}, g (to O {x0 : A & B x0} x) = x.1	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  (eissect (to O A) (g (to O {x : _ & B x} (a; b))))^	  @' ap (to O A)^-1 (ap (to O A) (O_rec_beta pr1 (a; b)))	  @' (ap (to O A)^-1 (ap (to O A) (p (a; b))))^	  @' ap (to O A)^-1 (ap (to O A) q)	  @' eissect (to O A) (g x) = q		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 279;
            data = "1 subgoal, subgoal 1 (ID 909)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  (eissect (to O A) (g (to O {x : _ & B x} (a; b))))^	  @' ap (to O A)^-1 (ap (to O A) (O_rec_beta pr1 (a; b)))	  @' (ap (to O A)^-1	        (ap (to O A) ((fun x0 : {x0 : A & B x0} => O_rec_beta pr1 x0) (a; b))))^	  @' ap (to O A)^-1 (ap (to O A) q)	  @' eissect (to O A) (g x) = q		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 280;
            data = "1 subgoal, subgoal 1 (ID 914)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  (eissect (to O A) (g (to O {x : _ & B x} (a; b))))^	  @' ap (to O A)^-1 (ap (to O A) q)	  @' eissect (to O A) (g x) = q		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 281;
            data = "1 subgoal, subgoal 1 (ID 934)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  ap (to O A)^-1 (ap (to O A) q)	  @' eissect (to O A) (g x) =	  eissect (to O A) (g (to O {x : _ & B x} (a; b)))	  @' q		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 282;
            data = "1 subgoal, subgoal 1 (ID 943)	  	  O : ReflectiveSubuniverse	  A : Type	  B : A -> Type	  A_inO : In O A	  B_inO : forall a : A, In O (B a)	  g := (O_rec pr1 : O {x : A & B x} -> A) : O {x : A & B x} -> A	  x : O {x : A & B x}	  a : A	  b : B a	  q : g (to O {x : A & B x} (a; b)) = g x	  ============================	  ap (fun x0 : A => (to O A)^-1 (to O A x0)) q	  @' eissect (to O A) (g x) =	  eissect (to O A) (g (to O {x : _ & B x} (a; b)))	  @' q		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 283;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 284;
            data = "";
            responses[i]=data;
          

            i = 285;
            data = "<infomsg>inO_sigma is defined</infomsg>	";
            responses[i]=data;
          

            i = 286;
            data = "<infomsg>Module Lex_Reflective_Subuniverses is defined</infomsg>	";
            responses[i]=data;
          

            i = 287;
            data = "";
            responses[i]=data;
          

            i = 288;
            data = "";
            responses[i]=data;
          

            i = 289;
            data = "";
            responses[i]=data;
          

            i = 290;
            data = "";
            responses[i]=data;
          

            i = 291;
            data = "";
            responses[i]=data;
          

            i = 292;
            data = "";
            responses[i]=data;
          

            i = 293;
            data = "";
            responses[i]=data;
          

            i = 294;
            data = "";
            responses[i]=data;
          

            i = 295;
            data = "";
            responses[i]=data;
          

            i = 296;
            data = "<infomsg>Interactive Module Accessible_Lex_Modalities_Theory started	</infomsg>	";
            responses[i]=data;
          

            i = 297;
            data = "<infomsg>Module Acc_Theory is defined</infomsg>	";
            responses[i]=data;
          

            i = 298;
            data = "<infomsg>Module Lex_Theory is defined</infomsg>	<infomsg>	Ambiguous paths:	[modality_to_reflective_subuniverse; O_reflector] : Modality >-> Funclass	</infomsg>	";
            responses[i]=data;
          

            i = 299;
            data = "";
            responses[i]=data;
          

            i = 300;
            data = "";
            responses[i]=data;
          

            i = 301;
            data = "";
            responses[i]=data;
          

            i = 302;
            data = "";
            responses[i]=data;
          

            i = 303;
            data = "";
            responses[i]=data;
          

            i = 304;
            data = "";
            responses[i]=data;
          

            i = 305;
            data = "";
            responses[i]=data;
          

            i = 306;
            data = "";
            responses[i]=data;
          

            i = 307;
            data = "";
            responses[i]=data;
          

            i = 308;
            data = "";
            responses[i]=data;
          

            i = 309;
            data = "";
            responses[i]=data;
          

            i = 310;
            data = "";
            responses[i]=data;
          

            i = 311;
            data = "";
            responses[i]=data;
          

            i = 312;
            data = "";
            responses[i]=data;
          

            i = 313;
            data = "";
            responses[i]=data;
          

            i = 314;
            data = "";
            responses[i]=data;
          

            i = 315;
            data = "";
            responses[i]=data;
          

            i = 316;
            data = "";
            responses[i]=data;
          

            i = 317;
            data = "";
            responses[i]=data;
          

            i = 318;
            data = "";
            responses[i]=data;
          

            i = 319;
            data = "";
            responses[i]=data;
          

            i = 320;
            data = "";
            responses[i]=data;
          

            i = 321;
            data = "";
            responses[i]=data;
          

            i = 322;
            data = "";
            responses[i]=data;
          

            i = 323;
            data = "";
            responses[i]=data;
          

            i = 324;
            data = "";
            responses[i]=data;
          

            i = 325;
            data = "";
            responses[i]=data;
          

            i = 326;
            data = "";
            responses[i]=data;
          

            i = 327;
            data = "";
            responses[i]=data;
          

            i = 328;
            data = "";
            responses[i]=data;
          

            i = 329;
            data = "";
            responses[i]=data;
          

            i = 330;
            data = "";
            responses[i]=data;
          

            i = 331;
            data = "";
            responses[i]=data;
          

            i = 332;
            data = "";
            responses[i]=data;
          

            i = 333;
            data = "";
            responses[i]=data;
          

            i = 334;
            data = "";
            responses[i]=data;
          

            i = 335;
            data = "";
            responses[i]=data;
          

            i = 336;
            data = "";
            responses[i]=data;
          

            i = 337;
            data = "";
            responses[i]=data;
          

            i = 338;
            data = "";
            responses[i]=data;
          

            i = 339;
            data = "";
            responses[i]=data;
          

            i = 340;
            data = "";
            responses[i]=data;
          

            i = 341;
            data = "";
            responses[i]=data;
          

            i = 342;
            data = "";
            responses[i]=data;
          

            i = 343;
            data = "";
            responses[i]=data;
          

            i = 344;
            data = "";
            responses[i]=data;
          

            i = 345;
            data = "";
            responses[i]=data;
          

            i = 346;
            data = "";
            responses[i]=data;
          

            i = 347;
            data = "";
            responses[i]=data;
          

            i = 348;
            data = "";
            responses[i]=data;
          

            i = 349;
            data = "";
            responses[i]=data;
          

            i = 350;
            data = "";
            responses[i]=data;
          

            i = 351;
            data = "";
            responses[i]=data;
          

            i = 352;
            data = "";
            responses[i]=data;
          

            i = 353;
            data = "";
            responses[i]=data;
          

            i = 354;
            data = "";
            responses[i]=data;
          

            i = 355;
            data = "";
            responses[i]=data;
          

            i = 356;
            data = "";
            responses[i]=data;
          

            i = 357;
            data = "";
            responses[i]=data;
          

            i = 358;
            data = "";
            responses[i]=data;
          

            i = 359;
            data = "";
            responses[i]=data;
          

            i = 360;
            data = "";
            responses[i]=data;
          

            i = 361;
            data = "";
            responses[i]=data;
          

            i = 362;
            data = "";
            responses[i]=data;
          

            i = 363;
            data = "";
            responses[i]=data;
          

            i = 364;
            data = "";
            responses[i]=data;
          

            i = 365;
            data = "";
            responses[i]=data;
          

            i = 366;
            data = "";
            responses[i]=data;
          

            i = 367;
            data = "";
            responses[i]=data;
          

            i = 368;
            data = "";
            responses[i]=data;
          

            i = 369;
            data = "";
            responses[i]=data;
          

            i = 370;
            data = "";
            responses[i]=data;
          

            i = 371;
            data = "";
            responses[i]=data;
          

            i = 372;
            data = "";
            responses[i]=data;
          

            i = 373;
            data = "";
            responses[i]=data;
          

            i = 374;
            data = "";
            responses[i]=data;
          

            i = 375;
            data = "";
            responses[i]=data;
          

            i = 376;
            data = "";
            responses[i]=data;
          

            i = 377;
            data = "";
            responses[i]=data;
          

            i = 378;
            data = "";
            responses[i]=data;
          

            i = 379;
            data = "<infomsg>isconnected_acc_to_lex is defined</infomsg>	";
            responses[i]=data;
          

            i = 380;
            data = "";
            responses[i]=data;
          

            i = 381;
            data = "";
            responses[i]=data;
          

            i = 382;
            data = "";
            responses[i]=data;
          

            i = 383;
            data = "";
            responses[i]=data;
          

            i = 384;
            data = "";
            responses[i]=data;
          

            i = 385;
            data = "1 subgoal, subgoal 1 (ID 4)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  ============================	  In O (Type_ O)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 386;
            data = "1 subgoal, subgoal 1 (ID 18)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  ============================	  ExtendableAlong n (fun _ : (acc_gen O) i => tt) (unit_name (Type_ O))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 387;
            data = "2 subgoals, subgoal 1 (ID 27)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  ============================	  forall g : (acc_gen O) i -> Type_ O,	  ExtensionAlong (fun _ : (acc_gen O) i => tt) (unit_name (Type_ O)) g		subgoal 2 (ID 28) is:	 forall h k : Unit -> Type_ O,	 ExtendableAlong n (fun _ : (acc_gen O) i => tt) (fun b : Unit => h b = k b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 388;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 27)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  ============================	  forall g : (acc_gen O) i -> Type_ O,	  ExtensionAlong (fun _ : (acc_gen O) i => tt) (unit_name (Type_ O)) g		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 29)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  P : (acc_gen O) i -> Type_ O	  ============================	  ExtensionAlong (fun _ : (acc_gen O) i => tt) (unit_name (Type_ O)) P		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 389;
            data = "";
            responses[i]=data;
          

            i = 390;
            data = "";
            responses[i]=data;
          

            i = 391;
            data = "";
            responses[i]=data;
          

            i = 392;
            data = "";
            responses[i]=data;
          

            i = 393;
            data = "";
            responses[i]=data;
          

            i = 394;
            data = "";
            responses[i]=data;
          

            i = 395;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 39)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  P : (acc_gen O) i -> Type_ O	  u : Unit	  ============================	  In O (O {a : (acc_gen O) i & P a})		subgoal 2 (ID 40) is:	 forall x : (acc_gen O) i,	 (O {a : (acc_gen O) i & P a}; ?Goal0@{u:=tt}) = P x	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 396;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 40)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  P : (acc_gen O) i -> Type_ O	  ============================	  forall x : (acc_gen O) i,	  (O {a : (acc_gen O) i & P a}; O_inO {a : (acc_gen O) i & P a}) = P x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 397;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 83)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  P : (acc_gen O) i -> Type_ O	  x : (acc_gen O) i	  ============================	  (P x).1 = O {a : (acc_gen O) i & P a}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 398;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 3518)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  P : (acc_gen O) i -> Type_ O	  x : (acc_gen O) i	  ============================	  IsEquiv (fun p : P x => to O {a : (acc_gen O) i & P a} (x; p))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 399;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 3522)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  P : (acc_gen O) i -> Type_ O	  ============================	  IsEquiv	    (functor_sigma idmap	       (fun (a : (acc_gen O) i) (p : P a) =>	        to O {a0 : (acc_gen O) i & P a0} (a; p)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 400;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 106949)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  P : (acc_gen O) i -> Type_ O	  ============================	  IsEquiv (pullback_corec (fun w : {a : (acc_gen O) i & P a} => 1))		subgoal 2 (ID 106950) is:	 IsEquiv (fun w : Pullback (const tt) (const tt) => ((w.2).1; w.1))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 401;
            data = "";
            responses[i]=data;
          

            i = 402;
            data = "";
            responses[i]=data;
          

            i = 403;
            data = "";
            responses[i]=data;
          

            i = 404;
            data = "";
            responses[i]=data;
          

            i = 405;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 106949)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  P : (acc_gen O) i -> Type_ O	  ============================	  IsEquiv (pullback_corec (fun w : {a : (acc_gen O) i & P a} => 1))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 406;
            data = "";
            responses[i]=data;
          

            i = 407;
            data = "";
            responses[i]=data;
          

            i = 408;
            data = "";
            responses[i]=data;
          

            i = 409;
            data = "";
            responses[i]=data;
          

            i = 410;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals, subgoal 1 (ID 106950)		subgoal 1 (ID 106950) is:	 IsEquiv (fun w : Pullback (const tt) (const tt) => ((w.2).1; w.1))	subgoal 2 (ID 28) is:	 forall h k : Unit -> Type_ O,	 ExtendableAlong n (fun _ : (acc_gen O) i => tt) (fun b : Unit => h b = k b)	(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 106950)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  P : (acc_gen O) i -> Type_ O	  ============================	  IsEquiv (fun w : Pullback (const tt) (const tt) => ((w.2).1; w.1))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 411;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 28)		subgoal 1 (ID 28) is:	 forall h k : Unit -> Type_ O,	 ExtendableAlong n (fun _ : (acc_gen O) i => tt) (fun b : Unit => h b = k b)	(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 28)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  ============================	  forall h k : Unit -> Type_ O,	  ExtendableAlong n (fun _ : (acc_gen O) i => tt) (fun b : Unit => h b = k b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 108584)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  A, B : Unit -> Type_ O	  ============================	  ExtendableAlong n (fun _ : (acc_gen O) i => tt) (fun b : Unit => A b = B b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 412;
            data = "";
            responses[i]=data;
          

            i = 413;
            data = "";
            responses[i]=data;
          

            i = 414;
            data = "";
            responses[i]=data;
          

            i = 415;
            data = "";
            responses[i]=data;
          

            i = 416;
            data = "";
            responses[i]=data;
          

            i = 417;
            data = "";
            responses[i]=data;
          

            i = 418;
            data = "";
            responses[i]=data;
          

            i = 419;
            data = "";
            responses[i]=data;
          

            i = 420;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 108615)	  	  H : Univalence	  O : Modality	  H0 : Lex O	  i : ngen_indices (acc_gen O)	  n : nat	  A, B : Unit -> Type_ O	  ============================	  ExtendableAlong n (fun _ : (acc_gen O) i => tt)	    (fun b : Unit => A b <~> B b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 421;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 422;
            data = "";
            responses[i]=data;
          

            i = 423;
            data = "";
            responses[i]=data;
          

            i = 424;
            data = "";
            responses[i]=data;
          

            i = 425;
            data = "";
            responses[i]=data;
          

            i = 426;
            data = "<infomsg>inO_typeO is defined</infomsg>	";
            responses[i]=data;
          

            i = 427;
            data = "";
            responses[i]=data;
          

            i = 428;
            data = "";
            responses[i]=data;
          

            i = 429;
            data = "";
            responses[i]=data;
          

            i = 430;
            data = "";
            responses[i]=data;
          

            i = 431;
            data = "";
            responses[i]=data;
          

            i = 432;
            data = "";
            responses[i]=data;
          

            i = 433;
            data = "1 subgoal, subgoal 1 (ID 7)	  	  O : Modality	  H : In O (Type_ O)	  ============================	  Lex O		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 434;
            data = "1 subgoal, subgoal 1 (ID 7)	  	  O : Modality	  H : In O (Type_ O)	  ============================	  Lex O		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 435;
            data = "1 subgoal, subgoal 1 (ID 12)	  	  O : Modality	  H : In O (Type_ O)	  A : Type	  x, y : A	  X : IsConnected O A	  ============================	  IsConnected O (x = y)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 436;
            data = "1 subgoal, subgoal 1 (ID 13)	  	  O : Modality	  H : In O (Type_ O)	  A : Type	  x, y : A	  X : IsConnected O A	  ============================	  NullHomotopy (to O (x = y))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 437;
            data = "";
            responses[i]=data;
          

            i = 438;
            data = "";
            responses[i]=data;
          

            i = 439;
            data = "";
            responses[i]=data;
          

            i = 440;
            data = "";
            responses[i]=data;
          

            i = 441;
            data = "";
            responses[i]=data;
          

            i = 442;
            data = "";
            responses[i]=data;
          

            i = 443;
            data = "";
            responses[i]=data;
          

            i = 444;
            data = "";
            responses[i]=data;
          

            i = 445;
            data = "";
            responses[i]=data;
          

            i = 446;
            data = "";
            responses[i]=data;
          

            i = 447;
            data = "";
            responses[i]=data;
          

            i = 448;
            data = "";
            responses[i]=data;
          

            i = 449;
            data = "";
            responses[i]=data;
          

            i = 450;
            data = "";
            responses[i]=data;
          

            i = 451;
            data = "";
            responses[i]=data;
          

            i = 452;
            data = "";
            responses[i]=data;
          

            i = 453;
            data = "";
            responses[i]=data;
          

            i = 454;
            data = "";
            responses[i]=data;
          

            i = 455;
            data = "";
            responses[i]=data;
          

            i = 456;
            data = "";
            responses[i]=data;
          

            i = 457;
            data = "";
            responses[i]=data;
          

            i = 458;
            data = "";
            responses[i]=data;
          

            i = 459;
            data = "";
            responses[i]=data;
          

            i = 460;
            data = "";
            responses[i]=data;
          

            i = 461;
            data = "";
            responses[i]=data;
          

            i = 462;
            data = "";
            responses[i]=data;
          

            i = 463;
            data = "";
            responses[i]=data;
          

            i = 464;
            data = "";
            responses[i]=data;
          

            i = 465;
            data = "";
            responses[i]=data;
          

            i = 466;
            data = "";
            responses[i]=data;
          

            i = 467;
            data = "";
            responses[i]=data;
          

            i = 468;
            data = "";
            responses[i]=data;
          

            i = 469;
            data = "";
            responses[i]=data;
          

            i = 470;
            data = "";
            responses[i]=data;
          

            i = 471;
            data = "";
            responses[i]=data;
          

            i = 472;
            data = "";
            responses[i]=data;
          

            i = 473;
            data = "";
            responses[i]=data;
          

            i = 474;
            data = "";
            responses[i]=data;
          

            i = 475;
            data = "";
            responses[i]=data;
          

            i = 476;
            data = "";
            responses[i]=data;
          

            i = 477;
            data = "";
            responses[i]=data;
          

            i = 478;
            data = "";
            responses[i]=data;
          

            i = 479;
            data = "1 subgoal, subgoal 1 (ID 23)	  	  O : Modality	  H : In O (Type_ O)	  A : Type	  x, y : A	  X : IsConnected O A	  e := isconnected_elim O (Type_ O)	         (fun y' : A => (O (x = y'); O_inO (x = y')))	    : NullHomotopy (fun y' : A => (O (x = y'); O_inO (x = y')))	  ============================	  NullHomotopy (to O (x = y))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 480;
            data = "1 subgoal, subgoal 1 (ID 46)	  	  O : Modality	  H : In O (Type_ O)	  A : Type	  x, y : A	  X : IsConnected O A	  e := isconnected_elim O (Type_ O)	         (fun y' : A => (O (x = y'); O_inO (x = y')))	    : NullHomotopy (fun y' : A => (O (x = y'); O_inO (x = y')))	  ============================	  forall x0 : x = y,	  to O (x = y) x0 = transport idmap (e.2 x @ (e.2 y)^) ..1 (to O (x = x) 1)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 481;
            data = "1 subgoal, subgoal 1 (ID 49)	  	  O : Modality	  H : In O (Type_ O)	  A : Type	  x, y : A	  X : IsConnected O A	  e := isconnected_elim O (Type_ O)	         (fun y' : A => (O (x = y'); O_inO (x = y')))	    : NullHomotopy (fun y' : A => (O (x = y'); O_inO (x = y')))	  ============================	  to O (x = x) 1 = transport idmap (e.2 x @ (e.2 x)^) ..1 (to O (x = x) 1)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 482;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 483;
            data = "<infomsg>lex_inO_typeO is defined</infomsg>	";
            responses[i]=data;
          

            i = 484;
            data = "<infomsg>Module Accessible_Lex_Modalities_Theory is defined</infomsg>	";
            responses[i]=data;
          

            i = 485;
            data = "";
            responses[i]=data;
          

            i = 486;
            data = "";
            responses[i]=data;
          

            i = 487;
            data = "";
            responses[i]=data;
          

            i = 488;
            data = "";
            responses[i]=data;
          

            i = 489;
            data = "";
            responses[i]=data;
          

            i = 490;
            data = "";
            responses[i]=data;
          

            i = 491;
            data = "";
            responses[i]=data;
          

            i = 492;
            data = "";
            responses[i]=data;
          

            i = 493;
            data = "";
            responses[i]=data;
          

            i = 494;
            data = "";
            responses[i]=data;
          

            i = 495;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Modalities.Lex</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.EquivalenceVarieties.html#"><span class="id" title="library">EquivalenceVarieties</span></a> <a class="idref" href="HoTT.Fibrations.html#"><span class="id" title="library">Fibrations</span></a> <a class="idref" href="HoTT.Extensions.html#"><span class="id" title="library">Extensions</span></a> <a class="idref" href="HoTT.Pullback.html#"><span class="id" title="library">Pullback</span></a> <a class="idref" href="HoTT.NullHomotopy.html#"><span class="id" title="library">NullHomotopy</span></a> <a class="idref" href="HoTT.Factorization.html#"><span class="id" title="library">Factorization</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Modalities.Modality.html#"><span class="id" title="library">Modality</span></a> <a class="idref" href="HoTT.Modalities.Accessible.html#"><span class="id" title="library">Accessible</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Tactics.html#"><span class="id" title="library">HoTT.Tactics</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(10, '0_3_3');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(11, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a name="lab287"></a><h1 class="section">Lex modalities</h1>
<div class="doc" scenenumber="4"> </div>
<a name="lab288"></a><h2 class="section">Basic theory</h2>
<div class="doc" scenenumber="9"> </div>

 A lex modality is one that preserves finite limits, or equivalently pullbacks.  It turns out that a more basic and useful way to say this is that all path-spaces of connected types are connected.  Note how different this is from the behavior of, say, truncation modalities!

<div class="doc" scenenumber="11"> </div>

  This is a "large" definition, and we don't know of any small one that's equivalent to it (see &lt;https://mathoverflow.net/questions/185980/a-small-definition-of-sub--1-topoi&gt;.  However, so far we never need to apply it "at multiple universes at once".  Thus, rather than making it a module type, we can make it a typeclass and rely on ordinary universe polymorphism. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(27, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Module</span> <a name="Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a> (<span class="id" title="var">Os</span> : <a class="idref" href="HoTT.Modalities.Modality.html#Modalities"><span class="id" title="module">Modalities</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(28, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Lex_Modalities_Theory.Os_Theory"><span class="id" title="module">Os_Theory</span></a> := <a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(29, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Class</span> <a name="Lex_Modalities_Theory.Lex"><span class="id" title="record">Lex</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span>})<br>
:= <a name="Lex_Modalities_Theory.isconnected_paths"><span class="id" title="projection">isconnected_paths</span></a> : <span class="id" title="keyword"></span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>}) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">i</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a><br>
<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">i</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(30, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Global</span> <span class="id" title="var">Existing</span> <span class="id" title="keyword">Instance</span> <span class="id" title="var">isconnected_paths</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(31, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
The following numbered lemmas are all actually equivalent characterizations of lex-ness.  We prove this for some of them, but we don't make the reverse implications Instances; usually <span class="inlinecode"><a class="idref" href="HoTT.HIT.Connectedness.html#isconnected_paths"><span class="id" title="instance">isconnected_paths</span></a></span> is the easier way to prove lexness. 
<div class="doc" scenenumber="3"> </div>

 1. Every map between connected types is a connected map. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(39, '0_3_11');
      ">
<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.conn_map_lex"><span class="id" title="instance">conn_map_lex</span></a> {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br>
{<span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>}} {<span class="id" title="var">B</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">j</span>}} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>}<br>
`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>}<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(40, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(41, '0_3_11');
      "><br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_sigma"><span class="id" title="instance">isconnected_sigma</span></a> <span class="id" title="var">O</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(42, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(43, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.lex_from_conn_map_lex"><span class="id" title="definition">lex_from_conn_map_lex</span></a> {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>}<br>
(<span class="id" title="var">H</span> : <span class="id" title="keyword"></span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a><br>
<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>)<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(44, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(45, '0_3_11');
      "><br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">AC</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(46, '0_3_11');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv'"><span class="id" title="definition">isconnected_equiv'</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> (<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">x</span>) <span class="id" title="var">y</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(47, '0_3_11');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(48, '0_3_11');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_contr_sigma"><span class="id" title="definition">equiv_contr_sigma</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span>  <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">y</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(49, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(50, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
2. Connected maps are left- as well as right-cancellable. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(54, '0_3_15');
      ">
<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.cancelL_conn_map"><span class="id" title="definition">cancelL_conn_map</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br>
{<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>)<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>) <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(55, '0_3_15');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(56, '0_3_15');
      "><br>
<span class="id" title="tactic">intros</span> ? ? <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(57, '0_3_15');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Fibrations.html#hfiber_hfiber_compose_map"><span class="id" title="definition">hfiber_hfiber_compose_map</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">b</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(58, '0_3_15');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(59, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
3. Every map inverted by <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#Issue754_1.O"><span class="id" title="constructor">O</span></a></span> is <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#Issue754_1.O"><span class="id" title="constructor">O</span></a></span>-connected. 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(67, '0_3_19');
      ">
<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.isconnected_O_inverts"><span class="id" title="definition">isconnected_O_inverts</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br>
{<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_inverts"><span class="id" title="abbreviation">O_inverts</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>}<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(68, '0_3_19');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(69, '0_3_19');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelL_conn_map"><span class="id" title="definition">cancelL_conn_map</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">B</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(70, '0_3_19');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(71, '0_3_19');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
Typeclass magic! 
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(75, '0_3_23');
      ">
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(76, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
4. Connected types are closed under pullbacks.  (Closure under fibers is <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_lex"><span class="id" title="instance">conn_map_lex</span></a></span> above. 
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(82, '0_3_27');
      ">
<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.isconnected_pullback"><span class="id" title="instance">isconnected_pullback</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br>
{<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>}<br>
`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>}<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Pullback.html#Pullback"><span class="id" title="definition">Pullback</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(83, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(84, '0_3_27');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_sigma"><span class="id" title="instance">isconnected_sigma</span></a>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(85, '0_3_27');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> <span class="id" title="var">g</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>))<br>
(<a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma'"><span class="id" title="definition">equiv_functor_sigma'</span></a> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_idmap"><span class="id" title="definition">equiv_idmap</span></a> <span class="id" title="var">_</span>)<br>
(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span>  <a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>))<br>
<span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(86, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(87, '0_3_27');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
5. The reflector preserves pullbacks.  This justifies the terminology "lex". 
</div>
<div scenenumber="31" class="code">
<span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(91, '0_3_31');
      ">
<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.O_functor_pullback"><span class="id" title="definition">O_functor_pullback</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br>
{<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)<br>
: <a class="idref" href="HoTT.Pullback.html#IsPullback"><span class="id" title="definition">IsPullback</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_square"><span class="id" title="definition">O_functor_square</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Pullback.html#pullback_commsq"><span class="id" title="definition">pullback_commsq</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(92, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(93, '0_3_31');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isequiv_O_inverts"><span class="id" title="definition">isequiv_O_inverts</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(94, '0_3_31');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_inverts_conn_map"><span class="id" title="instance">O_inverts_conn_map</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(95, '0_3_31');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelR_conn_map"><span class="id" title="definition">cancelR_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Pullback.html#Pullback"><span class="id" title="definition">Pullback</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span>)) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(96, '0_3_31');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span><br>
(<a class="idref" href="HoTT.Pullback.html#functor_pullback"><span class="id" title="definition">functor_pullback</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor"><span class="id" title="definition">O_functor</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor"><span class="id" title="definition">O_functor</span></a> <span class="id" title="var">O</span> <span class="id" title="var">g</span>)<br>
(<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">B</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">C</span>)<br>
(<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <span class="id" title="var">g</span>))<br>
<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(97, '0_3_31');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
This *seems* like it ought to be the easier goal, but it turns out to involve lots of naturality wrangling.  If we ever want to make real use of this theorem, we might want to separate out this goal into an opaque lemma so we could make the main theorem transparent. 
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(101, '0_3_35');
      ">
- <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> [<span class="id" title="var">c</span> <span class="id" title="var">e</span>]];<br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Pullback.html#functor_pullback"><span class="id" title="definition">functor_pullback</span></a>, <a class="idref" href="HoTT.Types.Sigma.html#functor_sigma"><span class="id" title="definition">functor_sigma</span></a>, <a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a>;<br>
<span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(102, '0_3_35');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#path_sigma'"><span class="id" title="definition">path_sigma'</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <a class="idref" href="HoTT.Pullback.html#pullback_pr1"><span class="id" title="definition">pullback_pr1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;(</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a><span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">))</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(103, '0_3_35');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Sigma.html#transport_sigma'"><span class="id" title="definition">transport_sigma'</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(104, '0_3_35');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#path_sigma'"><span class="id" title="definition">path_sigma'</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <a class="idref" href="HoTT.Pullback.html#pullback_pr2"><span class="id" title="definition">pullback_pr2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;(</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a><span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">))</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(105, '0_3_35');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_Fl"><span class="id" title="definition">transport_paths_Fl</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(106, '0_3_35');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_Fr"><span class="id" title="definition">transport_paths_Fr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(107, '0_3_35');
      "><br>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">long_path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(108, '0_3_35');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_square"><span class="id" title="definition">O_functor_square</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(109, '0_3_35');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a>, <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_homotopy_beta"><span class="id" title="definition">O_functor_homotopy_beta</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p_pp"><span class="id" title="definition">concat_p_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(110, '0_3_35');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Pullback.html#pullback_commsq"><span class="id" title="definition">pullback_commsq</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(111, '0_3_35');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural_compose"><span class="id" title="definition">to_O_natural_compose</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_pp_p"><span class="id" title="definition">concat_pp_p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(112, '0_3_35');
      "><br>
<span class="id" title="tactic">do</span> 3 <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#whiskerL"><span class="id" title="definition">whiskerL</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(113, '0_3_35');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a>, &lt;- <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_pp"><span class="id" title="definition">inv_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(114, '0_3_35');
      "><br>
<span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_compose"><span class="id" title="definition">O_functor_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)), &lt;- <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_pp"><span class="id" title="definition">inv_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(115, '0_3_35');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#inverse2"><span class="id" title="definition">inverse2</span></a>, <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural_compose"><span class="id" title="definition">to_O_natural_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(116, '0_3_35');
      "><br>
<span class="id" title="keyword">Close</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">long_path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(117, '0_3_35');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
By contrast, this goal, which seems to contain all the mathematical content, is solved fairly easily by <span class="inlinecode"><a class="idref" href="HoTT.Pullback.html#hfiber_functor_pullback"><span class="id" title="definition">hfiber_functor_pullback</span></a></span> and typeclass magic invoking <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_pullback"><span class="id" title="instance">isconnected_pullback</span></a></span>. 
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(125, '0_3_39');
      ">
- <span class="id" title="tactic">intros</span> [<span class="id" title="var">ob</span> [<span class="id" title="var">oc</span> <span class="id" title="var">oe</span>]].</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(126, '0_3_39');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span><br>
<a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Pullback.html#hfiber_functor_pullback"><span class="id" title="definition">hfiber_functor_pullback</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(127, '0_3_39');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(128, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
6. The reflector preserves fibers.  This is a slightly simpler version of the previous. 
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(132, '0_3_43');
      ">
<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.isequiv_O_functor_hfiber"><span class="id" title="instance">isequiv_O_functor_hfiber</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br>
{<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(133, '0_3_43');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(134, '0_3_43');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isequiv_O_inverts"><span class="id" title="definition">isequiv_O_inverts</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(135, '0_3_43');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_inverts_conn_map"><span class="id" title="instance">O_inverts_conn_map</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(136, '0_3_43');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelR_conn_map"><span class="id" title="definition">cancelR_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(137, '0_3_43');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(138, '0_3_43');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span><br>
(@<a class="idref" href="HoTT.Fibrations.html#functor_hfiber"><span class="id" title="definition">functor_hfiber</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor"><span class="id" title="definition">O_functor</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>)<br>
(<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">B</span>)<br>
(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span>  <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a>) <span class="id" title="var">b</span>)<br>
<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(139, '0_3_43');
      "><br>
- <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(140, '0_3_43');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(141, '0_3_43');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Fibrations.html#functor_hfiber"><span class="id" title="definition">functor_hfiber</span></a>, <a class="idref" href="HoTT.Types.Sigma.html#functor_sigma"><span class="id" title="definition">functor_sigma</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(142, '0_3_43');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(143, '0_3_43');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#whiskerR"><span class="id" title="definition">whiskerR</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(144, '0_3_43');
      "><br>
- <span class="id" title="tactic">intros</span> [<span class="id" title="var">oa</span> <span class="id" title="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(145, '0_3_43');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span><br>
<a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Fibrations.html#hfiber_functor_hfiber"><span class="id" title="definition">hfiber_functor_hfiber</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(146, '0_3_43');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(147, '0_3_43');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.equiv_O_functor_hfiber"><span class="id" title="definition">equiv_O_functor_hfiber</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br>
{<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>)<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor"><span class="id" title="definition">O_functor</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>)<br>
:= <a class="idref" href="HoTT.Basics.Overture.html#BuildEquiv"><span class="id" title="constructor">BuildEquiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>) <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(148, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
7. Lex modalities preserve path-spaces. 
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(152, '0_3_47');
      ">
<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.O_path_cmp"><span class="id" title="definition">O_path_cmp</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) {<span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a><br>
:= <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_rec"><span class="id" title="definition">O_rec</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(153, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.isequiv_O_path_cmp"><span class="id" title="instance">isequiv_O_path_cmp</span></a> {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>} {<span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_path_cmp"><span class="id" title="definition">O_path_cmp</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(154, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(155, '0_3_47');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isequiv_conn_ino_map"><span class="id" title="definition">isequiv_conn_ino_map</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(156, '0_3_47');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelR_conn_map"><span class="id" title="definition">cancelR_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">y</span>)) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(157, '0_3_47');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span>)) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(158, '0_3_47');
      "><br>
- <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(159, '0_3_47');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(160, '0_3_47');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Fibrations.html#hfiber_ap"><span class="id" title="definition">hfiber_ap</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(161, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(162, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
8. Any modal map between connected types is an equivalence. 
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(166, '0_3_51');
      ">
<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.isequiv_ismodal_isconnected_types"><span class="id" title="instance">isequiv_ismodal_isconnected_types</span></a><br>
{<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>} {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>}<br>
`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>}<br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(167, '0_3_51');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(168, '0_3_51');
      "><br>
<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isequiv_conn_ino_map"><span class="id" title="definition">isequiv_conn_ino_map</span></a> <span class="id" title="var">O</span>); <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(169, '0_3_51');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(170, '0_3_51');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.lex_from_isequiv_ismodal_isconnected_types"><span class="id" title="definition">lex_from_isequiv_ismodal_isconnected_types</span></a><br>
{<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>}<br>
(<span class="id" title="var">H</span> : <span class="id" title="keyword"></span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <br>
<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>)<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(171, '0_3_51');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(172, '0_3_51');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.lex_from_conn_map_lex"><span class="id" title="definition">lex_from_conn_map_lex</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(173, '0_3_51');
      "><br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">AC</span> <span class="id" title="var">BC</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(174, '0_3_51');
      "><br>
<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Factorization.html#fact_factors"><span class="id" title="projection">fact_factors</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.image"><span class="id" title="definition">image</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(175, '0_3_51');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_compose"><span class="id" title="instance">conn_map_compose</span></a>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | ].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(176, '0_3_51');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_isequiv"><span class="id" title="instance">conn_map_isequiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(177, '0_3_51');
      "><br>
<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>; [ | <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(178, '0_3_51');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_conn_map_to_unit"><span class="id" title="definition">isconnected_conn_map_to_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(179, '0_3_51');
      "><br>
<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelR_conn_map"><span class="id" title="definition">cancelR_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Factorization.html#factor1"><span class="id" title="projection">factor1</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.image"><span class="id" title="definition">image</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(180, '0_3_51');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(181, '0_3_51');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
9. Any commutative square with connected maps in one direction and modal ones in the other must necessarily be a pullback. 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(185, '0_3_55');
      ">
<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.ispullback_connmap_mapino_commsq"><span class="id" title="definition">ispullback_connmap_mapino_commsq</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>} {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span>}<br>
{<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#D"><span class="id" title="variable">D</span></a>} {<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">k</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#D"><span class="id" title="variable">D</span></a>}<br>
`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a>}<br>
`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#h"><span class="id" title="variable">h</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#k"><span class="id" title="variable">k</span></a>}<br>
(<span class="id" title="var">p</span> : <a class="idref" href="HoTT.Modalities.Lex.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#h"><span class="id" title="variable">h</span></a>)<br>
: <a class="idref" href="HoTT.Pullback.html#IsPullback"><span class="id" title="definition">IsPullback</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#p"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(186, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(187, '0_3_55');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isequiv_conn_ino_map"><span class="id" title="definition">isequiv_conn_ino_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a> <span class="id" title="var">p</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(188, '0_3_55');
      "><br>
- <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelL_conn_map"><span class="id" title="definition">cancelL_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a> <span class="id" title="var">p</span>) (<span class="id" title="var">k</span><a class="idref" href="HoTT.Pullback.html#a3f59e6c9556bd7073e29064ad7219d8"><span class="id" title="notation">^*</span></a> <span class="id" title="var">g</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(189, '0_3_55');
      "><br>
- <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelL_mapinO"><span class="id" title="definition">cancelL_mapinO</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Pullback.html#equiv_pullback_symm"><span class="id" title="definition">equiv_pullback_symm</span></a> <span class="id" title="var">k</span> <span class="id" title="var">g</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(190, '0_3_55');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelL_mapinO"><span class="id" title="definition">cancelL_mapinO</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<span class="id" title="var">g</span><a class="idref" href="HoTT.Pullback.html#a3f59e6c9556bd7073e29064ad7219d8"><span class="id" title="notation">^*</span></a> <span class="id" title="var">k</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(191, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(192, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.lex_from_ispullback_connmap_mapino_commsq"><span class="id" title="definition">lex_from_ispullback_connmap_mapino_commsq</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>)<br>
(<span class="id" title="var">H</span> : <span class="id" title="keyword"></span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span>}<br>
(<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#D"><span class="id" title="variable">D</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>) (<span class="id" title="var">k</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#D"><span class="id" title="variable">D</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a><br>
<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#k"><span class="id" title="variable">k</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a><br>
<span class="id" title="keyword"></span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">p</span> : <a class="idref" href="HoTT.Modalities.Lex.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Pullback.html#IsPullback"><span class="id" title="definition">IsPullback</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#p"><span class="id" title="variable">p</span></a>)<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(193, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(194, '0_3_55');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.lex_from_isequiv_ismodal_isconnected_types"><span class="id" title="definition">lex_from_isequiv_ismodal_isconnected_types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(195, '0_3_55');
      "><br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">AC</span> <span class="id" title="var">BC</span> <span class="id" title="var">fM</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(196, '0_3_55');
      "><br>
<span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) <span class="id" title="var">f</span> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br>
(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span>  1)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(197, '0_3_55');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Pullback.html#IsPullback"><span class="id" title="definition">IsPullback</span></a>, <a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(198, '0_3_55');
      "><br>
<span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span>  <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(199, '0_3_55');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Pullback.html#Pullback"><span class="id" title="definition">Pullback</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(200, '0_3_55');
      "><br>
<span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a> <span class="id" title="var">_</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">b</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a><a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">B</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a><br>
(<a class="idref" href="HoTT.Types.Sigma.html#functor_sigma"><span class="id" title="definition">functor_sigma</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span>  <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a>))<br>
<span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(201, '0_3_55');
      "><br>
<span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_sigma_prod0"><span class="id" title="definition">equiv_sigma_prod0</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> <span class="id" title="var">B</span>)<br>
<span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(202, '0_3_55');
      "><br>
<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#equiv_isequiv"><span class="id" title="projection">equiv_isequiv</span></a> (<a class="idref" href="HoTT.Types.Prod.html#prod_unit_l"><span class="id" title="definition">prod_unit_l</span></a> <span class="id" title="var">B</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(203, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(204, '0_3_55');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
<div class="doc" scenenumber="57">
Lex modalities preserve <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a></span>-types for all <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a></span>.  This is definitely not equivalent to lex-ness, since it is true for the truncation modalities that are not lex.  But it is also not true of all modalities; e.g. the shape modality in a cohesive topos can take 0-types to <span class="inlinecode"><a class="idref" href="HoTT.HIT.Truncations.html#oo"><span class="id" title="abbreviation">oo</span></a></span>-types. 
</div>
<div scenenumber="59" class="code">
<span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(214, '0_3_59');
      ">
<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.istrunc_O_lex"><span class="id" title="instance">istrunc_O_lex</span></a> `{<a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" title="class">Funext</span></a>} {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br>
{<span class="id" title="var">n</span>} {<span class="id" title="var">A</span>} `{<a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>}<br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#n"><span class="id" title="variable">n</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(215, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(216, '0_3_59');
      "><br>
<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">A</span>; <span class="id" title="var">simple_induction</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span> <span class="id" title="var">IHn</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> ?.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(217, '0_3_59');
      "><br>
- <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(218, '0_3_59');
      "></span>
</div>
<div class="goal" id="goal0_3_59"><pre><span></span></pre></div>
<div class="doc" scenenumber="61">
Already proven for all modalities. 
</div>
<div scenenumber="63" class="code">
<span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(222, '0_3_63');
      ">
- <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_ind"><span class="id" title="definition">O_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span>  <span class="id" title="keyword"></span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <span class="id" title="var">n</span> (<a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>)) <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(223, '0_3_63');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_ind"><span class="id" title="definition">O_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span>  <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <span class="id" title="var">n</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>)) <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(224, '0_3_63');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Trunc.html#trunc_equiv"><span class="id" title="definition">trunc_equiv</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_path_cmp"><span class="id" title="definition">O_path_cmp</span></a> <span class="id" title="var">O</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(225, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(226, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(227, '0_3_63');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_63"><pre><span></span></pre></div>
<div class="doc" scenenumber="65">
<a name="lab289"></a><h2 class="section">Lex reflective subuniverses</h2>
<div class="doc" scenenumber="4"> </div>

 A reflective subuniverse that preserves fibers is in fact a modality (and hence lex). 
</div>
<div scenenumber="67" class="code">
<span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(236, '0_3_67');
      ">
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Type</span> <a name="Preserves_Fibers"><span class="id" title="module">Preserves_Fibers</span></a> (<span class="id" title="var">Os</span> : <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses"><span class="id" title="module">ReflectiveSubuniverses</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(237, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Export</span> <span class="id" title="var">Os</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(238, '0_3_67');
      "><br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Preserves_Fibers.Os_Theory"><span class="id" title="module">Os_Theory</span></a> := <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses_Theory"><span class="id" title="module">ReflectiveSubuniverses_Theory</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(239, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Parameter</span> <a name="Preserves_Fibers.isequiv_O_functor_hfiber"><span class="id" title="axiom">isequiv_O_functor_hfiber</span></a> :<br>
<span class="id" title="keyword"></span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.ReflectiveSubuniverse"><span class="id" title="axiom">ReflectiveSubuniverse</span></a>) {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
<a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Preserves_Fibers.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(240, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Lex.html#Preserves_Fibers"><span class="id" title="module">Preserves_Fibers</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(241, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Module</span> <a name="Lex_Reflective_Subuniverses"><span class="id" title="module">Lex_Reflective_Subuniverses</span></a><br>
(<span class="id" title="var">Os</span> : <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses"><span class="id" title="module">ReflectiveSubuniverses</span></a>) (<span class="id" title="var">Opf</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Preserves_Fibers"><span class="id" title="module">Preserves_Fibers</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>)<br>
&lt;: <a class="idref" href="HoTT.Modalities.Modality.html#SigmaClosed"><span class="id" title="module">SigmaClosed</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(242, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Import</span> <span class="id" title="var">Opf</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(243, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="Lex_Reflective_Subuniverses.inO_sigma"><span class="id" title="definition">inO_sigma@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">k</span>} (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.ReflectiveSubuniverse"><span class="id" title="axiom">ReflectiveSubuniverse@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span>})<br>
(<span class="id" title="var">A</span>:<span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>}) (<span class="id" title="var">B</span>:<a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <span class="id" title="var">Type@</span>{<span class="id" title="var">j</span>})<br>
(<span class="id" title="var">A_inO</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.In"><span class="id" title="class">In@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">i</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)<br>
(<span class="id" title="var">B_inO</span> : <span class="id" title="keyword"></span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os.In"><span class="id" title="class">In@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">j</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#a"><span class="id" title="variable">a</span></a>))<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Os.In"><span class="id" title="class">In@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">k</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a><a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <span class="id" title="var">x</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(244, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(245, '0_3_67');
      "><br>
<span class="id" title="tactic">pose</span> (<span class="id" title="var">g</span> := <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_rec"><span class="id" title="definition">O_rec@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">k</span> <span class="id" title="var">i</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span> <span class="id" title="var">i</span>} <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> : <span class="id" title="var">O</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">B</span> <span class="id" title="var">x</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation"></span></a> <span class="id" title="var">A</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(246, '0_3_67');
      "><br>
<span class="id" title="var">transparent</span> <span class="id" title="tactic">assert</span> (<span class="id" title="var">p</span> : (<span class="id" title="keyword"></span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <span class="id" title="var">g</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Os.to"><span class="id" title="axiom">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(247, '0_3_67');
      "><br>
{ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">subst</span> <span class="id" title="var">g</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a>. }<br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.inO_isequiv_to_O"><span class="id" title="definition">inO_isequiv_to_O@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(248, '0_3_67');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.EquivalenceVarieties.html#isequiv_fcontr"><span class="id" title="definition">isequiv_fcontr</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(249, '0_3_67');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv'"><span class="id" title="definition">contr_equiv'</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Fibrations.html#hfiber_hfiber_compose_map"><span class="id" title="definition">hfiber_hfiber_compose_map@</span></a>{<span class="id" title="var">k</span> <span class="id" title="var">k</span> <span class="id" title="var">i</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span>} <span class="id" title="var">_</span> <span class="id" title="var">g</span> <span class="id" title="var">x</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(250, '0_3_67');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.EquivalenceVarieties.html#fcontr_isequiv"><span class="id" title="definition">fcontr_isequiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(251, '0_3_67');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Fibrations.html#hfiber_compose_map"><span class="id" title="definition">hfiber_compose_map</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(252, '0_3_67');
      "><br>
<span class="id" title="var">transparent</span> <span class="id" title="tactic">assert</span> (<span class="id" title="var">h</span> : (<a class="idref" href="HoTT.Basics.Overture.html#Equiv"><span class="id" title="record">Equiv@</span></a>{<span class="id" title="var">k</span> <span class="id" title="var">k</span>} (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber@</span></a>{<span class="id" title="var">k</span> <span class="id" title="var">i</span>} (@<a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) (<span class="id" title="var">g</span> <span class="id" title="var">x</span>))<br>
(<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber@</span></a>{<span class="id" title="var">k</span> <span class="id" title="var">i</span>} <span class="id" title="var">g</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>)))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(253, '0_3_67');
      "><br>
{ <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.equiv_to_O"><span class="id" title="definition">equiv_to_O@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span>} <span class="id" title="var">O</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(254, '0_3_67');
      "><br>
- <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Basics.Overture.html#BuildEquiv"><span class="id" title="constructor">BuildEquiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br>
(<a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a> <span class="id" title="var">O</span> (@<a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) (<span class="id" title="var">g</span> <span class="id" title="var">x</span>)) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(255, '0_3_67');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(256, '0_3_67');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma'"><span class="id" title="definition">equiv_functor_sigma'</span></a> 1 <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(257, '0_3_67');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(258, '0_3_67');
      "><br>
<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Types.Paths.html#equiv_moveR_equiv_V"><span class="id" title="definition">equiv_moveR_equiv_V</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(259, '0_3_67');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Paths.html#equiv_concat_l"><span class="id" title="definition">equiv_concat_l</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(260, '0_3_67');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#moveL_equiv_V"><span class="id" title="definition">moveL_equiv_V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(261, '0_3_67');
      "><br>
<span class="id" title="tactic">unfold</span> <span class="id" title="var">g</span>, <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_functor"><span class="id" title="definition">O_functor</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(262, '0_3_67');
      "><br>
<span class="id" title="var">revert</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_indpaths"><span class="id" title="definition">O_indpaths@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">k</span> <span class="id" title="var">i</span> <span class="id" title="var">i</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span>}; <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">q</span>]; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(263, '0_3_67');
      "><br>
<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(264, '0_3_67');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>, <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(265, '0_3_67');
      "><br>
- <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Os.inO_equiv_inO"><span class="id" title="axiom">inO_equiv_inO@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">j</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span>} <span class="id" title="var">_</span><br>
(<a class="idref" href="HoTT.Fibrations.html#hfiber_fibration"><span class="id" title="definition">hfiber_fibration@</span></a>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">k</span>} (<span class="id" title="var">g</span> <span class="id" title="var">x</span>) <span class="id" title="var">B</span>)). }</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(266, '0_3_67');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_homotopic"><span class="id" title="definition">isequiv_homotopic</span></a> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Fibrations.html#equiv_hfiber_homotopic"><span class="id" title="definition">equiv_hfiber_homotopic</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">p</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>)) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(267, '0_3_67');
      "><br>
<span class="id" title="tactic">intros</span> [[<span class="id" title="var">a</span> <span class="id" title="var">b</span>] <span class="id" title="var">q</span>]; <span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(268, '0_3_67');
      "><span class="id" title="tactic">clear</span> <span class="id" title="var">h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(269, '0_3_67');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(270, '0_3_67');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(271, '0_3_67');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Types.Sigma.html#functor_sigma"><span class="id" title="definition">functor_sigma</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(272, '0_3_67');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#path_sigma'"><span class="id" title="definition">path_sigma'</span></a> <span class="id" title="var">_</span> 1 <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(273, '0_3_67');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_indpaths_beta"><span class="id" title="definition">O_indpaths_beta</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(274, '0_3_67');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Equivalences.html#moveL_equiv_V"><span class="id" title="definition">moveL_equiv_V</span></a>, <a class="idref" href="HoTT.Basics.Equivalences.html#moveR_equiv_V"><span class="id" title="definition">moveR_equiv_V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(275, '0_3_67');
      "><br>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">long_path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(276, '0_3_67');
      "><br>
<span class="id" title="keyword">Local Opaque</span> <a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a>. <span class="id" title="tactic">set</span> (<span class="id" title="var">k</span> := @<a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a>); <span class="id" title="tactic">change</span> @<a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">k</span>; <span class="id" title="tactic">subst</span> <span class="id" title="var">k</span>. <span class="id" title="tactic">rewrite</span> !<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_pp"><span class="id" title="definition">ap_pp</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p_pp"><span class="id" title="definition">concat_p_pp</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(277, '0_3_67');
      "><br>
<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(278, '0_3_67');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_pV_p"><span class="id" title="definition">concat_pV_p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(279, '0_3_67');
      "><br>
<span class="id" title="tactic">subst</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(280, '0_3_67');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_pp_V"><span class="id" title="definition">concat_pp_V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(281, '0_3_67');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_pp_p"><span class="id" title="definition">concat_pp_p</span></a>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_Vp"><span class="id" title="definition">moveR_Vp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(282, '0_3_67');
      "><br>
<span class="id" title="tactic">rewrite</span> &lt;- !(<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Os.to"><span class="id" title="axiom">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span>) <a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Os.to"><span class="id" title="axiom">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(283, '0_3_67');
      "><br>
<span class="id" title="var">rapply</span> @<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_A1p"><span class="id" title="definition">concat_A1p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(284, '0_3_67');
      "><br>
<span class="id" title="keyword">Local Transparent</span> <a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a>. <span class="id" title="keyword">Close</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">long_path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(285, '0_3_67');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(286, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Reflective_Subuniverses"><span class="id" title="module">Lex_Reflective_Subuniverses</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(287, '0_3_67');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_67"><pre><span></span></pre></div>
<div class="doc" scenenumber="69">
<a name="lab290"></a><h2 class="section">Accessible lex modalities</h2>
<div class="doc" scenenumber="4"> </div>

 We now restrict to lex modalities that are also accessible. 
</div>
<div scenenumber="71" class="code">
<span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(296, '0_3_71');
      ">
<span class="id" title="keyword">Module</span> <a name="Accessible_Lex_Modalities_Theory"><span class="id" title="module">Accessible_Lex_Modalities_Theory</span></a><br>
(<span class="id" title="var">Os</span> : <a class="idref" href="HoTT.Modalities.Modality.html#Modalities"><span class="id" title="module">Modalities</span></a>)<br>
(<span class="id" title="var">Acc</span> : <a class="idref" href="HoTT.Modalities.Accessible.html#Accessible_Modalities"><span class="id" title="module">Accessible_Modalities</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(297, '0_3_71');
      "><br>
<br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Accessible_Lex_Modalities_Theory.Acc_Theory"><span class="id" title="module">Acc_Theory</span></a> := <a class="idref" href="HoTT.Modalities.Accessible.html#Accessible_Modalities_Theory"><span class="id" title="module">Accessible_Modalities_Theory</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Acc"><span class="id" title="module">Acc</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(298, '0_3_71');
      "><br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Accessible_Lex_Modalities_Theory.Lex_Theory"><span class="id" title="module">Lex_Theory</span></a> := <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(299, '0_3_71');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_71"><pre><span></span></pre></div>
<div class="doc" scenenumber="73">
Unfortunately, another subtlety of modules bites us here.  It appears that each application of a parametrized module to arguments creates a *new* module, and Coq has no algorithm (not even syntactic identity) for considering two such modules "the same".  In particular, the applications <span class="inlinecode"><span class="id" title="keyword">Module</span></span> <span class="inlinecode"><span class="id" title="var">Os_Theory</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> <span class="inlinecode"><span class="id" title="var">Os</span></span> that occur in both <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Accessible.html#Accessible_Modalities_Theory"><span class="id" title="module">Accessible_Modalities_Theory</span></a></span> <span class="inlinecode"><span class="id" title="var">Os</span></span> <span class="inlinecode"><span class="id" title="var">Acc</span></span> and <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a></span> <span class="inlinecode"><span class="id" title="var">Os</span></span> create two *different* modules, which appear here as <span class="inlinecode"><span class="id" title="var">Acc_Theory.Os_Theory</span></span> and <span class="inlinecode"><span class="id" title="var">Lex_Theory.Os_Theory</span></span>.  Thus, for instance, we have two different definitions <span class="inlinecode"><span class="id" title="var">Acc_Theory.Os_Theory.O_ind</span></span> and <span class="inlinecode"><span class="id" title="var">Lex_Theory.Os_Theory.O_ind</span></span>, etc.

<div class="doc" scenenumber="29"> </div>

  Fortunately, since these duplicate pairs of definitions each have the same body *and are (usually) transparent*, Coq is willing to consider them identical.  Thus, this doesn't cause a great deal of trouble.  However, there are certain contexts in which this doesn't apply.  For instance, if any definition in <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> is opaque, then Coq will be unable to notice that its duplicate copies in <span class="inlinecode"><span class="id" title="var">Acc_Theory.Os_Theory</span></span> and <span class="inlinecode"><span class="id" title="var">Lex_Theory.Os_Theory</span></span> were identical, potentially causing problems.  But since we generally only make definitions opaque if we aren't going to depend on their actual value anywhere else, this is unlikely to be much of an issue.

<div class="doc" scenenumber="37"> </div>

  A more serious issue is that there are some declarations that function up to a syntactic equality that is stricter than judgmental conversion.  For instance, <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> and <span class="inlinecode"><span class="id" title="keyword">Record</span></span> definitions, like modules, always create a new object not convertible to any previously existing one.  There are no <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> or <span class="inlinecode"><span class="id" title="keyword">Record</span></span> definitions in <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span>, but there are <span class="inlinecode"><span class="id" title="keyword">Class</span></span> declarations, and these function similarly.  In particular, typeclass search is unable to use <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>s defined in <span class="inlinecode"><span class="id" title="var">Acc_Theory</span></span> to instantiate typeclasses from <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> (such as <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory.IsConnected"><span class="id" title="record">IsConnected</span></a></span>) needed by functions in <span class="inlinecode"><span class="id" title="var">Lex_Theory</span></span>, and vice versa.

<div class="doc" scenenumber="61"> </div>

  Fortunately, all the typeclasses defined in <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> are *singleton* or *definitional* classes (defined with `:= unique_field` rather than `{ field1 ; field2 ; ... }`), which means that they do not actually introduce a new record wrapper.  Thus, the <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>s from <span class="inlinecode"><span class="id" title="var">Acc_Theory</span></span> can in fact be typechecked to *belong* to the typeclasses needed by <span class="inlinecode"><span class="id" title="var">Lex_Theory</span></span>, and hence can be supplied explicitly.

<div class="doc" scenenumber="71"> </div>

  We can also do this once and for all by defining <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>s translating automatically between the two typeclasses, although unfortunately we probably can't declare such instances in both directions at once for fear of infinite loops.  Fortunately, there is not a lot in <span class="inlinecode"><span class="id" title="var">Acc_Theory</span></span>, so this direction seems likely to be the most useful. 
</div>
<div scenenumber="75" class="code">
<span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(379, '0_3_75');
      ">
<br>
<span class="id" title="keyword">Global Instance</span> <a name="Accessible_Lex_Modalities_Theory.isconnected_acc_to_lex"><span class="id" title="instance">isconnected_acc_to_lex</span></a> {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}<br>
{<span class="id" title="var">H</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.IsConnected"><span class="id" title="class">Acc_Theory.Os_Theory.IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>}<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.IsConnected"><span class="id" title="class">Lex_Theory.Os_Theory.IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a><br>
:= <span class="id" title="var">H</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(380, '0_3_75');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_75"><pre><span></span></pre></div>
<div class="doc" scenenumber="77">
Probably the most important thing about an accessible lex modality is that the universe of modal types is again modal.  Here by "the universe" we mean a universe large enough to contain the generating family; this is why we need accessibility. 
</div>
<div scenenumber="79" class="code">
<span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(384, '0_3_79');
      ">
<span class="id" title="keyword">Global Instance</span> <a name="Accessible_Lex_Modalities_Theory.inO_typeO"><span class="id" title="instance">inO_typeO</span></a> `{<a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="class">Univalence</span></a>} (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.In"><span class="id" title="class">In</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Type_"><span class="id" title="definition">Type_</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(385, '0_3_79');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(386, '0_3_79');
      "><br>
<span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Acc.inO_iff_isnull"><span class="id" title="axiom">inO_iff_isnull</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> .</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(387, '0_3_79');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; [ <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> | <span class="id" title="tactic">split</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(388, '0_3_79');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">P</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(389, '0_3_79');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_79"><pre><span></span></pre></div>
<div class="doc" scenenumber="81">
Here is the core of the proof: we must show that any family of modal types indexed by a (generating) connected type is equivalent to a constant family.  We take the constant family to be constant at the reflection of the sum of our given family <span class="inlinecode"><a class="idref" href="HoTT.Categories.DependentProduct.html#dependent_product.P"><span class="id" title="variable">P</span></a></span>. 
</div>
<div scenenumber="83" class="code">
<span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(395, '0_3_83');
      ">
<span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> <span class="id" title="var">u</span>  <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">O</span> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>) <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>; <span class="id" title="var">cbn</span> <span class="id" title="keyword">beta</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(396, '0_3_83');
      "><br>
1:<span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(397, '0_3_83');
      "><br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.path_TypeO"><span class="id" title="definition">path_TypeO</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(398, '0_3_83');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Universe.html#path_universe"><span class="id" title="definition">path_universe</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">p</span>  <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(399, '0_3_83');
      "><br>
<span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Fibrations.html#isequiv_from_functor_sigma"><span class="id" title="definition">isequiv_from_functor_sigma</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(400, '0_3_83');
      "><br>
<span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br>
(<a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a> ((<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span>:<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>  1)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>) <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a>))<br>
<span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span>  <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(401, '0_3_83');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_83"><pre><span></span></pre></div>
<div class="doc" scenenumber="85">
And here is the core of why it works: the useful lemma above about detecting pullback squares. 
</div>
<div scenenumber="87" class="code">
<span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(405, '0_3_87');
      ">
+ <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.ispullback_connmap_mapino_commsq"><span class="id" title="definition">ispullback_connmap_mapino_commsq</span></a> <span class="id" title="var">O</span><br>
((<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span>:<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>  1)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>) <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(406, '0_3_87');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_87"><pre><span></span></pre></div>
<div class="doc" scenenumber="89">
All the necessary hypotheses are found by typeclass magic! 
</div>
<div scenenumber="91" class="code">
<span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(410, '0_3_91');
      ">
+ <span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br>
(<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_compose"><span class="id" title="definition">equiv_compose</span></a><br>
(<a class="idref" href="HoTT.Types.Prod.html#equiv_prod_symm"><span class="id" title="definition">equiv_prod_symm</span></a> (<span class="id" title="var">O</span> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>)) (<a class="idref" href="HoTT.Modalities.Lex.html#Acc.acc_gen"><span class="id" title="axiom">acc_gen</span></a> <span class="id" title="var">O</span> <span class="id" title="var">i</span>))<br>
(<a class="idref" href="HoTT.Pullback.html#equiv_pullback_unit_prod"><span class="id" title="definition">equiv_pullback_unit_prod</span></a> (<span class="id" title="var">O</span> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>)) (<a class="idref" href="HoTT.Modalities.Lex.html#Acc.acc_gen"><span class="id" title="axiom">acc_gen</span></a> <span class="id" title="var">O</span> <span class="id" title="var">i</span>)))<br>
<span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Types.Sigma.html#equiv_sigma_prod0"><span class="id" title="definition">equiv_sigma_prod0</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(411, '0_3_91');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(412, '0_3_91');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_91"><pre><span></span></pre></div>
<div class="doc" scenenumber="93">
The case <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a>&gt;0</span> is actually quite easy, using univalence and the fact that modal types are closed under <span class="inlinecode"><a class="idref" href="HoTT.HIT.quotient.html#Equiv"><span class="id" title="section">Equiv</span></a></span>. 
</div>
<div scenenumber="95" class="code">
<span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(420, '0_3_95');
      ">
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Extensions.html#extendable_postcompose'"><span class="id" title="definition">extendable_postcompose'</span></a> <span class="id" title="var">n</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br>
(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span>  <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.equiv_path_TypeO"><span class="id" title="definition">equiv_path_TypeO</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">A</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>) (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">)</span></a><br>
<a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Types.Universe.html#equiv_path_universe"><span class="id" title="definition">equiv_path_universe</span></a> (<span class="id" title="var">A</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>) (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">)</span></a>)<br>
<span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(421, '0_3_95');
      "><br>
<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.extendable_conn_map_inO"><span class="id" title="definition">extendable_conn_map_inO</span></a> <span class="id" title="var">O</span> <span class="id" title="var">n</span> (@<a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Acc.acc_gen"><span class="id" title="axiom">acc_gen</span></a> <span class="id" title="var">O</span> <span class="id" title="var">i</span>) <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)<br>
(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span>  <span class="id" title="var">A</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">&lt;~&gt;</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(422, '0_3_95');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_95"><pre><span></span></pre></div>
<div class="doc" scenenumber="97">
Typeclass magic! 
</div>
<div scenenumber="99" class="code">
<span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(426, '0_3_99');
      ">
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(427, '0_3_99');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_99"><pre><span></span></pre></div>
<div class="doc" scenenumber="101">
<span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.inO_typeO"><span class="id" title="instance">inO_typeO</span></a></span> is also an equivalent characterization of lex-ness for a modality.  We will prove this, because it is less obvious, and also more useful. 
</div>
<div scenenumber="103" class="code">
<span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(433, '0_3_103');
      ">
<span class="id" title="keyword">Definition</span> <a name="Accessible_Lex_Modalities_Theory.lex_inO_typeO"><span class="id" title="definition">lex_inO_typeO</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.In"><span class="id" title="class">In</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Type_"><span class="id" title="definition">Type_</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>)}<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(434, '0_3_103');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(435, '0_3_103');
      "><br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ?.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(436, '0_3_103');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.isconnected_from_elim_to_O"><span class="id" title="definition">isconnected_from_elim_to_O</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(437, '0_3_103');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_103"><pre><span></span></pre></div>
<div class="doc" scenenumber="105">
The idea is that if <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.A"><span class="id" title="variable">A</span></a></span> is connected and <span class="inlinecode"><a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses_Theory.Type_"><span class="id" title="definition">Type_</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#Issue754_1.O"><span class="id" title="constructor">O</span></a></span> is modal, then <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Attributes.html#fully_faithful_helpers.y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode"></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#Issue754_1.O"><span class="id" title="constructor">O</span></a></span> <span class="inlinecode">(<a class="idref" href="HoTT.Categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" title="projection">x</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Attributes.html#fully_faithful_helpers.y"><span class="id" title="variable">y</span></a>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.A"><span class="id" title="variable">A</span></a></span> <span class="inlinecode"></span> <span class="inlinecode"><a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses_Theory.Type_"><span class="id" title="definition">Type_</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#Issue754_1.O"><span class="id" title="constructor">O</span></a></span> is constant.  Thus, <span class="inlinecode"><a class="idref" href="HoTT.Categories.IndiscreteCategory.html#Functors.to"><span class="id" title="definition">to</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#Issue754_1.O"><span class="id" title="constructor">O</span></a></span> <span class="inlinecode">(<a class="idref" href="HoTT.Categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" title="projection">x</span></a>=<a class="idref" href="HoTT.Categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" title="projection">x</span></a>)</span> <span class="inlinecode">1</span> can be transported around to make it contractible everywhere. 
</div>
<div scenenumber="107" class="code">
<span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(479, '0_3_107');
      ">
<span class="id" title="tactic">pose</span> (<span class="id" title="var">e</span> := <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.isconnected_elim"><span class="id" title="definition">isconnected_elim</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Type_"><span class="id" title="definition">Type_</span></a> <span class="id" title="var">O</span>)<br>
(<span class="id" title="keyword">fun</span> <span class="id" title="var">y'</span>  <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">O</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y'"><span class="id" title="variable">y'</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.O_inO"><span class="id" title="definition">O_inO</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(480, '0_3_107');
      "><br>
<span class="id" title="tactic"></span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.Types.Sigma.html#5bfcbd4197c5362e00d29233e8cbeaee"><span class="id" title="notation">(</span></a><span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a> <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a><a class="idref" href="HoTT.Types.Sigma.html#5bfcbd4197c5362e00d29233e8cbeaee"><span class="id" title="notation">)</span></a>..<a class="idref" href="HoTT.Types.Sigma.html#5bfcbd4197c5362e00d29233e8cbeaee"><span class="id" title="notation">1</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><span class="id" title="var">x</span>) 1)).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(481, '0_3_107');
      "><br>
<span class="id" title="tactic">intros</span> [].</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(482, '0_3_107');
      "><br>
<span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#transport2"><span class="id" title="definition">transport2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_pV"><span class="id" title="definition">concat_pV</span></a> (<span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a> <span class="id" title="var">x</span>))) <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(483, '0_3_107');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(484, '0_3_107');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory"><span class="id" title="module">Accessible_Lex_Modalities_Theory</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(485, '0_3_107');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_107"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>

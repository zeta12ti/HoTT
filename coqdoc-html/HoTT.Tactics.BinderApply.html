<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>HoTT.Tactics.BinderApply</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library HoTT.Tactics.BinderApply</h1>

<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab158"></a><h1 class="section">Apply a lemma under binders</h1>

</div>
<div class="code">
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="HoTT.Basics.Overture.html#"><span class="id" type="library">Basics.Overture</span></a>.<br/>
</div>

<div class="doc">
There are some cases where <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#lem"><span class="id" type="variable">lem</span></a></span> will fail, but <span class="inlinecode"><span class="id" type="tactic">intros</span>;</span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#lem"><span class="id" type="variable">lem</span></a></span> will succeed.  The tactic <span class="inlinecode"><span class="id" type="var">binder</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> is like <span class="inlinecode"><span class="id" type="tactic">intros</span>;</span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#lem"><span class="id" type="variable">lem</span></a></span>, but it cleans up after itself by <span class="inlinecode"><span class="id" type="var">revert</span></span>ing the things it introduced.  The tactic <span class="inlinecode"><span class="id" type="var">binder</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#lem"><span class="id" type="variable">lem</span></a></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> is to <span class="inlinecode"><span class="id" type="var">binder</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#lem"><span class="id" type="variable">lem</span></a></span>, as <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#lem"><span class="id" type="variable">lem</span></a></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> is to <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#lem"><span class="id" type="variable">lem</span></a></span>.  Note, however, that the implementation of <span class="inlinecode"><span class="id" type="var">binder</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#lem"><span class="id" type="variable">lem</span></a></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> is completely different and significantly more complicated. 
<div class="paragraph"> </div>

<a name="lab159"></a><h2 class="section">Evaluating tactics on terms</h2>

<div class="paragraph"> </div>

 It sometimes happens, in the course of writing a tactic, that we have some term in an Ltac variable (more precisely, we have what Ltac calls a "constr") and we would like to act on it with some tactic such as <span class="inlinecode"><span class="id" type="tactic">cbv</span></span> or <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>.  Ordinarily, such tactics only act on the current *goal*, and generally they have a version such as <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode">...</span> which acts on something in the current *context*, but neither of these is the same as acting on a term held in an Ltac variable.

<div class="paragraph"> </div>

For some tactics, such as <span class="inlinecode"><span class="id" type="tactic">cbv</span></span> and <span class="inlinecode"><span class="id" type="tactic">pattern</span></span>, we can write <span class="inlinecode"><span class="id" type="tactic">eval</span></span> <span class="inlinecode"><span class="id" type="var">TAC</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span>, where <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> is the term in question; this form *returns* the modified term so we can place it in another Ltac variable.  However, other tactics such as <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> do not support this syntax.  (There is a feature request for it at https://coq.inria.fr/bugs/show_bug.cgi?id=3677.)

<div class="paragraph"> </div>

The following tactic <span class="inlinecode"><span class="id" type="var">eval_in</span></span> <span class="inlinecode"><span class="id" type="var">TAC</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> fills this gap, allowing us to act by <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> on terms in Ltac variables.  The argument <span class="inlinecode"><span class="id" type="var">TAC</span></span> must be a tactic that takes one argument, which is an Ltac function that gets passed the name of a hypothesis to act on, such as <span class="inlinecode"><span class="id" type="keyword">ltac</span>:(<span class="id" type="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H'"><span class="id" type="variable">H'</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H'"><span class="id" type="variable">H'</span></a>)</span>.  (Unfortunately, however, <span class="inlinecode"><span class="id" type="var">eval_in</span></span> cannot be used to exactly generalize <span class="inlinecode"><span class="id" type="tactic">eval</span></span> <span class="inlinecode"><span class="id" type="tactic">pattern</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span>; see below.)

<div class="paragraph"> </div>

There is also a variant called <span class="inlinecode"><span class="id" type="var">eval_in_using</span></span>, which also accepts a second user-specified tactic and uses it to solve side-conditions generated by the first one.  We actually define <span class="inlinecode"><span class="id" type="var">eval_in</span></span> in terms of <span class="inlinecode"><span class="id" type="var">eval_in_using</span></span> by passing <span class="inlinecode"><span class="id" type="tactic">idtac</span></span> as the second tactic. 
</div>
<div class="code">
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">eval_in_using</span> <span class="id" type="var">tac_in</span> <span class="id" type="var">using_tac</span> <span class="id" type="var">H</span> :=<br/>
&nbsp;&nbsp;</div>

<div class="doc">
The syntax <span class="inlinecode">$(...)$</span> allows execution of an arbitrary tactic to supply a needed term.  By prefixing it with <span class="inlinecode"><span class="id" type="keyword">constr</span>:</span> which tells Ltac to expect a term, we obtain a pattern <span class="inlinecode"><span class="id" type="keyword">constr</span>:($(...)$)</span> which allows us to execute an arbitrary tactic in the situation of a fresh goal.   This way we avoid modifying the existing context, and we can also get our hands on a proof term corresponding to the stateful modification.  We pose <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> in the fresh context so we can play with it nicely, regardless of if it's a hypothesis or a term.  Then we run <span class="inlinecode"><span class="id" type="var">tac_in</span></span> on the hypothesis to modify it, use <span class="inlinecode"><span class="id" type="tactic">exact</span></span> to "return" the modified hypothesis, and give a nice error message if <span class="inlinecode"><span class="id" type="var">using_tac</span></span> fails to solve some side-condition. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">ret</span> := <span class="id" type="keyword">constr</span>:($(<span class="id" type="keyword">let</span> <span class="id" type="var">H'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">pose</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> <span class="id" type="var">H'</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">tac_in</span> <span class="id" type="var">H'</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" type="tactic">exact</span> <span class="id" type="var">H'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="tactic">solve</span> [ <span class="id" type="var">using_tac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="keyword">let</span> <span class="id" type="var">G</span> := <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> |- ?<span class="id" type="var">G</span> ⇒ <span class="id" type="keyword">constr</span>:(<span class="id" type="var">G</span>) <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> <span class="id" type="var">H</span> : <span class="id" type="var">_</span> |- <span class="id" type="var">_</span> ⇒ <span class="id" type="var">revert</span> <span class="id" type="var">H</span> <span class="id" type="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">G'</span> := <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> |- ?<span class="id" type="var">G</span> ⇒ <span class="id" type="keyword">constr</span>:(<span class="id" type="var">G</span>) <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">fail</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Cannot use" <span class="id" type="var">using_tac</span> "to solve side-condition goal" <span class="id" type="var">G</span> "."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Extended goal with context:" <span class="id" type="var">G'</span> ].. ])$) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;</div>

<div class="doc">
Finally, we play some games to format the return value nicely.  We want to zeta-reduce the let-in generated by <span class="inlinecode"><span class="id" type="tactic">pose</span></span>, but not any other <span class="inlinecode"><span class="id" type="keyword">let</span>-<span class="id" type="keyword">in</span></span>s; we do this by matching for it and doing the substitution manually.  Additionally, <span class="inlinecode"><span class="id" type="tactic">pose</span></span>/<span class="inlinecode"><span class="id" type="tactic">exact</span></span> also results in an extra <span class="inlinecode"><a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" type="abbreviation">idmap</span></a></span>; we remove this with <span class="inlinecode"><span class="id" type="tactic">cbv</span></span> <span class="inlinecode"><span class="id" type="keyword">beta</span></span>, which unfortunately also beta-reduces everything else.  (This is why <span class="inlinecode"><span class="id" type="var">eval_in</span></span> <span class="inlinecode"><span class="id" type="tactic">pattern</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> doesn't strictly generalize <span class="inlinecode"><span class="id" type="tactic">eval</span></span> <span class="inlinecode"><span class="id" type="tactic">pattern</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span>, since the latter doesn't beta-reduce.)  Perhaps we want to zeta-reduce everything, and not beta-reduce anything instead? 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">T</span> := <span class="id" type="var">type</span> <span class="id" type="var">of</span> <span class="id" type="var">ret</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">ret'</span> := (<span class="id" type="keyword">lazymatch</span> <span class="id" type="var">ret</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="keyword">let</span> <span class="id" type="var">x</span> := ?<span class="id" type="var">x'</span> <span class="id" type="keyword">in</span> @?<span class="id" type="var">P</span> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a> ⇒ <span class="id" type="keyword">constr</span>:(<span class="id" type="var">P</span> <span class="id" type="var">x'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">ret''</span> := (<span class="id" type="tactic">eval</span> <span class="id" type="tactic">cbv</span> <span class="id" type="keyword">beta</span> <span class="id" type="keyword">in</span> <span class="id" type="var">ret'</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">constr</span>:(<span class="id" type="var">ret''</span> : <span class="id" type="var">T</span>).<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">eval_in</span> <span class="id" type="var">tac_in</span> <span class="id" type="var">H</span> := <span class="id" type="var">eval_in_using</span> <span class="id" type="var">tac_in</span> <span class="id" type="tactic">idtac</span> <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="eval_in_example"><span class="id" type="definition">eval_in_example</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Set</span>, <a class="idref" href="HoTT.Tactics.BinderApply.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#B"><span class="id" type="variable">B</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">H</span> <span class="id" type="var">a</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x</span> := (<span class="id" type="var">eval_in</span> <span class="id" type="keyword">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">H'</span> ⇒ <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span>) <span class="id" type="var">a</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">pose</span> <span class="id" type="var">x</span> <span class="id" type="keyword">as</span> <span class="id" type="var">b</span>.<br/>
</div>

<div class="doc">
we get a <span class="inlinecode"><a class="idref" href="HoTT.categories.LaxComma.CoreParts.html#LaxCommaCategoryParts.b"><span class="id" type="projection">b</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.B"><span class="id" type="variable">B</span></a></span>  We <span class="inlinecode"><span class="id" type="keyword">Abort</span></span>, so that we don't get an extra constant floating around. 
</div>
<div class="code">
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">can_binder_apply</span> <span class="id" type="var">apply_tac</span> <span class="id" type="var">fail1_tac</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span> [ <span class="id" type="var">test</span> <span class="id" type="var">apply_tac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">test</span> (<span class="id" type="tactic">intro</span>; <span class="id" type="var">can_binder_apply</span> <span class="id" type="var">apply_tac</span> <span class="id" type="var">fail1_tac</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">fail1_tac</span> ].<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">binder_apply</span> <span class="id" type="var">apply_tac</span> <span class="id" type="var">fail1_tac</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">can_binder_apply</span> <span class="id" type="var">apply_tac</span> <span class="id" type="var">fail1_tac</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span> [ <span class="id" type="var">apply_tac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="keyword">let</span> <span class="id" type="var">H</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">binder_apply</span> <span class="id" type="var">apply_tac</span> <span class="id" type="var">fail1_tac</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">revert</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="tactic">fail</span> 1 "Cannot re-revert some introduced hypothesis" ].<br/>

<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" type="var">eval_under_binders</span></span> <span class="inlinecode"><span class="id" type="var">tac</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> is equivalent to <span class="inlinecode"><span class="id" type="var">tac</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> if <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> is not a product (lambda-abstraction), and roughly equivalent to the constr <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">eval_under_binders</span></span> <span class="inlinecode"><span class="id" type="var">tac</span></span> <span class="inlinecode">(<a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a>)</span> if <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> is a product. 
</div>
<div class="code">
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">eval_under_binders</span> <span class="id" type="var">tac</span> <span class="id" type="var">H</span> :=<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Bind a convenient name for the recursive call 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">rec_tac</span> := <span class="id" type="var">eval_under_binders</span> <span class="id" type="var">tac</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;</div>

<div class="doc">
If the hypothesis is a product (<span class="inlinecode"><span class="id" type="keyword">∀</span></span>), we want to recurse under binders; if not, we're in the base case, and we simply compute the new term.  We use <span class="inlinecode"><span class="id" type="keyword">match</span></span> rather than <span class="inlinecode"><span class="id" type="keyword">lazymatch</span></span> so that if the tactic fails to apply under all of the binders, we try again under fewer binders.  We want to try first under as many binders as possible, in case the tactic, e.g., instantiates extra binders with evars. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">type</span> <span class="id" type="var">of</span> <span class="id" type="var">H</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
Standard pattern for recursing under binders.  We zeta-expand to work around https://coq.inria.fr/bugs/show_bug.cgi?id=3248 and https://coq.inria.fr/bugs/show_bug.cgi?id=3458; we'd otherwise need globally unique name for <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a></span>.  We zeta-reduce afterwards so the user doesn't see our zeta-expansion.  We use <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a></span> in both the pattern and the returned constructor so that we preserve the given name for the binder.  
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : ?<span class="id" type="var">T</span>, @?<span class="id" type="var">P</span> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇒ <span class="id" type="keyword">let</span> <span class="id" type="var">ret</span> := <span class="id" type="keyword">constr</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> : <span class="id" type="var">T</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">Hx</span> := <span class="id" type="var">H</span> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(<span class="id" type="keyword">let</span> <span class="id" type="var">ret'</span> := <span class="id" type="var">rec_tac</span> <span class="id" type="var">Hx</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">exact</span> <span class="id" type="var">ret'</span>)$) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">ret'</span> := (<span class="id" type="tactic">eval</span> <span class="id" type="tactic">cbv</span> <span class="id" type="keyword">zeta</span> <span class="id" type="keyword">in</span> <span class="id" type="var">ret</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">constr</span>:(<span class="id" type="var">ret'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
Base case - simply return <span class="inlinecode"><span class="id" type="var">tac</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span>  
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">tac</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" type="var">make_tac_under_binders_using_in</span></span> <span class="inlinecode"><span class="id" type="var">tac</span></span> <span class="inlinecode"><span class="id" type="var">using_tac</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> uses <span class="inlinecode"><span class="id" type="var">tac</span></span> to transform a term <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span>, solving side-conditions (e.g., if <span class="inlinecode"><span class="id" type="var">tac</span></span> uses <span class="inlinecode"><span class="id" type="tactic">apply</span></span>) with <span class="inlinecode"><span class="id" type="var">using_tac</span></span>.  It returns the updated version of <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> as a constr; if <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> is a hypothesis in the context, it does not modify it.  Conceptually, <span class="inlinecode"><span class="id" type="var">make_tac_under_binders_using_in</span></span> <span class="inlinecode"><span class="id" type="var">tac</span></span> <span class="inlinecode"><span class="id" type="tactic">idtac</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> is the composition of two tactics: a <span class="inlinecode"><span class="id" type="var">transform_under_binders</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" type="keyword">constr</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="keyword">constr</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" type="keyword">constr</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="keyword">constr</span>)</span> that runs a tactic under the binders of the constr it's given, and what would be an <span class="inlinecode"><span class="id" type="tactic">eval</span></span> <span class="inlinecode"><span class="id" type="var">tac</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span>, except for the fact that, e.g., <span class="inlinecode"><span class="id" type="tactic">eval</span></span> <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> doesn't actually work because it predates tactics in terms (we use <span class="inlinecode"><span class="id" type="var">eval_in_using</span></span> <span class="inlinecode"><span class="id" type="var">tac</span></span> <span class="inlinecode"><span class="id" type="var">using_tac</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> instead).

<div class="paragraph"> </div>

    The arguments are:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">tac</span></span> - should take the name of a hypothesis, and modify that hypothesis in place.  It could, for example, be <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#lem"><span class="id" type="variable">lem</span></a></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> to do the <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> under binders.

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="var">using_tac</span></span> - used to solve any side-conditions that <span class="inlinecode"><span class="id" type="var">tac</span></span> generates.  Not strictly necessary, since <span class="inlinecode"><span class="id" type="var">tac</span></span> can always solve its own side-conditions, but it's sometimes convenient to instantiate <span class="inlinecode"><span class="id" type="var">tac</span></span> with <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#lem"><span class="id" type="variable">lem</span></a></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> or something, and solve the side-conditions with <span class="inlinecode"><span class="id" type="var">eassumption</span></span>.

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H"><span class="id" type="variable">H</span></a></span> - the name of the hypothesis to start from.

</li>
</ul>
    N.B. We do not require <span class="inlinecode"><a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" type="record">Funext</span></a></span> to use this tactic; <span class="inlinecode"><a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" type="record">Funext</span></a></span> would only required to relate the term returned by this tactic and the original term.  Note also that we only rewrite under top-level binders (e.g., under the <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a></span> in a hypothesis of type <span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a>,</span> <span class="inlinecode"><a class="idref" href="HoTT.categories.DependentProduct.html#dependent_product.P"><span class="id" type="variable">P</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a></span>, but not under the <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a></span> in a hypothesis of type <span class="inlinecode">(<span class="id" type="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Functor.Attributes.html#fully_faithful_helpers.y"><span class="id" type="variable">y</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Functor.Attributes.html#fully_faithful_helpers.y"><span class="id" type="variable">y</span></a>)</span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" type="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Functor.Attributes.html#fully_faithful_helpers.y"><span class="id" type="variable">y</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Functor.Attributes.html#fully_faithful_helpers.y"><span class="id" type="variable">y</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" type="projection">x</span></a>)</span>). 
</div>
<div class="code">
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">make_tac_under_binders_using_in</span> <span class="id" type="var">tac</span> <span class="id" type="var">using_tac</span> <span class="id" type="var">H</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">eval_under_binders</span> <span class="id" type="keyword">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">H'</span> ⇒ <span class="id" type="var">eval_in_using</span> <span class="id" type="var">tac</span> <span class="id" type="var">using_tac</span> <span class="id" type="var">H'</span>) <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">do_tac_under_binders_using_in</span> <span class="id" type="var">tac</span> <span class="id" type="var">using_tac</span> <span class="id" type="var">H</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">H'</span> := <span class="id" type="var">make_tac_under_binders_using_in</span> <span class="id" type="var">tac</span> <span class="id" type="var">using_tac</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">H''</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">pose</span> <span class="id" type="var">proof</span> <span class="id" type="var">H'</span> <span class="id" type="keyword">as</span> <span class="id" type="var">H''</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rename</span> <span class="id" type="var">H''</span> <span class="id" type="var">into</span> <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "constrbinder" "apply" <span class="id" type="keyword">constr</span>(<span class="id" type="var">lem</span>) "in" <span class="id" type="keyword">constr</span>(<span class="id" type="var">H</span>) "using" <span class="id" type="var">tactic3</span>(<span class="id" type="var">tac</span>)<br/>
&nbsp;&nbsp;:= <span class="id" type="var">make_tac_under_binders_using_in</span> <span class="id" type="keyword">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">H'</span> ⇒ <span class="id" type="tactic">apply</span> <span class="id" type="var">lem</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span>) <span class="id" type="var">tac</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Tactic Notation</span> "constrbinder" "eapply" <span class="id" type="var">open_constr</span>(<span class="id" type="var">lem</span>) "in" <span class="id" type="keyword">constr</span>(<span class="id" type="var">H</span>) "using" <span class="id" type="var">tactic3</span>(<span class="id" type="var">tac</span>)<br/>
&nbsp;&nbsp;:= <span class="id" type="var">constrbinder</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">lem</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="keyword">using</span> <span class="id" type="var">tac</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "binder" "apply" <span class="id" type="keyword">constr</span>(<span class="id" type="var">lem</span>) "in" <span class="id" type="keyword">constr</span>(<span class="id" type="var">H</span>) "using" <span class="id" type="var">tactic3</span>(<span class="id" type="var">tac</span>)<br/>
&nbsp;&nbsp;:= <span class="id" type="var">do_tac_under_binders_using_in</span> <span class="id" type="keyword">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">H'</span> ⇒ <span class="id" type="tactic">apply</span> <span class="id" type="var">lem</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span>) <span class="id" type="var">tac</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Tactic Notation</span> "binder" "eapply" <span class="id" type="var">open_constr</span>(<span class="id" type="var">lem</span>) "in" <span class="id" type="keyword">constr</span>(<span class="id" type="var">H</span>) "using" <span class="id" type="var">tactic3</span>(<span class="id" type="var">tac</span>)<br/>
&nbsp;&nbsp;:= <span class="id" type="var">binder</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">lem</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="keyword">using</span> <span class="id" type="var">tac</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "constrbinder" "apply" <span class="id" type="keyword">constr</span>(<span class="id" type="var">lem</span>) "in" <span class="id" type="keyword">constr</span>(<span class="id" type="var">H</span>) := <span class="id" type="var">constrbinder</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">lem</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="keyword">using</span> <span class="id" type="tactic">idtac</span>.<br/>
<span class="id" type="keyword">Tactic Notation</span> "constrbinder" "eapply" <span class="id" type="var">open_constr</span>(<span class="id" type="var">lem</span>) "in" <span class="id" type="keyword">constr</span>(<span class="id" type="var">H</span>) := <span class="id" type="var">constrbinder</span> <span class="id" type="tactic">eapply</span> <span class="id" type="var">lem</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="keyword">using</span> <span class="id" type="tactic">idtac</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "binder" "apply" <span class="id" type="keyword">constr</span>(<span class="id" type="var">lem</span>) := <span class="id" type="var">binder_apply</span> <span class="id" type="keyword">ltac</span>:(<span class="id" type="tactic">apply</span> <span class="id" type="var">lem</span>) <span class="id" type="keyword">ltac</span>:(<span class="id" type="tactic">fail</span> 1 "Cannot apply" <span class="id" type="var">lem</span>).<br/>
<span class="id" type="keyword">Tactic Notation</span> "binder" "eapply" <span class="id" type="var">open_constr</span>(<span class="id" type="var">lem</span>) := <span class="id" type="var">binder_apply</span> <span class="id" type="keyword">ltac</span>:(<span class="id" type="tactic">eapply</span> <span class="id" type="var">lem</span>) <span class="id" type="keyword">ltac</span>:(<span class="id" type="tactic">fail</span> 1 "Cannot eapply" <span class="id" type="var">lem</span>).<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "binder" "apply" <span class="id" type="keyword">constr</span>(<span class="id" type="var">lem</span>) "in" <span class="id" type="keyword">constr</span>(<span class="id" type="var">H</span>) := <span class="id" type="var">binder</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">lem</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="keyword">using</span> <span class="id" type="tactic">idtac</span>.<br/>
<span class="id" type="keyword">Tactic Notation</span> "binder" "eapply" <span class="id" type="var">open_constr</span>(<span class="id" type="var">lem</span>) "in" <span class="id" type="keyword">constr</span>(<span class="id" type="var">H</span>) := <span class="id" type="var">binder</span> <span class="id" type="tactic">eapply</span> <span class="id" type="var">lem</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="keyword">using</span> <span class="id" type="tactic">idtac</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="basic_goal"><span class="id" type="definition">basic_goal</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">C</span>} (<span class="id" type="var">HA</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="HoTT.Tactics.BinderApply.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.Tactics.BinderApply.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">HB</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="HoTT.Tactics.BinderApply.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.Tactics.BinderApply.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a>) : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="HoTT.Tactics.BinderApply.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.Tactics.BinderApply.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
</div>

<div class="doc">
If we try to <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="HoTT.Types.Prod.html#HB"><span class="id" type="variable">HB</span></a></span>, wanting to replace <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.C"><span class="id" type="variable">C</span></a></span> with <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.B"><span class="id" type="variable">B</span></a></span>, we get an error about being unable to unify <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.B"><span class="id" type="variable">B</span></a></span> <span class="inlinecode">?</span> with <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.A"><span class="id" type="variable">A</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="var">Fail</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HB</span>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" type="var">binder</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> fixes this shortcoming. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="var">binder</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HB</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">exact</span> <span class="id" type="var">HA</span>.<br/>
</div>

<div class="doc">
We <span class="inlinecode"><span class="id" type="keyword">Abort</span></span>, so that we don't get an extra constant floating around. 
</div>
<div class="code">
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="basic"><span class="id" type="definition">basic</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">C</span>} (<span class="id" type="var">HA</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="HoTT.Tactics.BinderApply.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.Tactics.BinderApply.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">HB</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="HoTT.Tactics.BinderApply.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.Tactics.BinderApply.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a>) : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="HoTT.Tactics.BinderApply.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.Tactics.BinderApply.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
</div>

<div class="doc">
If we try to <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="HoTT.Types.Prod.html#HB"><span class="id" type="variable">HB</span></a></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.Types.Prod.html#HA"><span class="id" type="variable">HA</span></a></span>, wanting to replace <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.B"><span class="id" type="variable">B</span></a></span> with <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.C"><span class="id" type="variable">C</span></a></span>, we get an error about being unable to instantiate the argument of type <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.A"><span class="id" type="variable">A</span></a></span>: "Error: Unable to find an instance for the variable x." 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="var">Fail</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HB</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HA</span>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" type="var">binder</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> fixes this shortcoming. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="var">binder</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HB</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HA</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">exact</span> <span class="id" type="var">HA</span>.<br/>
</div>

<div class="doc">
We <span class="inlinecode"><span class="id" type="keyword">Abort</span></span>, so that we don't get an extra constant floating around. 
</div>
<div class="code">
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="ex_funext"><span class="id" type="definition">ex_funext</span></a> `{<a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" type="class">Funext</span></a>} {<span class="id" type="var">A</span>} <span class="id" type="var">f</span> <span class="id" type="var">g</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">H'</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">w</span> : <a class="idref" href="HoTT.Tactics.BinderApply.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.Tactics.BinderApply.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#z"><span class="id" type="variable">z</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#w"><span class="id" type="variable">w</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x_':>'_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#z"><span class="id" type="variable">z</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#w"><span class="id" type="variable">w</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x_':>'_x"><span class="id" type="notation">:&gt;</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#A"><span class="id" type="variable">A</span></a>)<br/>
: <a class="idref" href="HoTT.Tactics.BinderApply.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Tactics.BinderApply.html#g"><span class="id" type="variable">g</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
</div>

<div class="doc">
We need to apply <span class="inlinecode"><a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a></span> under binders five times in <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H'"><span class="id" type="variable">H'</span></a></span>.  We use a different variant each time to demonstrate the various ways of using this tactic.  In a normal proof, you'd probably just do <span class="inlinecode"><span class="id" type="tactic">do</span></span> <span class="inlinecode">4</span> <span class="inlinecode"><span class="id" type="var">binder</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode">(@<a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a></span> <span class="inlinecode"><span class="id" type="var">_</span>)</span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H'"><span class="id" type="variable">H'</span></a></span> or just <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> <span class="inlinecode"><span class="id" type="var">binder</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode">(@<a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a></span> <span class="inlinecode"><span class="id" type="var">_</span>)</span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H'"><span class="id" type="variable">H'</span></a></span>.  If we do <span class="inlinecode"><span class="id" type="var">binder</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H'"><span class="id" type="variable">H'</span></a></span>, we are told that Coq can't infer the argument <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.A"><span class="id" type="variable">A</span></a></span> to <span class="inlinecode"><a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a></span>.  Instead, we can <span class="inlinecode"><span class="id" type="var">binder</span></span> <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> it, to tell Coq to defer inference and use an evar for now. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="var">Fail</span> <span class="id" type="var">binder</span> <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">binder</span> <span class="id" type="tactic">eapply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span>.<br/>
</div>

<div class="doc">
Alternatively, we can make <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.A"><span class="id" type="variable">A</span></a></span> explicit.  But then we get an error about not being able to resolve the instance of <span class="inlinecode"><a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" type="record">Funext</span></a></span>.  We can either tell Coq to solve the side condition using the <span class="inlinecode"><span class="id" type="tactic">assumption</span></span> tactic (or <span class="inlinecode"><span class="id" type="var">typeclasses</span></span> <span class="inlinecode"><span class="id" type="tactic">eauto</span></span>, for that matter), or we can have typeclass inference run when we construct the lemma to apply.  Some versions of Proof General are bad about noticing <span class="inlinecode"><span class="id" type="var">Fail</span></span> within a tactic; see http://proofgeneral.inf.ed.ac.uk/trac/ticket/494.  So we comment this one out. 
<div class="paragraph"> </div>

<pre>
  Fail binder apply @path_forall in H'.
</pre>
  Error: Tactic failure: Cannot use &lt;tactic&gt; to solve side-condition goal
Funext . Extended goal with context:
(Funext -&gt;
 forall (A : Type) (f g : A -&gt; A -&gt; A -&gt; A -&gt; A)
   (H' : forall x' x'0 x'1 : A, f x' x'0 x'1 = g x' x'0 x'1),
 let H0 := H' in Funext). 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="var">binder</span> <span class="id" type="tactic">apply</span> @<a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span> <span class="id" type="keyword">using</span> <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">binder</span> <span class="id" type="tactic">apply</span> @<a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span> <span class="id" type="keyword">using</span> <span class="id" type="var">typeclasses</span> <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">binder</span> <span class="id" type="tactic">apply</span> (@<a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a> <span class="id" type="var">_</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span>.<br/>
</div>

<div class="doc">
Now we have removed all arguments to <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.f"><span class="id" type="variable">f</span></a></span> and <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.g"><span class="id" type="variable">g</span></a></span> in <span class="inlinecode"><a class="idref" href="HoTT.categories.Adjoint.Composition.AssociativityLaw.html#composition_lemmas.H'"><span class="id" type="variable">H'</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="tactic">exact</span> <span class="id" type="var">H'</span>.<br/>
</div>

<div class="doc">
We <span class="inlinecode"><span class="id" type="keyword">Abort</span></span>, so that we don't get an extra constant floating around. 
</div>
<div class="code">
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
N.B. <span class="inlinecode"><span class="id" type="var">constrbinder</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> is like <span class="inlinecode"><span class="id" type="var">binder</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span>, except that it constructs a new term and returns it, rather than applying a lemma in-place to a hypothesis.  It's primarily useful as plumbing for higher-level tactics. 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>
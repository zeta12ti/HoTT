<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>HoTT.Modalities.Lex</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library HoTT.Modalities.Lex</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.EquivalenceVarieties.html#"><span class="id" title="library">EquivalenceVarieties</span></a> <a class="idref" href="HoTT.Fibrations.html#"><span class="id" title="library">Fibrations</span></a> <a class="idref" href="HoTT.Extensions.html#"><span class="id" title="library">Extensions</span></a> <a class="idref" href="HoTT.Pullback.html#"><span class="id" title="library">Pullback</span></a> <a class="idref" href="HoTT.NullHomotopy.html#"><span class="id" title="library">NullHomotopy</span></a> <a class="idref" href="HoTT.Factorization.html#"><span class="id" title="library">Factorization</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Modalities.Modality.html#"><span class="id" title="library">Modality</span></a> <a class="idref" href="HoTT.Modalities.Accessible.html#"><span class="id" title="library">Accessible</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Tactics.html#"><span class="id" title="library">HoTT.Tactics</span></a>.<br/>

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab292"></a><h1 class="section">Lex modalities</h1>

<div class="paragraph"> </div>

<a name="lab293"></a><h2 class="section">Basic theory</h2>

<div class="paragraph"> </div>

 A lex modality is one that preserves finite limits, or equivalently pullbacks.  It turns out that a more basic and useful way to say this is that all path-spaces of connected types are connected.  Note how different this is from the behavior of, say, truncation modalities!

<div class="paragraph"> </div>

  This is a "large" definition, and we don't know of any small one that's equivalent to it (see &lt;https://mathoverflow.net/questions/185980/a-small-definition-of-sub-∞-1-topoi&gt;.  However, so far we never need to apply it "at multiple universes at once".  Thus, rather than making it a module type, we can make it a typeclass and rely on ordinary universe polymorphism. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a> (<span class="id" title="var">Os</span> : <a class="idref" href="HoTT.Modalities.Modality.html#Modalities"><span class="id" title="module">Modalities</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Lex_Modalities_Theory.Os_Theory"><span class="id" title="module">Os_Theory</span></a> := <a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Class</span> <a name="Lex_Modalities_Theory.Lex"><span class="id" title="record">Lex</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span>})<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <a name="Lex_Modalities_Theory.isconnected_paths"><span class="id" title="projection">isconnected_paths</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>}) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">i</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">i</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global</span> <span class="id" title="var">Existing</span> <span class="id" title="keyword">Instance</span> <span class="id" title="var">isconnected_paths</span>.<br/>

<br/>
</div>

<div class="doc">
The following numbered lemmas are all actually equivalent characterizations of lex-ness.  We prove this for some of them, but we don't make the reverse implications Instances; usually <span class="inlinecode"><a class="idref" href="HoTT.HIT.Connectedness.html#isconnected_paths"><span class="id" title="instance">isconnected_paths</span></a></span> is the easier way to prove lexness. 
<div class="paragraph"> </div>

 1. Every map between connected types is a connected map. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.conn_map_lex"><span class="id" title="instance">conn_map_lex</span></a> {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>}} {<span class="id" title="var">B</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">j</span>}} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_sigma"><span class="id" title="instance">isconnected_sigma</span></a> <span class="id" title="var">O</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.lex_from_conn_map_lex"><span class="id" title="definition">lex_from_conn_map_lex</span></a> {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">AC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv'"><span class="id" title="definition">isconnected_equiv'</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> (<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">x</span>) <span class="id" title="var">y</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_contr_sigma"><span class="id" title="definition">equiv_contr_sigma</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">y</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
2. Connected maps are left- as well as right-cancellable. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.cancelL_conn_map"><span class="id" title="definition">cancelL_conn_map</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>) <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> ? ? <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Fibrations.html#hfiber_hfiber_compose_map"><span class="id" title="definition">hfiber_hfiber_compose_map</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">b</span>) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
3. Every map inverted by <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#Issue754_1.O"><span class="id" title="constructor">O</span></a></span> is <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#Issue754_1.O"><span class="id" title="constructor">O</span></a></span>-connected. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.isconnected_O_inverts"><span class="id" title="definition">isconnected_O_inverts</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_inverts"><span class="id" title="abbreviation">O_inverts</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelL_conn_map"><span class="id" title="definition">cancelL_conn_map</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">B</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>) <span class="id" title="var">_</span>).<br/>
</div>

<div class="doc">
Typeclass magic! 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
4. Connected types are closed under pullbacks.  (Closure under fibers is <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_lex"><span class="id" title="instance">conn_map_lex</span></a></span> above. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.isconnected_pullback"><span class="id" title="instance">isconnected_pullback</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Pullback.html#Pullback"><span class="id" title="definition">Pullback</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_sigma"><span class="id" title="instance">isconnected_sigma</span></a>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> <span class="id" title="var">g</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma'"><span class="id" title="definition">equiv_functor_sigma'</span></a> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_idmap"><span class="id" title="definition">equiv_idmap</span></a> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> ⇒ <a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
5. The reflector preserves pullbacks.  This justifies the terminology "lex". 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.O_functor_pullback"><span class="id" title="definition">O_functor_pullback</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Pullback.html#IsPullback"><span class="id" title="definition">IsPullback</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_square"><span class="id" title="definition">O_functor_square</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Pullback.html#pullback_commsq"><span class="id" title="definition">pullback_commsq</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a>)).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isequiv_O_inverts"><span class="id" title="definition">isequiv_O_inverts</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_inverts_conn_map"><span class="id" title="instance">O_inverts_conn_map</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelR_conn_map"><span class="id" title="definition">cancelR_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Pullback.html#Pullback"><span class="id" title="definition">Pullback</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span>)) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Pullback.html#functor_pullback"><span class="id" title="definition">functor_pullback</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor"><span class="id" title="definition">O_functor</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor"><span class="id" title="definition">O_functor</span></a> <span class="id" title="var">O</span> <span class="id" title="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">B</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <span class="id" title="var">g</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
</div>

<div class="doc">
This *seems* like it ought to be the easier goal, but it turns out to involve lots of naturality wrangling.  If we ever want to make real use of this theorem, we might want to separate out this goal into an opaque lemma so we could make the main theorem transparent. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> [<span class="id" title="var">c</span> <span class="id" title="var">e</span>]];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Pullback.html#functor_pullback"><span class="id" title="definition">functor_pullback</span></a>, <a class="idref" href="HoTT.Types.Sigma.html#functor_sigma"><span class="id" title="definition">functor_sigma</span></a>, <a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#path_sigma'"><span class="id" title="definition">path_sigma'</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <a class="idref" href="HoTT.Pullback.html#pullback_pr1"><span class="id" title="definition">pullback_pr1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;(</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a><span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">))</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Sigma.html#transport_sigma'"><span class="id" title="definition">transport_sigma'</span></a>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#path_sigma'"><span class="id" title="definition">path_sigma'</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <a class="idref" href="HoTT.Pullback.html#pullback_pr2"><span class="id" title="definition">pullback_pr2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;(</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a><span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">))</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_Fl"><span class="id" title="definition">transport_paths_Fl</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_Fr"><span class="id" title="definition">transport_paths_Fr</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">long_path_scope</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_square"><span class="id" title="definition">O_functor_square</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a>, <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_homotopy_beta"><span class="id" title="definition">O_functor_homotopy_beta</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p_pp"><span class="id" title="definition">concat_p_pp</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Pullback.html#pullback_commsq"><span class="id" title="definition">pullback_commsq</span></a>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural_compose"><span class="id" title="definition">to_O_natural_compose</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_pp_p"><span class="id" title="definition">concat_pp_p</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">do</span> 3 <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#whiskerL"><span class="id" title="definition">whiskerL</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a>, &lt;- <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_pp"><span class="id" title="definition">inv_pp</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_compose"><span class="id" title="definition">O_functor_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)), &lt;- <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_pp"><span class="id" title="definition">inv_pp</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#inverse2"><span class="id" title="definition">inverse2</span></a>, <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural_compose"><span class="id" title="definition">to_O_natural_compose</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Close</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">long_path_scope</span>.<br/>
</div>

<div class="doc">
By contrast, this goal, which seems to contain all the mathematical content, is solved fairly easily by <span class="inlinecode"><a class="idref" href="HoTT.Pullback.html#hfiber_functor_pullback"><span class="id" title="definition">hfiber_functor_pullback</span></a></span> and typeclass magic invoking <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_pullback"><span class="id" title="instance">isconnected_pullback</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">ob</span> [<span class="id" title="var">oc</span> <span class="id" title="var">oe</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Pullback.html#hfiber_functor_pullback"><span class="id" title="definition">hfiber_functor_pullback</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
6. The reflector preserves fibers.  This is a slightly simpler version of the previous. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.isequiv_O_functor_hfiber"><span class="id" title="instance">isequiv_O_functor_hfiber</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isequiv_O_inverts"><span class="id" title="definition">isequiv_O_inverts</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_inverts_conn_map"><span class="id" title="instance">O_inverts_conn_map</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelR_conn_map"><span class="id" title="definition">cancelR_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<a class="idref" href="HoTT.Fibrations.html#functor_hfiber"><span class="id" title="definition">functor_hfiber</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor"><span class="id" title="definition">O_functor</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a>) <span class="id" title="var">b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Fibrations.html#functor_hfiber"><span class="id" title="definition">functor_hfiber</span></a>, <a class="idref" href="HoTT.Types.Sigma.html#functor_sigma"><span class="id" title="definition">functor_sigma</span></a>. <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#whiskerR"><span class="id" title="definition">whiskerR</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">oa</span> <span class="id" title="var">p</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Fibrations.html#hfiber_functor_hfiber"><span class="id" title="definition">hfiber_functor_hfiber</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.equiv_O_functor_hfiber"><span class="id" title="definition">equiv_O_functor_hfiber</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor"><span class="id" title="definition">O_functor</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="HoTT.Basics.Overture.html#BuildEquiv"><span class="id" title="constructor">BuildEquiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>) <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
7. Lex modalities preserve path-spaces. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.O_path_cmp"><span class="id" title="definition">O_path_cmp</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) {<span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_rec"><span class="id" title="definition">O_rec</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.isequiv_O_path_cmp"><span class="id" title="instance">isequiv_O_path_cmp</span></a> {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>} {<span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_path_cmp"><span class="id" title="definition">O_path_cmp</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isequiv_conn_ino_map"><span class="id" title="definition">isequiv_conn_ino_map</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelR_conn_map"><span class="id" title="definition">cancelR_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">y</span>)) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span>)) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Fibrations.html#hfiber_ap"><span class="id" title="definition">hfiber_ap</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
8. Any modal map between connected types is an equivalence. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.isequiv_ismodal_isconnected_types"><span class="id" title="instance">isequiv_ismodal_isconnected_types</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>} {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isequiv_conn_ino_map"><span class="id" title="definition">isequiv_conn_ino_map</span></a> <span class="id" title="var">O</span>); <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.lex_from_isequiv_ismodal_isconnected_types"><span class="id" title="definition">lex_from_isequiv_ismodal_isconnected_types</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.lex_from_conn_map_lex"><span class="id" title="definition">lex_from_conn_map_lex</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">AC</span> <span class="id" title="var">BC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Factorization.html#fact_factors"><span class="id" title="projection">fact_factors</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.image"><span class="id" title="definition">image</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_compose"><span class="id" title="instance">conn_map_compose</span></a>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_isequiv"><span class="id" title="instance">conn_map_isequiv</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>; [ | <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_conn_map_to_unit"><span class="id" title="definition">isconnected_conn_map_to_unit</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelR_conn_map"><span class="id" title="definition">cancelR_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Factorization.html#factor1"><span class="id" title="projection">factor1</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.image"><span class="id" title="definition">image</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
9. Any commutative square with connected maps in one direction and modal ones in the other must necessarily be a pullback. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.ispullback_connmap_mapino_commsq"><span class="id" title="definition">ispullback_connmap_mapino_commsq</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>} {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#D"><span class="id" title="variable">D</span></a>} {<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">k</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#D"><span class="id" title="variable">D</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#h"><span class="id" title="variable">h</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#k"><span class="id" title="variable">k</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">p</span> : <a class="idref" href="HoTT.Modalities.Lex.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#h"><span class="id" title="variable">h</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Pullback.html#IsPullback"><span class="id" title="definition">IsPullback</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#p"><span class="id" title="variable">p</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isequiv_conn_ino_map"><span class="id" title="definition">isequiv_conn_ino_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a> <span class="id" title="var">p</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelL_conn_map"><span class="id" title="definition">cancelL_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a> <span class="id" title="var">p</span>) (<span class="id" title="var">k</span><a class="idref" href="HoTT.Pullback.html#a3f59e6c9556bd7073e29064ad7219d8"><span class="id" title="notation">^*</span></a> <span class="id" title="var">g</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelL_mapinO"><span class="id" title="definition">cancelL_mapinO</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Pullback.html#equiv_pullback_symm"><span class="id" title="definition">equiv_pullback_symm</span></a> <span class="id" title="var">k</span> <span class="id" title="var">g</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelL_mapinO"><span class="id" title="definition">cancelL_mapinO</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<span class="id" title="var">g</span><a class="idref" href="HoTT.Pullback.html#a3f59e6c9556bd7073e29064ad7219d8"><span class="id" title="notation">^*</span></a> <span class="id" title="var">k</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.lex_from_ispullback_connmap_mapino_commsq"><span class="id" title="definition">lex_from_ispullback_connmap_mapino_commsq</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#D"><span class="id" title="variable">D</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>) (<span class="id" title="var">k</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#D"><span class="id" title="variable">D</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#k"><span class="id" title="variable">k</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">p</span> : <a class="idref" href="HoTT.Modalities.Lex.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Pullback.html#IsPullback"><span class="id" title="definition">IsPullback</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#p"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.lex_from_isequiv_ismodal_isconnected_types"><span class="id" title="definition">lex_from_isequiv_ismodal_isconnected_types</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">AC</span> <span class="id" title="var">BC</span> <span class="id" title="var">fM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) <span class="id" title="var">f</span> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ 1)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Pullback.html#IsPullback"><span class="id" title="definition">IsPullback</span></a>, <a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a>) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Pullback.html#Pullback"><span class="id" title="definition">Pullback</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a> <span class="id" title="var">_</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">b</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a><a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">B</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Types.Sigma.html#functor_sigma"><span class="id" title="definition">functor_sigma</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_sigma_prod0"><span class="id" title="definition">equiv_sigma_prod0</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#equiv_isequiv"><span class="id" title="projection">equiv_isequiv</span></a> (<a class="idref" href="HoTT.Types.Prod.html#prod_unit_l"><span class="id" title="definition">prod_unit_l</span></a> <span class="id" title="var">B</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
10. Families of modal types indexed by connected types are constant. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.modal_over_connected_isconst_lex"><span class="id" title="definition">modal_over_connected_isconst_lex</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>} (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) `{<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.In"><span class="id" title="class">In</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a>)}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">Q</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="keyword">Type</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.In"><span class="id" title="class">In</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">Q</span> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">&lt;~&gt;</span></a> <span class="id" title="var">Q</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<span class="id" title="var">O</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a><span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">P</span> <span class="id" title="var">x</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>); <span class="id" title="tactic">split</span>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#BuildEquiv"><span class="id" title="constructor">BuildEquiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">p</span> ⇒ <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isequiv_conn_map_ino"><span class="id" title="definition">isequiv_conn_map_ino</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.conn_map_fiber"><span class="id" title="definition">conn_map_fiber</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelL_conn_map"><span class="id" title="definition">cancelL_conn_map</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span>:<a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a><span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">O</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">P</span> <span class="id" title="var">x</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}}</span></a> ⇒ <a class="idref" href="HoTT.Modalities.Lex.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_equiv'"><span class="id" title="definition">isconnected_equiv'</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_adjointify"><span class="id" title="definition">equiv_adjointify</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">((</span></a><a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <span class="id" title="var">z</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1.1</span></a>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [[<span class="id" title="var">x</span> <span class="id" title="var">y</span>] []]; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
And conversely. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.lex_from_modal_over_connected_isconst"><span class="id" title="definition">lex_from_modal_over_connected_isconst</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.In"><span class="id" title="class">In</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">Q</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="keyword">Type</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.In"><span class="id" title="class">In</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">Q</span> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">&lt;~&gt;</span></a> <span class="id" title="var">Q</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_from_elim_to_O"><span class="id" title="definition">isconnected_from_elim_to_O</span></a>.<br/>
</div>

<div class="doc">
By assumption, <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Attributes.html#fully_faithful_helpers.y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#Issue754_1.O"><span class="id" title="constructor">O</span></a></span> <span class="inlinecode">(<a class="idref" href="HoTT.Categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" title="projection">x</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Attributes.html#fully_faithful_helpers.y"><span class="id" title="variable">y</span></a>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.A"><span class="id" title="variable">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses_Theory.Type_"><span class="id" title="definition">Type_</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#Issue754_1.O"><span class="id" title="constructor">O</span></a></span> is constant.  Thus, <span class="inlinecode"><a class="idref" href="HoTT.Categories.IndiscreteCategory.html#Functors.to"><span class="id" title="definition">to</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#Issue754_1.O"><span class="id" title="constructor">O</span></a></span> <span class="inlinecode">(<a class="idref" href="HoTT.Categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" title="projection">x</span></a>=<a class="idref" href="HoTT.Categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" title="projection">x</span></a>)</span> <span class="inlinecode">1</span> can be transported around to make it contractible everywhere. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">A</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">O</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#z"><span class="id" title="variable">z</span></a>)) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Q</span> [? <span class="id" title="var">H</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.NullHomotopy.html#NullHomotopy"><span class="id" title="definition">NullHomotopy</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><span class="id" title="var">H</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a> ((<span class="id" title="var">H</span> <span class="id" title="var">x</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> 1))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Lex modalities preserve <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a></span>-types for all <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a></span>.  This is definitely not equivalent to lex-ness, since it is true for the truncation modalities that are not lex.  But it is also not true of all modalities; e.g. the shape modality in a cohesive topos can take 0-types to <span class="inlinecode"><a class="idref" href="HoTT.HIT.Truncations.html#oo"><span class="id" title="abbreviation">oo</span></a></span>-types. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.istrunc_O_lex"><span class="id" title="instance">istrunc_O_lex</span></a> `{<a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" title="class">Funext</span></a>} {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">n</span>} {<span class="id" title="var">A</span>} `{<a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#n"><span class="id" title="variable">n</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">A</span>; <span class="id" title="var">simple_induction</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span> <span class="id" title="var">IHn</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> ?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. </div>

<div class="doc">
Already proven for all modalities. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_ind"><span class="id" title="definition">O_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <span class="id" title="var">n</span> (<a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>)) <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_ind"><span class="id" title="definition">O_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <span class="id" title="var">n</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>)) <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Trunc.html#trunc_equiv"><span class="id" title="definition">trunc_equiv</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_path_cmp"><span class="id" title="definition">O_path_cmp</span></a> <span class="id" title="var">O</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab294"></a><h2 class="section">Lex reflective subuniverses</h2>

<div class="paragraph"> </div>

 A reflective subuniverse that preserves fibers is in fact a modality (and hence lex). 
</div>
<div class="code">
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Type</span> <a name="Preserves_Fibers"><span class="id" title="module">Preserves_Fibers</span></a> (<span class="id" title="var">Os</span> : <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses"><span class="id" title="module">ReflectiveSubuniverses</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Export</span> <span class="id" title="var">Os</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Preserves_Fibers.Os_Theory"><span class="id" title="module">Os_Theory</span></a> := <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses_Theory"><span class="id" title="module">ReflectiveSubuniverses_Theory</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Parameter</span> <a name="Preserves_Fibers.isequiv_O_functor_hfiber"><span class="id" title="axiom">isequiv_O_functor_hfiber</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.ReflectiveSubuniverse"><span class="id" title="axiom">ReflectiveSubuniverse</span></a>) {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Preserves_Fibers.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>).<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Lex.html#Preserves_Fibers"><span class="id" title="module">Preserves_Fibers</span></a>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a name="Lex_Reflective_Subuniverses"><span class="id" title="module">Lex_Reflective_Subuniverses</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Os</span> : <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses"><span class="id" title="module">ReflectiveSubuniverses</span></a>) (<span class="id" title="var">Opf</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Preserves_Fibers"><span class="id" title="module">Preserves_Fibers</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>)<br/>
&nbsp;&nbsp;&lt;: <a class="idref" href="HoTT.Modalities.Modality.html#SigmaClosed"><span class="id" title="module">SigmaClosed</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Import</span> <span class="id" title="var">Opf</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Reflective_Subuniverses.inO_sigma"><span class="id" title="definition">inO_sigma@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">k</span>} (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.ReflectiveSubuniverse"><span class="id" title="axiom">ReflectiveSubuniverse@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span>})<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span>:<span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>}) (<span class="id" title="var">B</span>:<a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="var">Type@</span>{<span class="id" title="var">j</span>})<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A_inO</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.In"><span class="id" title="class">In@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">i</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">B_inO</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os.In"><span class="id" title="class">In@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">j</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#a"><span class="id" title="variable">a</span></a>))<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Os.In"><span class="id" title="class">In@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">k</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a><a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <span class="id" title="var">x</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">g</span> := <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_rec"><span class="id" title="definition">O_rec@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">k</span> <span class="id" title="var">i</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span> <span class="id" title="var">i</span>} <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> : <span class="id" title="var">O</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">B</span> <span class="id" title="var">x</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="var">A</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">transparent</span> <span class="id" title="tactic">assert</span> (<span class="id" title="var">p</span> : (<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <span class="id" title="var">g</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Os.to"><span class="id" title="axiom">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">subst</span> <span class="id" title="var">g</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.inO_isequiv_to_O"><span class="id" title="definition">inO_isequiv_to_O@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span>}.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.EquivalenceVarieties.html#isequiv_fcontr"><span class="id" title="definition">isequiv_fcontr</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv'"><span class="id" title="definition">contr_equiv'</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Fibrations.html#hfiber_hfiber_compose_map"><span class="id" title="definition">hfiber_hfiber_compose_map@</span></a>{<span class="id" title="var">k</span> <span class="id" title="var">k</span> <span class="id" title="var">i</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span>} <span class="id" title="var">_</span> <span class="id" title="var">g</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.EquivalenceVarieties.html#fcontr_isequiv"><span class="id" title="definition">fcontr_isequiv</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Fibrations.html#hfiber_compose_map"><span class="id" title="definition">hfiber_compose_map</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">transparent</span> <span class="id" title="tactic">assert</span> (<span class="id" title="var">h</span> : (<a class="idref" href="HoTT.Basics.Overture.html#Equiv"><span class="id" title="record">Equiv@</span></a>{<span class="id" title="var">k</span> <span class="id" title="var">k</span>} (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber@</span></a>{<span class="id" title="var">k</span> <span class="id" title="var">i</span>} (@<a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) (<span class="id" title="var">g</span> <span class="id" title="var">x</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber@</span></a>{<span class="id" title="var">k</span> <span class="id" title="var">i</span>} <span class="id" title="var">g</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.equiv_to_O"><span class="id" title="definition">equiv_to_O@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span>} <span class="id" title="var">O</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Basics.Overture.html#BuildEquiv"><span class="id" title="constructor">BuildEquiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a> <span class="id" title="var">O</span> (@<a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) (<span class="id" title="var">g</span> <span class="id" title="var">x</span>)) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma'"><span class="id" title="definition">equiv_functor_sigma'</span></a> 1 <span class="id" title="var">_</span>). <span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Types.Paths.html#equiv_moveR_equiv_V"><span class="id" title="definition">equiv_moveR_equiv_V</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">)</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Paths.html#equiv_concat_l"><span class="id" title="definition">equiv_concat_l</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#moveL_equiv_V"><span class="id" title="definition">moveL_equiv_V</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">g</span>, <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_functor"><span class="id" title="definition">O_functor</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_indpaths"><span class="id" title="definition">O_indpaths@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">k</span> <span class="id" title="var">i</span> <span class="id" title="var">i</span> <span class="id" title="var">k</span> <span class="id" title="var">k</span>}; <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">q</span>]; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>, <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_homotopic"><span class="id" title="definition">isequiv_homotopic</span></a> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Fibrations.html#equiv_hfiber_homotopic"><span class="id" title="definition">equiv_hfiber_homotopic</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">p</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>)) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [[<span class="id" title="var">a</span> <span class="id" title="var">b</span>] <span class="id" title="var">q</span>]; <span class="id" title="var">cbn</span>. <span class="id" title="tactic">clear</span> <span class="id" title="var">h</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_functor_hfiber"><span class="id" title="definition">O_functor_hfiber</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Types.Sigma.html#functor_sigma"><span class="id" title="definition">functor_sigma</span></a>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#path_sigma'"><span class="id" title="definition">path_sigma'</span></a> <span class="id" title="var">_</span> 1 <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.O_indpaths_beta"><span class="id" title="definition">O_indpaths_beta</span></a>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Equivalences.html#moveL_equiv_V"><span class="id" title="definition">moveL_equiv_V</span></a>, <a class="idref" href="HoTT.Basics.Equivalences.html#moveR_equiv_V"><span class="id" title="definition">moveR_equiv_V</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">long_path_scope</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Local Opaque</span> <a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a>. &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">k</span> := @<a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a>); <span class="id" title="tactic">change</span> @<a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">k</span>; <span class="id" title="tactic">subst</span> <span class="id" title="var">k</span>. &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> !<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_pp"><span class="id" title="definition">ap_pp</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p_pp"><span class="id" title="definition">concat_p_pp</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Modalities.Lex.html#Opf.Os_Theory.to_O_natural"><span class="id" title="definition">to_O_natural</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_pV_p"><span class="id" title="definition">concat_pV_p</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_pp_V"><span class="id" title="definition">concat_pp_V</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_pp_p"><span class="id" title="definition">concat_pp_p</span></a>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_Vp"><span class="id" title="definition">moveR_Vp</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- !(<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Os.to"><span class="id" title="axiom">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span>) <a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Os.to"><span class="id" title="axiom">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rapply</span> @<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_A1p"><span class="id" title="definition">concat_A1p</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Local Transparent</span> <a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a>. &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Close</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">long_path_scope</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Reflective_Subuniverses"><span class="id" title="module">Lex_Reflective_Subuniverses</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab295"></a><h2 class="section">Accessible lex modalities</h2>

<div class="paragraph"> </div>

 We now restrict to lex modalities that are also accessible. 
</div>
<div class="code">
<span class="id" title="keyword">Module</span> <a name="Accessible_Lex_Modalities_Theory"><span class="id" title="module">Accessible_Lex_Modalities_Theory</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Os</span> : <a class="idref" href="HoTT.Modalities.Modality.html#Modalities"><span class="id" title="module">Modalities</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Acc</span> : <a class="idref" href="HoTT.Modalities.Accessible.html#Accessible_Modalities"><span class="id" title="module">Accessible_Modalities</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Accessible_Lex_Modalities_Theory.Acc_Theory"><span class="id" title="module">Acc_Theory</span></a> := <a class="idref" href="HoTT.Modalities.Accessible.html#Accessible_Modalities_Theory"><span class="id" title="module">Accessible_Modalities_Theory</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Acc"><span class="id" title="module">Acc</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Accessible_Lex_Modalities_Theory.Lex_Theory"><span class="id" title="module">Lex_Theory</span></a> := <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>.<br/>

<br/>
</div>

<div class="doc">
Unfortunately, another subtlety of modules bites us here.  It appears that each application of a parametrized module to arguments creates a *new* module, and Coq has no algorithm (not even syntactic identity) for considering two such modules "the same".  In particular, the applications <span class="inlinecode"><span class="id" title="keyword">Module</span></span> <span class="inlinecode"><span class="id" title="var">Os_Theory</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> <span class="inlinecode"><span class="id" title="var">Os</span></span> that occur in both <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Accessible.html#Accessible_Modalities_Theory"><span class="id" title="module">Accessible_Modalities_Theory</span></a></span> <span class="inlinecode"><span class="id" title="var">Os</span></span> <span class="inlinecode"><span class="id" title="var">Acc</span></span> and <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a></span> <span class="inlinecode"><span class="id" title="var">Os</span></span> create two *different* modules, which appear here as <span class="inlinecode"><span class="id" title="var">Acc_Theory.Os_Theory</span></span> and <span class="inlinecode"><span class="id" title="var">Lex_Theory.Os_Theory</span></span>.  Thus, for instance, we have two different definitions <span class="inlinecode"><span class="id" title="var">Acc_Theory.Os_Theory.O_ind</span></span> and <span class="inlinecode"><span class="id" title="var">Lex_Theory.Os_Theory.O_ind</span></span>, etc.

<div class="paragraph"> </div>

  Fortunately, since these duplicate pairs of definitions each have the same body *and are (usually) transparent*, Coq is willing to consider them identical.  Thus, this doesn't cause a great deal of trouble.  However, there are certain contexts in which this doesn't apply.  For instance, if any definition in <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> is opaque, then Coq will be unable to notice that its duplicate copies in <span class="inlinecode"><span class="id" title="var">Acc_Theory.Os_Theory</span></span> and <span class="inlinecode"><span class="id" title="var">Lex_Theory.Os_Theory</span></span> were identical, potentially causing problems.  But since we generally only make definitions opaque if we aren't going to depend on their actual value anywhere else, this is unlikely to be much of an issue.

<div class="paragraph"> </div>

  A more serious issue is that there are some declarations that function up to a syntactic equality that is stricter than judgmental conversion.  For instance, <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> and <span class="inlinecode"><span class="id" title="keyword">Record</span></span> definitions, like modules, always create a new object not convertible to any previously existing one.  There are no <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> or <span class="inlinecode"><span class="id" title="keyword">Record</span></span> definitions in <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span>, but there are <span class="inlinecode"><span class="id" title="keyword">Class</span></span> declarations, and these function similarly.  In particular, typeclass search is unable to use <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>s defined in <span class="inlinecode"><span class="id" title="var">Acc_Theory</span></span> to instantiate typeclasses from <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> (such as <span class="inlinecode"><a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses_Theory.IsConnected"><span class="id" title="record">IsConnected</span></a></span>) needed by functions in <span class="inlinecode"><span class="id" title="var">Lex_Theory</span></span>, and vice versa.

<div class="paragraph"> </div>

  Fortunately, all the typeclasses defined in <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> are *singleton* or *definitional* classes (defined with `:= unique_field` rather than `{ field1 ; field2 ; ... }`), which means that they do not actually introduce a new record wrapper.  Thus, the <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>s from <span class="inlinecode"><span class="id" title="var">Acc_Theory</span></span> can in fact be typechecked to *belong* to the typeclasses needed by <span class="inlinecode"><span class="id" title="var">Lex_Theory</span></span>, and hence can be supplied explicitly.

<div class="paragraph"> </div>

  We can also do this once and for all by defining <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>s translating automatically between the two typeclasses, although unfortunately we probably can't declare such instances in both directions at once for fear of infinite loops.  Fortunately, there is not a lot in <span class="inlinecode"><span class="id" title="var">Acc_Theory</span></span>, so this direction seems likely to be the most useful. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Accessible_Lex_Modalities_Theory.isconnected_acc_to_lex"><span class="id" title="instance">isconnected_acc_to_lex</span></a> {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">H</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.IsConnected"><span class="id" title="class">Acc_Theory.Os_Theory.RSU.IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.IsConnected"><span class="id" title="class">Lex_Theory.Os_Theory.RSU.IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
Probably the most important thing about an accessible lex modality is that the universe of modal types is again modal.  Here by "the universe" we mean a universe large enough to contain the generating family; this is why we need accessibility. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Accessible_Lex_Modalities_Theory.inO_typeO"><span class="id" title="instance">inO_typeO</span></a> `{<a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="class">Univalence</span></a>} (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.In"><span class="id" title="class">In</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Type_"><span class="id" title="definition">Type_</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Acc.inO_iff_isnull"><span class="id" title="axiom">inO_iff_isnull</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; [ <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> | <span class="id" title="tactic">split</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">P</span>.<br/>
</div>

<div class="doc">
The case <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a>=0</span> is basically just one of the above characterizations of lex-ness. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.modal_over_connected_isconst_lex"><span class="id" title="definition">modal_over_connected_isconst_lex</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Acc.acc_gen"><span class="id" title="axiom">acc_gen</span></a> <span class="id" title="var">O</span> <span class="id" title="var">i</span>) <span class="id" title="var">P</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">as</span> [<span class="id" title="var">Q</span> [<span class="id" title="var">QinO</span> <span class="id" title="var">f</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">Q</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <span class="id" title="var">QinO</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.path_TypeO"><span class="id" title="definition">path_TypeO</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Universe.html#path_universe"><span class="id" title="definition">path_universe</span></a> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
</div>

<div class="doc">
The case <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a>&gt;0</span> is actually quite easy, using univalence and the fact that modal types are closed under <span class="inlinecode"><a class="idref" href="HoTT.HIT.quotient.html#Equiv"><span class="id" title="section">Equiv</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Extensions.html#extendable_postcompose'"><span class="id" title="definition">extendable_postcompose'</span></a> <span class="id" title="var">n</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> ⇒ <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.equiv_path_TypeO"><span class="id" title="definition">equiv_path_TypeO</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">A</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>) (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Types.Universe.html#equiv_path_universe"><span class="id" title="definition">equiv_path_universe</span></a> (<span class="id" title="var">A</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>) (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="HoTT.Basics.Equivalences.html#e4f125badd7d48f77249897c8bdc044f"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.extendable_conn_map_inO"><span class="id" title="definition">extendable_conn_map_inO</span></a> <span class="id" title="var">O</span> <span class="id" title="var">n</span> (@<a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Acc.acc_gen"><span class="id" title="axiom">acc_gen</span></a> <span class="id" title="var">O</span> <span class="id" title="var">i</span>) <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> ⇒ <span class="id" title="var">A</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">&lt;~&gt;</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>)).<br/>
</div>

<div class="doc">
Typeclass magic! 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.inO_typeO"><span class="id" title="instance">inO_typeO</span></a></span> is also an equivalent characterization of lex-ness for a modality, by the converse of the characterization of lex-ness we used above. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Accessible_Lex_Modalities_Theory.lex_inO_typeO"><span class="id" title="definition">lex_inO_typeO</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.In"><span class="id" title="class">In</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Type_"><span class="id" title="definition">Type_</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>)}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.lex_from_modal_over_connected_isconst"><span class="id" title="definition">lex_from_modal_over_connected_isconst</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> ? <span class="id" title="var">PO</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.isconnected_elim"><span class="id" title="definition">isconnected_elim</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Type_"><span class="id" title="definition">Type_</span></a> <span class="id" title="var">O</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">P</span> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <span class="id" title="var">PO</span> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">as</span> [<span class="id" title="var">Q</span> <span class="id" title="var">f</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">Q</span>; <span class="id" title="tactic">split</span>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#equiv_path"><span class="id" title="definition">equiv_path</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory"><span class="id" title="module">Accessible_Lex_Modalities_Theory</span></a>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>
<html>
<head>
<title>Lex.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Lex.v</h1>

<div class="code" title="File: Lex.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*- *)</pre>
</div>
<div class="code" title="File: Lex.v
Line: 1
Time: 0.044s">
<div class="time" style="width: 1.6845329249617%"></div>
<pre>Require Import HoTT.Basics HoTT.Types.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 1
Time: 0.014s">
<div class="time" style="width: 0.53598774885145%"></div>
<pre>
Require Import EquivalenceVarieties Fibrations Extensions Pullback NullHomotopy Factorization.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 2
Time: 0.018s">
<div class="time" style="width: 0.68912710566616%"></div>
<pre>
Require Import Modality Accessible.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 3
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>
Require Import HoTT.Tactics.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 6
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** * Lex modalities *)

(** ** Basic theory *)

(** A lex modality is one that preserves finite limits, or equivalently pullbacks.  It turns out that a more basic and useful way to say this is that all path-spaces of connected types are connected.  Note how different this is from the behavior of, say, truncation modalities!

  This is a "large" definition, and we don't know of any small one that's equivalent to it (see &lt;https://mathoverflow.net/questions/185980/a-small-definition-of-sub-âˆž-1-topoi&gt;.  However, so far we never need to apply it "at multiple universes at once".  Thus, rather than making it a module type, we can make it a typeclass and rely on ordinary universe polymorphism. *)

</pre>
</div>
<div class="code" title="File: Lex.v
Line: 16
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Module Lex_Modalities_Theory (Os : Modalities).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 16
Time: 0.095s">
<div class="time" style="width: 3.6370597243492%"></div>
<pre>

  Module Export Os_Theory := Modalities_Theory Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 18
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>

  Class Lex (O : Modality@{u a})
    := isconnected_paths : forall (A : Type@{i}) (x y : A),
                             IsConnected@{u a i} O A -&gt;
                             IsConnected@{u a i} O (x = y).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Global Existing Instance isconnected_paths.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 25
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** The following numbered lemmas are all actually equivalent characterizations of lex-ness.  We prove this for some of them, but we don't make the reverse implications Instances; usually [isconnected_paths] is the easier way to prove lexness. *)

  (** 1. Every map between connected types is a connected map. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 30
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance conn_map_lex {O : Modality} `{Lex O}
         {A : Type@{i}} {B : Type@{j}} {f : A -&gt; B}
         `{IsConnected O A} `{IsConnected O B}
  : IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 33
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 34
Time: 0.016s">
<div class="time" style="width: 0.61255742725881%"></div>
<pre>
    intros b; refine (isconnected_sigma O).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 35
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 36
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Definition lex_from_conn_map_lex {O : Modality}
             (H : forall A B (f : A -&gt; B),
                         (IsConnected O A) -&gt; (IsConnected O B) -&gt;
                         IsConnMap O f)
    : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 42
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 43
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A x y AC.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 44
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>
    refine (isconnected_equiv' O (hfiber (unit_name x) y) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 45
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 46
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    refine (equiv_contr_sigma (fun _ =&gt; x = y)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 47
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 48
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 2. Connected maps are left- as well as right-cancellable. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 51
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>Definition cancelL_conn_map (O : Modality) `{Lex O}
             {A B C : Type} (f : A -&gt; B) (g : B -&gt; C)
  : IsConnMap O g -&gt; IsConnMap O (g o f) -&gt; IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 53
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 54
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros ? ? b.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 55
Time: 0.045s">
<div class="time" style="width: 1.7228177641654%"></div>
<pre>
    refine (isconnected_equiv O _ (hfiber_hfiber_compose_map f g b) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 56
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 57
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 3. Every map inverted by [O] is [O]-connected. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 60
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>Definition isconnected_O_inverts (O : Modality) `{Lex O}
             {A B : Type} (f : A -&gt; B) `{O_inverts O f}
  : IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 62
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 63
Time: 0.053s">
<div class="time" style="width: 2.0290964777948%"></div>
<pre>
    refine (cancelL_conn_map O f (to O B) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 64
Time: 0.063s">
<div class="time" style="width: 2.4119448698315%"></div>
<pre>
    refine (conn_map_homotopic O _ _ (to_O_natural O f) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 65
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** Typeclass magic! *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 67
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 67
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 4. Connected types are closed under pullbacks.  (Closure under fibers is [conn_map_lex] above. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 70
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>Global Instance isconnected_pullback (O : Modality) `{Lex O}
         {A B C : Type} {f : A -&gt; C} {g : B -&gt; C}
         `{IsConnected O A} `{IsConnected O B} `{IsConnected O C}
  : IsConnected O (Pullback f g).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 73
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 74
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply isconnected_sigma; [ exact _ | intros a ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 75
Time: 0.009s">
<div class="time" style="width: 0.34456355283308%"></div>
<pre>
    refine (isconnected_equiv O (hfiber g (f a))
                              (equiv_functor_sigma' (equiv_idmap _)
                              (fun b =&gt; equiv_path_inverse _ _))
                              _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 79
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 80
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 5. The reflector preserves pullbacks.  This justifies the terminology "lex". *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 83
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>Definition O_functor_pullback (O : Modality) `{Lex O}
             {A B C} (f : B -&gt; A) (g : C -&gt; A)
  : IsPullback (O_functor_square O _ _ _ _ (pullback_commsq f g)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 85
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 86
Time: 0.197s">
<div class="time" style="width: 7.542113323124%"></div>
<pre>
    refine (isequiv_O_inverts O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 87
Time: 0.071s">
<div class="time" style="width: 2.7182235834609%"></div>
<pre>
    refine (O_inverts_conn_map O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 88
Time: 0.281s">
<div class="time" style="width: 10.758039816233%"></div>
<pre>
    refine (cancelR_conn_map O (to O (Pullback f g)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 89
Time: 0.13s">
<div class="time" style="width: 4.9770290964778%"></div>
<pre>
    refine (conn_map_homotopic O
             (functor_pullback f g (O_functor O f) (O_functor O g)
                               (to O A) (to O B) (to O C)
                               (to_O_natural O f) (to_O_natural O g))
             _ _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 94
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** This *seems* like it ought to be the easier goal, but it turns out to involve lots of naturality wrangling.  If we ever want to make real use of this theorem, we might want to separate out this goal into an opaque lemma so we could make the main theorem transparent. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 96
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 96
Time: 0.007s">
<div class="time" style="width: 0.26799387442573%"></div>
<pre> intros [b [c e]];
        unfold functor_pullback, functor_sigma, pullback_corec;
        simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 98
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>
      refine (path_sigma' _ (to_O_natural O pullback_pr1 (b;(c;e)))^ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 99
Time: 0.008s">
<div class="time" style="width: 0.3062787136294%"></div>
<pre>
      rewrite transport_sigma'; simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 100
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>
      refine (path_sigma' _ (to_O_natural O pullback_pr2 (b;(c;e)))^ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 101
Time: 0.006s">
<div class="time" style="width: 0.22970903522205%"></div>
<pre>
      rewrite transport_paths_Fl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 102
Time: 0.007s">
<div class="time" style="width: 0.26799387442573%"></div>
<pre>
      rewrite transport_paths_Fr.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 103
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      Open Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 104
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold O_functor_square.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 105
Time: 0.112s">
<div class="time" style="width: 4.2879019908116%"></div>
<pre>
      rewrite ap_V, inv_V, O_functor_homotopy_beta, !concat_p_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 106
Time: 0.027s">
<div class="time" style="width: 1.0336906584992%"></div>
<pre>
      unfold pullback_commsq; simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 107
Time: 0.135s">
<div class="time" style="width: 5.1684532924962%"></div>
<pre>
      rewrite to_O_natural_compose, !concat_pp_p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 108
Time: 0.008s">
<div class="time" style="width: 0.3062787136294%"></div>
<pre>
      do 3 apply whiskerL.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 109
Time: 0.012s">
<div class="time" style="width: 0.4594180704441%"></div>
<pre>
      rewrite ap_V, &lt;- inv_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 110
Time: 0.017s">
<div class="time" style="width: 0.65084226646248%"></div>
<pre>
      rewrite &lt;- (inv_V (O_functor_compose _ _ _ _)), &lt;- inv_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 111
Time: 0.004s">
<div class="time" style="width: 0.1531393568147%"></div>
<pre>
      apply inverse2, to_O_natural_compose.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 112
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      Close Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 113
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** By contrast, this goal, which seems to contain all the mathematical content, is solved fairly easily by [hfiber_functor_pullback] and typeclass magic invoking [isconnected_pullback]. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 115
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 115
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre> intros [ob [oc oe]].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 115
Time: 2.612s">
<div class="time" style="width: 100%"></div>
<pre>
      refine (isconnected_equiv O _
                (hfiber_functor_pullback _ _ _ _ _ _ _ _ _ _)^-1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 117
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 118
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 6. The reflector preserves fibers.  This is a slightly simpler version of the previous. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 121
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>Global Instance isequiv_O_functor_hfiber (O : Modality) `{Lex O}
             {A B} (f : A -&gt; B) (b : B)
  : IsEquiv (O_functor_hfiber O f b).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 123
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 124
Time: 0.221s">
<div class="time" style="width: 8.4609494640123%"></div>
<pre>
    refine (isequiv_O_inverts O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 125
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply O_inverts_conn_map.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 126
Time: 0.324s">
<div class="time" style="width: 12.404287901991%"></div>
<pre>
    refine (cancelR_conn_map O (to O _) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 127
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold O_functor_hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 128
Time: 0.164s">
<div class="time" style="width: 6.2787136294028%"></div>
<pre>
    refine (conn_map_homotopic O
             (@functor_hfiber _ _ _ _ f (O_functor O f)
                               (to O A) (to O B)
                               (fun x =&gt; (to_O_natural O f x)^) b)
             _ _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 133
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 134
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre> intros [a p].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 134
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>
      rewrite O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 135
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold functor_hfiber, functor_sigma.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 136
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> apply ap.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 136
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
      apply whiskerR, inv_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 137
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 138
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre> intros [oa p].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 138
Time: 0.46s">
<div class="time" style="width: 17.611026033691%"></div>
<pre>
      refine (isconnected_equiv O _
               (hfiber_functor_hfiber _ _ _ _)^-1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 140
Time: 0.017s">
<div class="time" style="width: 0.65084226646248%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 141
Time: 0.012s">
<div class="time" style="width: 0.4594180704441%"></div>
<pre>

  Definition equiv_O_functor_hfiber (O : Modality) `{Lex O}
             {A B} (f : A -&gt; B) (b : B)
  : O (hfiber f b) &lt;~&gt; hfiber (O_functor O f) (to O B b)
    := BuildEquiv _ _ (O_functor_hfiber O f b) _.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 146
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 7. Lex modalities preserve path-spaces. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 149
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>Definition O_path_cmp (O : Modality) {A} (x y : A)
  : O (x = y) -&gt; (to O A x = to O A y)
    := O_rec (ap (to O A)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 151
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Global Instance isequiv_O_path_cmp {O : Modality} `{Lex O} {A} (x y : A)
  : IsEquiv (O_path_cmp O x y).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 154
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 155
Time: 0.099s">
<div class="time" style="width: 3.7901990811639%"></div>
<pre>
    refine (isequiv_conn_ino_map O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 156
Time: 0.267s">
<div class="time" style="width: 10.222052067381%"></div>
<pre>
    refine (cancelR_conn_map O (to O (x = y)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 157
Time: 0.039s">
<div class="time" style="width: 1.4931087289433%"></div>
<pre>
    refine (conn_map_homotopic O (ap (to O A)) _ _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 158
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 159
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre> intros ?; symmetry; by apply O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 159
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 160
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 160
Time: 0.364s">
<div class="time" style="width: 13.935681470138%"></div>
<pre>
      refine (isconnected_equiv O _ (hfiber_ap p)^-1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 161
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 162
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 8. Any modal map between connected types is an equivalence. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 165
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>Global Instance isequiv_ismodal_isconnected_types
         {O : Modality} `{Lex O} {A B} {f : A -&gt; B}
         `{IsConnected O A} `{IsConnected O B} `{MapIn O _ _ f}
    : IsEquiv f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 168
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 169
Time: 0.005s">
<div class="time" style="width: 0.19142419601838%"></div>
<pre>
    apply (isequiv_conn_ino_map O); exact _.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 170
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 171
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Definition lex_from_isequiv_ismodal_isconnected_types
             {O : Modality}
             (H : forall A B (f : A -&gt; B),
                         (IsConnected O A) -&gt; (IsConnected O B) -&gt; 
                         (MapIn O f) -&gt; IsEquiv f)
    : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 178
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 179
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply lex_from_conn_map_lex.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 180
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A B f AC BC.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 181
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply (conn_map_homotopic O _ _ (fact_factors (image O f))).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 182
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
    apply conn_map_compose; [ exact _ | ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 183
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply conn_map_isequiv.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 184
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply H; [ | exact _ | exact _ ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 185
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply isconnected_conn_map_to_unit.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 186
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>
    apply (cancelR_conn_map O (factor1 (image O f)) (const tt)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 187
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 188
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 9. Any commutative square with connected maps in one direction and modal ones in the other must necessarily be a pullback. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 191
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>Definition ispullback_connmap_mapino_commsq (O : Modality) `{Lex O} {A B C D}
             {f : A -&gt; B} {g : C -&gt; D} {h : A -&gt; C} {k : B -&gt; D}
             `{IsConnMap O _ _ f} `{IsConnMap O _ _ g}
             `{MapIn O _ _ h} `{MapIn O _ _ k}
             (p : k o f == g o h)
  : IsPullback p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 196
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 197
Time: 0.039s">
<div class="time" style="width: 1.4931087289433%"></div>
<pre>
    refine (isequiv_conn_ino_map O (pullback_corec p)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 198
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 199
Time: 0.015s">
<div class="time" style="width: 0.57427258805513%"></div>
<pre> refine (cancelL_conn_map O (pullback_corec p) (k^* g) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 199
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 200
Time: 0.127s">
<div class="time" style="width: 4.8621745788668%"></div>
<pre> refine (cancelL_mapinO O _ (equiv_pullback_symm k g) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 200
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>
      refine (cancelL_mapinO O _ (g^* k) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 201
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 202
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>

  Definition lex_from_ispullback_connmap_mapino_commsq (O : Modality)
             (H : forall {A B C D}
                         (f : A -&gt; B) (g : C -&gt; D) (h : A -&gt; C) (k : B -&gt; D),
                 (IsConnMap O f) -&gt; (IsConnMap O g) -&gt;
                 (MapIn O h) -&gt; (MapIn O k) -&gt;
                 forall (p : k o f == g o h), IsPullback p)
    : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 210
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 211
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply lex_from_isequiv_ismodal_isconnected_types.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 212
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A B f AC BC fM.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 213
Time: 0.004s">
<div class="time" style="width: 0.1531393568147%"></div>
<pre>
    specialize (H A Unit B Unit (const tt) (const tt) f idmap _ _ _ _
               (fun _ =&gt; 1)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 215
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold IsPullback, pullback_corec in H.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 216
Time: 0.015s">
<div class="time" style="width: 0.57427258805513%"></div>
<pre>
    refine (@isequiv_compose _ _ _ H _ (fun x =&gt; x.2.1) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 217
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold Pullback.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 218
Time: 0.053s">
<div class="time" style="width: 2.0290964777948%"></div>
<pre>
    refine (@isequiv_compose _ {b:Unit &amp; B}
                             (functor_sigma idmap (fun a =&gt; pr1))
                             _ _ pr2 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 221
Time: 0.012s">
<div class="time" style="width: 0.4594180704441%"></div>
<pre>
    refine (@isequiv_compose _ _ (equiv_sigma_prod0 Unit B)
                             _ _ snd _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 223
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply (equiv_isequiv (prod_unit_l B)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 224
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 225
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 10. Families of modal types indexed by connected types are constant. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 228
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>Definition modal_over_connected_isconst_lex (O : Modality) `{Lex O}
             (A : Type) `{IsConnected O A} (P : A -&gt; Type) `{forall x, In O (P x)}
    : {Q : Type &amp; In O Q * forall x, P x &lt;~&gt; Q}.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 230
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 231
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
    exists (O {x:A &amp; P x}); split; [ exact _ | intros x].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 232
Time: 0.039s">
<div class="time" style="width: 1.4931087289433%"></div>
<pre>
    refine (BuildEquiv _ _ (fun p =&gt; to O _ (x ; p)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 233
Time: 0.041s">
<div class="time" style="width: 1.5696784073507%"></div>
<pre>
    refine (isequiv_conn_map_ino O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 234
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    revert x.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 235
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply conn_map_fiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 236
Time: 0.068s">
<div class="time" style="width: 2.6033690658499%"></div>
<pre>
    refine (cancelL_conn_map O _ (fun z:{x:A &amp; O {x : A &amp; P x}} =&gt; z.2) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 237
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros z.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 238
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    refine (isconnected_equiv' O A _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 239
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 240
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
    refine (equiv_adjointify (fun x =&gt; ((x ; z) ; 1))
                             (fun y =&gt; y.1.1) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 242
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> 
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 243
Time: 0.006s">
<div class="time" style="width: 0.22970903522205%"></div>
<pre> intros [[x y] []]; reflexivity.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 243
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 244
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros x; reflexivity.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 244
Time: 0.007s">
<div class="time" style="width: 0.26799387442573%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 245
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** And conversely. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 248
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>Definition lex_from_modal_over_connected_isconst (O : Modality)
             (H : forall (A : Type) (P : A -&gt; Type),
                 (IsConnected O A) -&gt; (forall x, In O (P x)) -&gt;
                 {Q : Type &amp; In O Q * forall x, P x &lt;~&gt; Q})
    : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 252
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 253
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A x y ?.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 254
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply isconnected_from_elim_to_O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 255
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** By assumption, [fun y =&gt; O (x = y) : A -&gt; Type_ O] is constant.  Thus, [to O (x=x) 1] can be transported around to make it contractible everywhere. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 257
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>specialize (H A (fun z =&gt; O (x = z)) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 257
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
    destruct H as [Q [? H]].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 258
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold NullHomotopy.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 259
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>
    exists ((H y)^-1 ((H x) (to O _ 1))).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 260
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros [].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 261
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
    symmetry; apply eissect.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 262
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 263
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Lex modalities preserve [n]-types for all [n].  This is definitely not equivalent to lex-ness, since it is true for the truncation modalities that are not lex.  But it is also not true of all modalities; e.g. the shape modality in a cohesive topos can take 0-types to [oo]-types. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 266
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance istrunc_O_lex `{Funext} {O : Modality} `{Lex O}
         {n} {A} `{IsTrunc n A}
  : IsTrunc n (O A).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 268
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 269
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    generalize dependent A; simple_induction n n IHn; intros A ?.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 270
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 271
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre> exact _.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 271
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>               (** Already proven for all modalities. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 272
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 272
Time: 0.021s">
<div class="time" style="width: 0.80398162327718%"></div>
<pre> refine (O_ind (fun x =&gt; forall y, IsTrunc n (x = y)) _); intros x.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 272
Time: 0.007s">
<div class="time" style="width: 0.26799387442573%"></div>
<pre>
      refine (O_ind (fun y =&gt; IsTrunc n (to O A x = y)) _); intros y.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 273
Time: 0.006s">
<div class="time" style="width: 0.22970903522205%"></div>
<pre>
      refine (trunc_equiv _ (O_path_cmp O x y)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 274
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 275
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Lex_Modalities_Theory.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 277
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Lex reflective subuniverses *)

(** A reflective subuniverse that preserves fibers is in fact a modality (and hence lex). *)</pre>
</div>
<div class="code" title="File: Lex.v
Line: 281
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Module Type Preserves_Fibers (Os : ReflectiveSubuniverses).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 281
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Export Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 283
Time: 0.059s">
<div class="time" style="width: 2.2588055130168%"></div>
<pre>
  Module Export Os_Theory := ReflectiveSubuniverses_Theory Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 284
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>

  Parameter isequiv_O_functor_hfiber :
     forall (O : ReflectiveSubuniverse) {A B} (f : A -&gt; B) (b : B),
       IsEquiv (O_functor_hfiber O f b).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 288
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Existing Instance isequiv_O_functor_hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 289
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Preserves_Fibers.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 291
Time: 0.015s">
<div class="time" style="width: 0.57427258805513%"></div>
<pre>

Module Lex_Reflective_Subuniverses
       (Os : ReflectiveSubuniverses) (Opf : Preserves_Fibers Os)
  &lt;: SigmaClosed Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 295
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>

  Import Opf.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 297
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Definition inO_sigma@{u a i j k} (O : ReflectiveSubuniverse@{u a})
             (A:Type@{i}) (B:A -&gt; Type@{j})
             (A_inO : In@{u a i} O A)
             (B_inO : forall a, In@{u a j} O (B a))
  : In@{u a k} O {x:A &amp; B x}.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 303
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 304
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    pose (g := O_rec@{u a k i k k i} pr1 : O {x : A &amp; B x} -&gt; A).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 305
Time: 0.005s">
<div class="time" style="width: 0.19142419601838%"></div>
<pre>
    transparent assert (p : (forall x, g (to O _ x) = x.1)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 306
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    {</pre>
</div>
<div class="code" title="File: Lex.v
Line: 307
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros x; subst g; apply O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 307
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Lex.v
Line: 307
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply inO_isequiv_to_O@{u a k k}.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 308
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply isequiv_fcontr; intros x.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 309
Time: 0.054s">
<div class="time" style="width: 2.0673813169985%"></div>
<pre>
    refine (contr_equiv' _ (hfiber_hfiber_compose_map@{k k i k k k k k} _ g x)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 310
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply fcontr_isequiv.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 311
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold hfiber_compose_map.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 312
Time: 0.021s">
<div class="time" style="width: 0.80398162327718%"></div>
<pre>
    transparent assert (h : (Equiv@{k k} (hfiber@{k i} (@pr1 A B) (g x))
                                         (hfiber@{k i} g (g x)))).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 314
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    {</pre>
</div>
<div class="code" title="File: Lex.v
Line: 315
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre> refine (_ oE equiv_to_O@{u a k k} O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 315
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
      refine (_ oE BuildEquiv _ _
                (O_functor_hfiber O (@pr1 A B) (g x)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 317
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 318
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      refine (equiv_functor_sigma' 1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 319
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros y; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 319
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>
      refine (_ oE (equiv_moveR_equiv_V _ _)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 320
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      apply equiv_concat_l.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 321
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      apply moveL_equiv_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 322
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold g, O_functor.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 323
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>
      revert y; apply O_indpaths@{u a k i i k k}; intros [a q]; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 324
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      refine (_ @ (O_rec_beta _ _)^).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 325
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      apply ap, O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 326
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Lex.v
Line: 326
Time: 0.012s">
<div class="time" style="width: 0.4594180704441%"></div>
<pre>
    refine (isequiv_homotopic (h oE equiv_hfiber_homotopic _ _ p (g x)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 327
Time: 0.012s">
<div class="time" style="width: 0.4594180704441%"></div>
<pre>
    intros [[a b] q]; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 328
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> clear h.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 328
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold O_functor_hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 329
Time: 0.011s">
<div class="time" style="width: 0.42113323124043%"></div>
<pre>
    rewrite O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 330
Time: 0.007s">
<div class="time" style="width: 0.26799387442573%"></div>
<pre>
    unfold functor_sigma; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 331
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
    refine (path_sigma' _ 1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 332
Time: 0.011s">
<div class="time" style="width: 0.42113323124043%"></div>
<pre>
    rewrite O_indpaths_beta; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 333
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold moveL_equiv_V, moveR_equiv_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 334
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    Open Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 335
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    Local Opaque eissect.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 336
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* work around bug 4533 *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 337
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>set (k := @eissect); change @eissect with k; subst k.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 337
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* work around bug 4543 *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 338
Time: 0.097s">
<div class="time" style="width: 3.7136294027565%"></div>
<pre>rewrite !ap_pp, !concat_p_pp, !ap_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 338
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold to_O_natural.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 339
Time: 0.015s">
<div class="time" style="width: 0.57427258805513%"></div>
<pre>
    rewrite concat_pV_p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 340
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    subst p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 341
Time: 0.004s">
<div class="time" style="width: 0.1531393568147%"></div>
<pre>
    rewrite concat_pp_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 342
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>
    rewrite concat_pp_p; apply moveR_Vp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 343
Time: 0.006s">
<div class="time" style="width: 0.22970903522205%"></div>
<pre>
    rewrite &lt;- !(ap_compose (to O A) (to O A)^-1).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 344
Time: 0.007s">
<div class="time" style="width: 0.26799387442573%"></div>
<pre>
    rapply @concat_A1p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 345
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    Local Transparent eissect.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 346
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* work around bug 4533 *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 347
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Close Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 347
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 348
Time: 0.022s">
<div class="time" style="width: 0.84226646248086%"></div>
<pre>

End Lex_Reflective_Subuniverses.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 350
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Accessible lex modalities *)

(** We now restrict to lex modalities that are also accessible. *)</pre>
</div>
<div class="code" title="File: Lex.v
Line: 354
Time: 0.015s">
<div class="time" style="width: 0.57427258805513%"></div>
<pre>Module Accessible_Lex_Modalities_Theory
       (Os : Modalities)
       (Acc : Accessible_Modalities Os).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 356
Time: 0.146s">
<div class="time" style="width: 5.5895865237366%"></div>
<pre>

  Module Export Acc_Theory := Accessible_Modalities_Theory Os Acc.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 358
Time: 0.106s">
<div class="time" style="width: 4.0581929555896%"></div>
<pre>
  Module Export Lex_Theory := Lex_Modalities_Theory Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 359
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Unfortunately, another subtlety of modules bites us here.  It appears that each application of a parametrized module to arguments creates a *new* module, and Coq has no algorithm (not even syntactic identity) for considering two such modules "the same".  In particular, the applications [Module Os_Theory := Modalities_Theory Os] that occur in both [Accessible_Modalities_Theory Os Acc] and [Lex_Modalities_Theory Os] create two *different* modules, which appear here as [Acc_Theory.Os_Theory] and [Lex_Theory.Os_Theory].  Thus, for instance, we have two different definitions [Acc_Theory.Os_Theory.O_ind] and [Lex_Theory.Os_Theory.O_ind], etc.

  Fortunately, since these duplicate pairs of definitions each have the same body *and are (usually) transparent*, Coq is willing to consider them identical.  Thus, this doesn't cause a great deal of trouble.  However, there are certain contexts in which this doesn't apply.  For instance, if any definition in [Modalities_Theory] is opaque, then Coq will be unable to notice that its duplicate copies in [Acc_Theory.Os_Theory] and [Lex_Theory.Os_Theory] were identical, potentially causing problems.  But since we generally only make definitions opaque if we aren't going to depend on their actual value anywhere else, this is unlikely to be much of an issue.

  A more serious issue is that there are some declarations that function up to a syntactic equality that is stricter than judgmental conversion.  For instance, [Inductive] and [Record] definitions, like modules, always create a new object not convertible to any previously existing one.  There are no [Inductive] or [Record] definitions in [Modalities_Theory], but there are [Class] declarations, and these function similarly.  In particular, typeclass search is unable to use [Instance]s defined in [Acc_Theory] to instantiate typeclasses from [Modalities_Theory] (such as [IsConnected]) needed by functions in [Lex_Theory], and vice versa.

  Fortunately, all the typeclasses defined in [Modalities_Theory] are *singleton* or *definitional* classes (defined with `:= unique_field` rather than `{ field1 ; field2 ; ... }`), which means that they do not actually introduce a new record wrapper.  Thus, the [Instance]s from [Acc_Theory] can in fact be typechecked to *belong* to the typeclasses needed by [Lex_Theory], and hence can be supplied explicitly.

  We can also do this once and for all by defining [Instance]s translating automatically between the two typeclasses, although unfortunately we probably can't declare such instances in both directions at once for fear of infinite loops.  Fortunately, there is not a lot in [Acc_Theory], so this direction seems likely to be the most useful. *)

 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 371
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance isconnected_acc_to_lex {O : Modality} {A : Type}
         {H : Acc_Theory.Os_Theory.RSU.IsConnected O A}
            : Lex_Theory.Os_Theory.RSU.IsConnected O A
         := H.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 374
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Probably the most important thing about an accessible lex modality is that the universe of modal types is again modal.  Here by "the universe" we mean a universe large enough to contain the generating family; this is why we need accessibility. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 377
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance inO_typeO `{Univalence} (O : Modality) `{Lex O}
  : In O (Type_ O).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 378
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 379
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply (snd (inO_iff_isnull O _)); intros i n; simpl in *.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 380
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    destruct n; [ exact tt | split ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 381
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 382
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros P.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 382
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** The case [n=0] is basically just one of the above characterizations of lex-ness. *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 384
Time: 0.006s">
<div class="time" style="width: 0.22970903522205%"></div>
<pre>destruct (modal_over_connected_isconst_lex O (acc_gen O i) P)
        as [Q [QinO f]].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 385
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      exists (fun _ =&gt; (Q ; QinO)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 386
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>
      intros x; symmetry; apply path_TypeO.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 387
Time: 0.004s">
<div class="time" style="width: 0.1531393568147%"></div>
<pre> 
      refine (path_universe (f x)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 388
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 389
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros A B.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 389
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** The case [n&gt;0] is actually quite easy, using univalence and the fact that modal types are closed under [Equiv]. *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 391
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>refine (extendable_postcompose' n _ _ _
                (fun b =&gt; (equiv_path_TypeO O (A b) (B b))
                            oE (equiv_path_universe (A b) (B b)))
                _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 394
Time: 0.018s">
<div class="time" style="width: 0.68912710566616%"></div>
<pre>
      refine (extendable_conn_map_inO O n (@const (acc_gen O i) Unit tt)
                                      (fun b =&gt; A b &lt;~&gt; B b)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 396
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** Typeclass magic! *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 398
Time: 0.003s">
<div class="time" style="width: 0.11485451761103%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 398
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** [inO_typeO] is also an equivalent characterization of lex-ness for a modality, by the converse of the characterization of lex-ness we used above. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 401
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition lex_inO_typeO (O : Modality) `{In O (Type_ O)}
  : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 402
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 403
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply lex_from_modal_over_connected_isconst.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 404
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A P ? PO.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 405
Time: 0.002s">
<div class="time" style="width: 0.076569678407351%"></div>
<pre>
    destruct (isconnected_elim O (Type_ O) (fun x =&gt; (P x ; PO x)))
      as [Q f].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 407
Time: 0.001s">
<div class="time" style="width: 0.038284839203675%"></div>
<pre>
    exists Q; split; [ exact _ | intros x ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 408
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply equiv_path.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 409
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> 
    exact (ap pr1 (f x)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 410
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 411
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Accessible_Lex_Modalities_Theory.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 414
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>


<html>
<head>
<title>orders.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for orders.v</h1>

<div class="code" title="File: orders.v
Line: 1
Time: 0.445s">
<div class="time" style="width: 100%"></div>
<pre>Require Import HoTT.Classes.interfaces.abstract_algebra.</pre>
</div>
<div class="code" title="File: orders.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(*
In this file we describe interfaces for ordered structures. Since we are in a
constructive setting we use a pseudo order instead of a total order. Therefore
we also have to include an apartness relation.

Obviously, in case we consider decidable structures these interfaces are quite
inconvenient. Hence we will, later on, provide means to go back and forth
between the usual classical notions and these constructive notions.

On the one hand, if we have an ordinary (total) partial order (≤) with a
corresponding strict order (&lt;), we will prove that we can construct a
FullPartialOrder and PseudoPartialOrder, respectively.

On the other hand, if equality is decidable, we will prove that we have the
usual properties like Trichotomy (&lt;) and TotalRelation (≤).
*)

</pre>
</div>
<div class="code" title="File: orders.v
Line: 19
Time: 0.003s">
<div class="time" style="width: 0.67415730337079%"></div>
<pre>Class PartialOrder `(Ale : Le A) :=
  { po_hset :&gt; IsHSet A
  ; po_hprop :&gt; is_mere_relation A Ale
  ; po_preorder:&gt; PreOrder (≤)
  ; po_antisym:&gt; AntiSymmetric (≤) }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 23
Time: 0.002s">
<div class="time" style="width: 0.44943820224719%"></div>
<pre>

Class TotalOrder `(Ale : Le A) :=
  { total_order_po :&gt; PartialOrder (≤)
  ; total_order_total :&gt; TotalRelation (≤) }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 27
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(*
We define a variant of the order theoretic definition of meet and join
semilattices. Notice that we include a meet operation instead of the
more common:
  forall x y, exists m, m ≤ x /\ m ≤ y /\ forall z, z ≤ x -&gt; z ≤ y -&gt; m ≤ z
Our definition is both stronger and more convenient than the above.
This is needed to prove equavalence with the algebraic definition. We
do this in orders.lattices.
*)</pre>
</div>
<div class="code" title="File: orders.v
Line: 37
Time: 0.005s">
<div class="time" style="width: 1.123595505618%"></div>
<pre>Class MeetSemiLatticeOrder `(Ale : Le A) `{Meet A} :=
  { meet_sl_order :&gt; PartialOrder (≤)
  ; meet_lb_l : forall x y, x ⊓ y ≤ x
  ; meet_lb_r : forall x y, x ⊓ y ≤ y
  ; meet_glb : forall x y z, z ≤ x -&gt; z ≤ y -&gt; z ≤ x ⊓ y }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 41
Time: 0.006s">
<div class="time" style="width: 1.3483146067416%"></div>
<pre>

Class JoinSemiLatticeOrder `(Ale : Le A) `{Join A} :=
  { join_sl_order :&gt; PartialOrder (≤)
  ; join_ub_l : forall x y, x ≤ x ⊔ y
  ; join_ub_r : forall x y, y ≤ x ⊔ y
  ; join_lub : forall x y z, x ≤ z -&gt; y ≤ z -&gt; x ⊔ y ≤ z }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 47
Time: 0.002s">
<div class="time" style="width: 0.44943820224719%"></div>
<pre>

Class LatticeOrder `(Ale : Le A) `{Meet A} `{Join A} :=
  { lattice_order_meet :&gt; MeetSemiLatticeOrder (≤)
  ; lattice_order_join :&gt; JoinSemiLatticeOrder (≤) }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 51
Time: 0.002s">
<div class="time" style="width: 0.44943820224719%"></div>
<pre>

Class StrictOrder `(Alt : Lt A) :=
  { strict_order_mere :&gt; is_mere_relation A lt
  ; strictorder_irrefl :&gt; Irreflexive (&lt;)
  ; strictorder_trans :&gt; Transitive (&lt;) }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 56
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* The constructive notion of a total strict total order.
   We will prove that (&lt;) is in fact a StrictOrder. *)</pre>
</div>
<div class="code" title="File: orders.v
Line: 59
Time: 0.007s">
<div class="time" style="width: 1.5730337078652%"></div>
<pre>Class PseudoOrder `{Aap : Apart A} (Alt : Lt A) :=
  { pseudo_order_apart : IsApart A
  ; pseudo_order_mere_lt :&gt; is_mere_relation A lt
  ; pseudo_order_antisym : forall x y, ~(x &lt; y /\ y &lt; x)
  ; pseudo_order_cotrans :&gt; CoTransitive (&lt;)
  ; apart_iff_total_lt : forall x y, x ≶ y &lt;-&gt; x &lt; y \/ y &lt; x }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 64
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* A partial order (≤) with a corresponding (&lt;). We will prove that (&lt;) is in fact
  a StrictOrder *)</pre>
</div>
<div class="code" title="File: orders.v
Line: 67
Time: 0.007s">
<div class="time" style="width: 1.5730337078652%"></div>
<pre>Class FullPartialOrder `{Aap : Apart A} (Ale : Le A) (Alt : Lt A) :=
  { strict_po_apart : IsApart A
  ; strict_po_mere_lt : is_mere_relation A lt
  ; strict_po_po :&gt; PartialOrder (≤)
  ; strict_po_trans :&gt; Transitive (&lt;)
  ; lt_iff_le_apart : forall x y, x &lt; y &lt;-&gt; x ≤ y /\ x ≶ y }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 72
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* A pseudo order (&lt;) with a corresponding (≤). We will prove that (≤) is in fact
  a PartialOrder. *)</pre>
</div>
<div class="code" title="File: orders.v
Line: 75
Time: 0.004s">
<div class="time" style="width: 0.89887640449438%"></div>
<pre>Class FullPseudoOrder `{Aap : Apart A} (Ale : Le A) (Alt : Lt A) :=
  { fullpseudo_le_hprop :&gt; is_mere_relation A Ale
  ; full_pseudo_order_pseudo :&gt; PseudoOrder Alt
  ; le_iff_not_lt_flip : forall x y, x ≤ y &lt;-&gt; ~y &lt; x }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 78
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Section order_maps.</pre>
</div>
<div class="code" title="File: orders.v
Line: 80
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Context {A B : Type} {Ale: Le A} {Ble: Le B}(f : A -&gt; B).</pre>
</div>
<div class="code" title="File: orders.v
Line: 81
Time: 0.003s">
<div class="time" style="width: 0.67415730337079%"></div>
<pre>

  Class OrderPreserving := order_preserving : forall x y, (x ≤ y -&gt; f x ≤ f y).</pre>
</div>
<div class="code" title="File: orders.v
Line: 83
Time: 0.003s">
<div class="time" style="width: 0.67415730337079%"></div>
<pre>

  Class OrderReflecting := order_reflecting : forall x y, (f x ≤ f y -&gt; x ≤ y).</pre>
</div>
<div class="code" title="File: orders.v
Line: 85
Time: 0.001s">
<div class="time" style="width: 0.2247191011236%"></div>
<pre>

  Class OrderEmbedding :=
    { order_embedding_preserving :&gt; OrderPreserving
    ; order_embedding_reflecting :&gt; OrderReflecting }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 89
Time: 0.006s">
<div class="time" style="width: 1.3483146067416%"></div>
<pre>
End order_maps.</pre>
</div>
<div class="code" title="File: orders.v
Line: 90
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Section srorder_maps.</pre>
</div>
<div class="code" title="File: orders.v
Line: 92
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Context {A B : Type} {Alt: Lt A} {Blt: Lt B} (f : A -&gt; B).</pre>
</div>
<div class="code" title="File: orders.v
Line: 93
Time: 0.003s">
<div class="time" style="width: 0.67415730337079%"></div>
<pre>

  Class StrictlyOrderPreserving := strictly_order_preserving
    : forall x y, (x &lt; y -&gt; f x &lt; f y).</pre>
</div>
<div class="code" title="File: orders.v
Line: 96
Time: 0.003s">
<div class="time" style="width: 0.67415730337079%"></div>
<pre>

  Class StrictlyOrderReflecting := strictly_order_reflecting
    : forall x y, (f x &lt; f y -&gt; x &lt; y).</pre>
</div>
<div class="code" title="File: orders.v
Line: 99
Time: 0.001s">
<div class="time" style="width: 0.2247191011236%"></div>
<pre>

  Class StrictOrderEmbedding :=
    { strict_order_embedding_preserving :&gt; StrictlyOrderPreserving
    ; strict_order_embedding_reflecting :&gt; StrictlyOrderReflecting }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 103
Time: 0.006s">
<div class="time" style="width: 1.3483146067416%"></div>
<pre>
End srorder_maps.</pre>
</div>
<div class="code" title="File: orders.v
Line: 104
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Hint Extern 4 (?f _ ≤ ?f _) =&gt; apply (order_preserving f).</pre>
</div>
<div class="code" title="File: orders.v
Line: 106
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Hint Extern 4 (?f _ &lt; ?f _) =&gt; apply (strictly_order_preserving f).</pre>
</div>
<div class="code" title="File: orders.v
Line: 107
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(*
We define various classes to describe the order on the lower part of the
algebraic hierarchy. This results in the notion of a PseudoSemiRingOrder, which
specifies the order on the naturals, integers, rationals and reals. This notion
is quite similar to a strictly linearly ordered unital commutative protoring in
Davorin Lešnik's PhD thesis.
*)</pre>
</div>
<div class="code" title="File: orders.v
Line: 115
Time: 0.009s">
<div class="time" style="width: 2.0224719101124%"></div>
<pre>Class SemiRingOrder `{Plus A} `{Mult A}
    `{Zero A} `{One A} (Ale : Le A) :=
  { srorder_po :&gt; PartialOrder Ale
  ; srorder_partial_minus : forall x y, x ≤ y -&gt; exists z, y = x + z
  ; srorder_plus :&gt; forall z, OrderEmbedding (z +)
  ; nonneg_mult_compat : forall x y, PropHolds (0 ≤ x) -&gt; PropHolds (0 ≤ y) -&gt;
                                PropHolds (0 ≤ x * y) }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 121
Time: 0.009s">
<div class="time" style="width: 2.0224719101124%"></div>
<pre>

Class StrictSemiRingOrder `{Plus A} `{Mult A}
    `{Zero A} `{One A} (Alt : Lt A) :=
  { strict_srorder_so :&gt; StrictOrder Alt
  ; strict_srorder_partial_minus : forall x y, x &lt; y -&gt; exists z, y = x + z
  ; strict_srorder_plus :&gt; forall z, StrictOrderEmbedding (z +)
  ; pos_mult_compat : forall x y, PropHolds (0 &lt; x) -&gt; PropHolds (0 &lt; y) -&gt;
                             PropHolds (0 &lt; x * y) }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 129
Time: 0.014s">
<div class="time" style="width: 3.1460674157303%"></div>
<pre>

Class PseudoSemiRingOrder `{Apart A} `{Plus A}
    `{Mult A} `{Zero A} `{One A} (Alt : Lt A) :=
  { pseudo_srorder_strict :&gt; PseudoOrder Alt
  ; pseudo_srorder_partial_minus : forall x y, ~y &lt; x -&gt; exists z, y = x + z
  ; pseudo_srorder_plus :&gt; forall z, StrictOrderEmbedding (z +)
  ; pseudo_srorder_mult_ext :&gt; StrongBinaryExtensionality (.*.)
  ; pseudo_srorder_pos_mult_compat : forall x y, PropHolds (0 &lt; x) -&gt; PropHolds (0 &lt; y) -&gt;
                                            PropHolds (0 &lt; x * y) }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 138
Time: 0.006s">
<div class="time" style="width: 1.3483146067416%"></div>
<pre>

Class FullPseudoSemiRingOrder `{Apart A} `{Plus A}
    `{Mult A} `{Zero A} `{One A} (Ale : Le A) (Alt : Lt A) :=
  { full_pseudo_srorder_le_hprop :&gt; is_mere_relation A Ale
  ; full_pseudo_srorder_pso :&gt; PseudoSemiRingOrder Alt
  ; full_pseudo_srorder_le_iff_not_lt_flip : forall x y, x ≤ y &lt;-&gt; ~y &lt; x }.</pre>
</div>
<div class="code" title="File: orders.v
Line: 144
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* Due to bug #2528 *)</pre>
</div>
<div class="code" title="File: orders.v
Line: 146
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Hint Extern 7 (PropHolds (0 &lt; _ * _)) =&gt;
  eapply @pos_mult_compat : typeclass_instances.</pre>
</div>
<div class="code" title="File: orders.v
Line: 147
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Hint Extern 7 (PropHolds (0 ≤ _ * _)) =&gt;
  eapply @nonneg_mult_compat : typeclass_instances.</pre>
</div>
<div class="code" title="File: orders.v
Line: 150
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(*
Alternatively, we could have defined the standard notion of a RingOrder:

Class RingOrder `{Equiv A} `{Plus A} `{Mult A} `{Zero A} (Ale : Le A) :=
  { ringorder_po :&gt; PartialOrder Ale
  ; ringorder_plus :&gt; forall z, OrderPreserving (z +)
  ; ringorder_mult : forall x y, 0 ≤ x -&gt; 0 ≤ y -&gt; 0 ≤ x * y }.

Unfortunately, this notion is too weak when we consider semirings (e.g. the
naturals). Moreover, in case of rings, we prove that this notion is equivalent
to our SemiRingOrder class (see orders.rings.from_ring_order). Hence we omit
defining such a class.

Similarly we prove that a FullSemiRingOrder
and a FullPseudoRingOrder are equivalent.

Class FullPseudoRingOrder `{Apart A} `{Plus A}
    `{Mult A} `{Zero A} (Ale : Le A) (Alt : Lt A) :=
  { pseudo_ringorder_spo :&gt; FullPseudoOrder Ale Alt
  ; pseudo_ringorder_mult_ext :&gt; StrongSetoid_BinaryMorphism (.*.)
  ; pseudo_ringorder_plus :&gt; forall z, StrictlyOrderPreserving (z +)
  ; pseudo_ringorder_mult : forall x y, 0 &lt; x -&gt; 0 &lt; y -&gt; 0 &lt; x * y }.
*)

</pre>
</div>
</body>
</html>


<html>
<head>
<title>Equiv.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Equiv.v</h1>

<div class="code" title="File: Equiv.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*- *)

</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 2
Time: 0.024s">
<div class="time" style="width: 7.5%"></div>
<pre>Require Import HoTT.Basics.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 2
Time: 0.016s">
<div class="time" style="width: 5%"></div>
<pre>
Require Import Types.Prod Types.Sigma Types.Forall Types.Arrow Types.Paths Types.Record.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 3
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 5
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** * Equivalences *)

</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 8
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Section AssumeFunext.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 8
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Context `{Funext}.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 9
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** We begin by showing that, assuming function extensionality, [IsEquiv f] is an hprop. *)
 </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 12
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance hprop_isequiv {A B} `(f : A -&gt; B)
  : IsHProp (IsEquiv f).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 13
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 14
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply hprop_inhabited_contr; intros feq.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 15
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (* We will show that if [IsEquiv] is inhabited, then it is contractible, because it is equivalent to a sigma of a pointed path-space over a pointed path-space, both of which are contractible. *)
   </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 17
Time: 0.015s">
<div class="time" style="width: 4.6875%"></div>
<pre>refine (contr_equiv' { g : B -&gt; A &amp; g = f^-1 } _).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 17
Time: 0.005s">
<div class="time" style="width: 1.5625%"></div>
<pre>
    equiv_via ({ g:B-&gt;A &amp; { r:g=f^-1 &amp; { s:g=f^-1 &amp; r=s }}}); apply equiv_inverse.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 18
Time: 0.056s">
<div class="time" style="width: 17.5%"></div>
<pre>
    1:exact (equiv_functor_sigma' 1 (fun _ =&gt; equiv_sigma_contr _ )).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 19
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (* First we apply [issig], peel off the first component, and convert to pointwise paths. *)
   </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 21
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre>refine (_ oE (issig_isequiv f)^-1).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 21
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre>
    refine (equiv_functor_sigma' (equiv_idmap (B -&gt; A)) _); intros g; simpl.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 22
Time: 0.002s">
<div class="time" style="width: 0.625%"></div>
<pre>
    equiv_via ({ r : g == f^-1 &amp; { s : g == f^-1 &amp; r == s }}).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (* Now the idea is that if [f] is an equivalence, then [g f == 1] and [f g == 1] are both equivalent to [g == f^-1]. *)
   </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 25
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>{</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 25
Time: 0.32s">
<div class="time" style="width: 100%"></div>
<pre> refine (equiv_functor_sigma'
                (equiv_functor_forall idmap (fun b p =&gt; (ap f)^-1 (p @ (eisretr f b)^)))
                (fun r =&gt; equiv_functor_sigma'
                            (equiv_functor_forall f (fun a p =&gt; p @ (eissect f a)))^-1 _));
      intros s; simpl.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 29
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (* What remains is to show that under these equivalences, the remaining datum [eisadj] reduces simply to [r == s].  Pleasingly, Coq can compute for us exactly what this means. *)
     </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 31
Time: 0.003s">
<div class="time" style="width: 0.9375%"></div>
<pre>apply equiv_inverse;
        refine (equiv_functor_forall' (BuildEquiv _ _ f _) _);
        intros a; simpl; unfold functor_forall.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 33
Time: 0.004s">
<div class="time" style="width: 1.25%"></div>
<pre>
      rewrite transport_paths_FlFr.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 34
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (* At this point it's just naturality wrangling, potentially automatable.  It's a little unusual because what we have to prove is not just the existence of some path, but that one path-type is equivalent to another one, but we can mostly still use [rewrite]. *)
     </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 36
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Open Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 36
Time: 0.059s">
<div class="time" style="width: 18.4375%"></div>
<pre>
      rewrite ap_pp, !concat_p_pp, eisadj, &lt;- !ap_V, &lt;- !ap_compose.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 37
Time: 0.005s">
<div class="time" style="width: 1.5625%"></div>
<pre>
      rewrite (concat_pA1_p (eissect f) (eissect f a)^).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 38
Time: 0.005s">
<div class="time" style="width: 1.5625%"></div>
<pre>
      rewrite (concat_A1p s (eissect f a)^).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 39
Time: 0.007s">
<div class="time" style="width: 2.1875%"></div>
<pre>
      rewrite (concat_pp_A1 (fun x =&gt; (eissect f x)^) (eissect f a)).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 40
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (* Here instead of [whiskerR] we have to be a bit fancier. *)
     </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 42
Time: 0.005s">
<div class="time" style="width: 1.5625%"></div>
<pre>refine (_ oE (equiv_ap (equiv_concat_r (eissect f a)^ _) _ _)^-1).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 42
Time: 0.003s">
<div class="time" style="width: 0.9375%"></div>
<pre>
      rewrite concat_pV_p.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 43
Time: 0.038s">
<div class="time" style="width: 11.875%"></div>
<pre>
      refine (_ oE equiv_ap (ap f) _ _).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 44
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (* Now we can get rid of the [&lt;~&gt;] and reduce the question to constructing some path. *)
     </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 46
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>apply equiv_concat_l.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 46
Time: 0.027s">
<div class="time" style="width: 8.4375%"></div>
<pre>
      rewrite !ap_pp, !ap_V, &lt;- !eisadj, &lt;- ap_compose.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 47
Time: 0.01s">
<div class="time" style="width: 3.125%"></div>
<pre>
      rewrite_moveL_Vp_p.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 48
Time: 0.002s">
<div class="time" style="width: 0.625%"></div>
<pre>
      symmetry; exact (concat_A1p (eisretr f) (r (f a))).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 49
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      Close Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 50
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 50
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (* The leftover goal is just nested applications of funext. *)
   </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 52
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>{</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 52
Time: 0.004s">
<div class="time" style="width: 1.25%"></div>
<pre> refine (equiv_functor_sigma' (equiv_path_arrow g f^-1)
                                   (fun r =&gt; equiv_functor_sigma' (equiv_path_arrow g f^-1) _));
      intros s; simpl.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 54
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre>
      refine (_ oE equiv_path_forall r s).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 55
Time: 0.002s">
<div class="time" style="width: 0.625%"></div>
<pre>
      exact (equiv_ap (path_forall g f^-1) r s).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 56
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 56
Time: 0.035s">
<div class="time" style="width: 10.9375%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 57
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Thus, paths of equivalences are equivalent to paths of functions. *)
 </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 60
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Lemma equiv_path_equiv {A B : Type} (e1 e2 : A &lt;~&gt; B)
  : (e1 = e2 :&gt; (A -&gt; B)) &lt;~&gt; (e1 = e2 :&gt; (A &lt;~&gt; B)).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 61
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 62
Time: 0.002s">
<div class="time" style="width: 0.625%"></div>
<pre>
    equiv_via ((issig_equiv A B) ^-1 e1 = (issig_equiv A B) ^-1 e2).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 63
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre>
    2: symmetry; apply equiv_ap; refine _.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 64
Time: 0.004s">
<div class="time" style="width: 1.25%"></div>
<pre>
    exact (equiv_path_sigma_hprop ((issig_equiv A B)^-1 e1) ((issig_equiv A B)^-1 e2)).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 65
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 66
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre>

  Definition path_equiv {A B : Type} {e1 e2 : A &lt;~&gt; B}
  : (e1 = e2 :&gt; (A -&gt; B)) -&gt; (e1 = e2 :&gt; (A &lt;~&gt; B))
    := equiv_path_equiv e1 e2.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 70
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre>

  Global Instance isequiv_path_equiv {A B : Type} {e1 e2 : A &lt;~&gt; B}
  : IsEquiv (@path_equiv _ _ e1 e2)
    (* Coq can find this instance by itself, but it's slow. *)
    := equiv_isequiv (equiv_path_equiv e1 e2).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 75
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** This implies that types of equivalences inherit truncation.  Note that we only state the theorem for [n.+1]-truncatedness, since it is not true for contractibility: if [B] is contractible but [A] is not, then [A &lt;~&gt; B] is not contractible because it is not inhabited.

   Don't confuse this lemma with [trunc_equiv], which says that if [A] is truncated and [A] is equivalent to [B], then [B] is truncated.  It would be nice to find a better pair of names for them. *)
 </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 80
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance istrunc_equiv {n : trunc_index} {A B : Type} `{IsTrunc n.+1 B}
  : IsTrunc n.+1 (A &lt;~&gt; B).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 81
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 82
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    simpl.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 83
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros e1 e2.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 83
Time: 0.005s">
<div class="time" style="width: 1.5625%"></div>
<pre>
    apply (trunc_equiv _ (equiv_path_equiv e1 e2)).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 84
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 85
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** In the contractible case, we have to assume that *both* types are contractible to get a contractible type of equivalences. *)
 </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 88
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance contr_equiv_contr_contr {A B : Type} `{Contr A} `{Contr B}
  : Contr (A &lt;~&gt; B).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 89
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 90
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    exists equiv_contr_contr.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 91
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros e.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 92
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> apply path_equiv, path_forall.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 92
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros ?; apply contr.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 92
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 93
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** The type of *automorphisms* of an hprop is always contractible *)
 </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 96
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance contr_aut_hprop A `{IsHProp A}
  : Contr (A &lt;~&gt; A).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 97
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 98
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    exists 1%equiv.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 99
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros e; apply path_equiv, path_forall.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 100
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros ?; apply path_ishprop.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 100
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 101
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Equivalences are functorial under equivalences. *)
 </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 104
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre>Definition functor_equiv {A B C D} (h : A &lt;~&gt; C) (k : B &lt;~&gt; D)
  : (A &lt;~&gt; B) -&gt; (C &lt;~&gt; D)
  := fun f =&gt; ((k oE f) oE h^-1).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 106
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Global Instance isequiv_functor_equiv {A B C D} (h : A &lt;~&gt; C) (k : B &lt;~&gt; D)
  : IsEquiv (functor_equiv h k).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 109
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 110
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    refine (isequiv_adjointify _
              (functor_equiv (equiv_inverse h) (equiv_inverse k)) _ _).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 112
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 113
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre> intros f; apply path_equiv, path_arrow; intros x; simpl.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 113
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      exact (eisretr k _ @ ap f (eisretr h x)).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 114
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 115
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre> intros g; apply path_equiv, path_arrow; intros x; simpl.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 115
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      exact (eissect k _ @ ap g (eissect h x)).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 116
Time: 0.002s">
<div class="time" style="width: 0.625%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 117
Time: 0.002s">
<div class="time" style="width: 0.625%"></div>
<pre>

  Definition equiv_functor_equiv {A B C D} (h : A &lt;~&gt; C) (k : B &lt;~&gt; D)
  : (A &lt;~&gt; B) &lt;~&gt; (C &lt;~&gt; D)
  := BuildEquiv _ _ (functor_equiv h k) _.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 121
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Reversing equivalences is an equivalence *)
 </pre>
</div>
<div class="code" title="File: Equiv.v
Line: 124
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance isequiv_equiv_inverse {A B}
  : IsEquiv (@equiv_inverse A B).</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 125
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 126
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre>
    refine (isequiv_adjointify _ equiv_inverse _ _);
      intros e; apply path_equiv; reflexivity.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 128
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 129
Time: 0.001s">
<div class="time" style="width: 0.3125%"></div>
<pre>

  Definition equiv_equiv_inverse A B
  : (A &lt;~&gt; B) &lt;~&gt; (B &lt;~&gt; A)
    := BuildEquiv _ _ (@equiv_inverse A B) _.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 133
Time: 0.011s">
<div class="time" style="width: 3.4375%"></div>
<pre>

End AssumeFunext.</pre>
</div>
<div class="code" title="File: Equiv.v
Line: 136
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>


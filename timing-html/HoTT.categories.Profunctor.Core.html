<html>
<head>
<title>Core.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Core.v</h1>

<div class="code" title="File: Core.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(** * Profunctors *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 1
Time: 0.075s">
<div class="time" style="width: 100%"></div>
<pre>Require Import Category.Core Functor.Core Category.Prod Category.Dual Functor.Prod.Core SetCategory.Core.</pre>
</div>
<div class="code" title="File: Core.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Set Universe Polymorphism.</pre>
</div>
<div class="code" title="File: Core.v
Line: 3
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Set Implicit Arguments.</pre>
</div>
<div class="code" title="File: Core.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Generalizable All Variables.</pre>
</div>
<div class="code" title="File: Core.v
Line: 5
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Set Asymmetric Patterns.</pre>
</div>
<div class="code" title="File: Core.v
Line: 6
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Delimit Scope profunctor_scope with profunctor.</pre>
</div>
<div class="code" title="File: Core.v
Line: 8
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Section profunctor.</pre>
</div>
<div class="code" title="File: Core.v
Line: 10
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** Quoting nCatLab:

      If [C] and [D] are categories, a profunctor from [C] to [D] is a functor [Dᵒᵖ * C -&gt; Set]. Such a profunctor is usually written as [F : C ⇸ D].

      Every functor [f : C -&gt; D] induces two profunctors [D(1, f) : C ⇸ D] and [D(f, 1) : D ⇸ C], defined by [D(1,f)(d,c) = D(d, f(c))] and [D(f, 1)(c,d) = D(f(c), d)]. These profunctors are called representable (or sometimes one of them is corepresentable).

      In particular the identity profunctor [Id : C ⇸ C] is represented by the identity functor and hence is given by the hom-functor [C(−, −) : Cᵒᵖ * C -&gt; Set].

      The notion generalizes to many other kinds of categories. For instance, if [C] and [D] are enriched over some symmetric closed monoidal category [V], then a profunctor from [C] to [D] is a [V]-functor [Dᵒᵖ ⊗ C -&gt; V]. If they are internal categories, then a profunctor [C ⇸ D] is an internal diagram on [Dᵒᵖ * C], and so on. There are also other equivalent definitions in each case; see below.

      A profunctor is also sometimes called a (bi)module or a distributor or a correspondence, though the latter word is also used for a span. The term “module” tends to be common in Australia, especially in the enriched case; here the intuition is that for one-object [V]-categories, i.e. monoids in [V], profunctors really are the same as bimodules between such monoids in the usual sense. “Profunctor” is perhaps more common in the Set-based and internal cases (but is also used in the enriched case); here the intuition is that a profunctor is a generalization of a functor, via the construction of “representable” profunctors. Jean Bénabou, who invented the term and originally used “profunctor,” now prefers “distributor,” which is supposed to carry the intuition that a distributor generalizes a functor in a similar way to how a distribution generalizes a function.

      Note that the convention that a profunctor is a functor [Dᵒᵖ * C -&gt; Set] is not universal; some authors reverse C and D and/or put the “op” on the other one. See the discussion below. *)

 </pre>
</div>
<div class="code" title="File: Core.v
Line: 25
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Context `{Funext}.</pre>
</div>
<div class="code" title="File: Core.v
Line: 25
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Variables C D : PreCategory.</pre>
</div>
<div class="code" title="File: Core.v
Line: 26
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** We capitalize [Profunctor] just like we capitalize [Functor]. *)
 </pre>
</div>
<div class="code" title="File: Core.v
Line: 29
Time: 0.001s">
<div class="time" style="width: 1.3333333333333%"></div>
<pre>Definition Profunctor := Functor (D^op * C) set_cat.</pre>
</div>
<div class="code" title="File: Core.v
Line: 29
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
End profunctor.</pre>
</div>
<div class="code" title="File: Core.v
Line: 30
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Bind Scope profunctor_scope with Profunctor.</pre>
</div>
<div class="code" title="File: Core.v
Line: 32
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Module Export ProfunctorCoreNotations.</pre>
</div>
<div class="code" title="File: Core.v
Line: 34
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Notation "x -|-&gt; y" := (Profunctor x y)
                           (at level 99, right associativity, y at level 200)
                         : type_scope.</pre>
</div>
<div class="code" title="File: Core.v
Line: 37
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
End ProfunctorCoreNotations.</pre>
</div>
<div class="code" title="File: Core.v
Line: 39
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

